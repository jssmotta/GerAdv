// 100% auto-generated by Source Genesys WebApi Front & Back Creator
// copyright © 2000-2025 Menphis - Sistemas Inteligentes
// This file is part of the Source Genesys project                     
namespace MenphisSI.GerAdv.WFiltro.Tests
{
    public class AgendaRelatorioServiceWFiltroTests : IDisposable
    {
        private readonly Mock<IOptions<AppSettings>> _mockAppSettings;
        private readonly Mock<IFAgendaRelatorioFactory> _mockAgendaRelatorioFactory;
        private readonly Mock<IAgendaRelatorioReader> _mockReader;
        private readonly Mock<IAgendaRelatorioValidation> _mockValidation;
        private readonly Mock<HybridCache> _mockCache;
        private readonly Mock<IMemoryCache> _mockMemoryCache;
        private readonly AgendaRelatorioService _service;
        public AgendaRelatorioServiceWFiltroTests()
        {
            _mockAppSettings = new Mock<IOptions<AppSettings>>();
            _mockAgendaRelatorioFactory = new Mock<IFAgendaRelatorioFactory>();
            _mockReader = new Mock<IAgendaRelatorioReader>();
            _mockValidation = new Mock<IAgendaRelatorioValidation>();
            _mockCache = new Mock<HybridCache>();
            _mockMemoryCache = new Mock<IMemoryCache>();
            var appSettings = new AppSettings();
            _mockAppSettings.Setup(x => x.Value).Returns(appSettings);
            _service = new AgendaRelatorioService(_mockAppSettings.Object, _mockAgendaRelatorioFactory.Object, _mockReader.Object, _mockValidation.Object, _mockCache.Object, _mockMemoryCache.Object);
        }

        [Fact]
        public void WFiltro_QuandoFiltroEhNull_DeveRetornarResultadoVazio()
        {
            // Arrange
            FilterAgendaRelatorio? filtro = null;
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().BeNull();
        }

        [Fact]
        public void WFiltro_QuandoTodosCamposSaoValoresPadrao_DeveRetornarResultadoVazio()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio(); // Todos os valores padrão
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_ComTodosOsCamposPreenchidos_DeveProcessarRapidamente()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                vqaData = "24/04/1975",
                vqaProcesso = 1,
                xxxParaNome = "João",
                xxxParaPessoas = "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM",
                xxxBoxAudiencia = "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM",
                xxxBoxAudienciaMobile = "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM",
                xxxNomeAdvogado = "João",
                xxxNomeForo = "João",
                xxxNomeJustica = "João",
                xxxNomeArea = "João",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var stopwatch = System.Diagnostics.Stopwatch.StartNew();
            var resultado = _service.WFiltro(filtro);
            stopwatch.Stop();
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().NotBeEmpty();
            resultado.Value.where.Should().NotBeEmpty();
            stopwatch.ElapsedMilliseconds.Should().BeLessThan(100); // Deve processar em menos de 100ms
        }

#region String Tests
        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_xxxParaNome_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string xxxparanomeComWhitespace)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxParaNome = xxxparanomeComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_xxxParaNome_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var xxxparanomeGigante = new string ('A', 1000);
            var filtro = new FilterAgendaRelatorio
            {
                xxxParaNome = xxxparanomeGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{xxxparanomeGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_xxxParaNome_ComCaracteresEspeciais_DeveProcessarCorretamente(string xxxparanomeComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxParaNome = xxxparanomeComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(xxxparanomeComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_xxxParaNomeAgendaRelatorio_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxParaNome = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_xxxParaNomeAgendaRelatorio_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxParaNome = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_xxxParaNomeAgendaRelatorio_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeAgendaRelatorio = "João Silva";
            var filtro = new FilterAgendaRelatorio
            {
                xxxParaNome = nomeAgendaRelatorio,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_xxxParaNomeAgendaRelatorio_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxParaNome = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_xxxParaNomeAgendaRelatorio_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxParaNome = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_xxxParaNomeAgendaRelatorio_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeAgendaRelatorio)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxParaNome = nomeAgendaRelatorio,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_xxxParaNomeAgendaRelatorio_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxParaNome = "João",
                vqaProcesso = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@xxxParaNome");
            resultado.Value.where.Should().Contain("@vqaProcesso");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @xxxParaNome");
            resultado.Value.where.Should().Contain("= @vqaProcesso");
        }

        [Fact]
        public void WFiltro_xxxParaNomeAgendaRelatorio_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeAgendaRelatorio = "João Silva";
            var filtro = new FilterAgendaRelatorio
            {
                xxxParaNome = nomeAgendaRelatorio,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBAgendaRelatorioDicInfo.PTabelaNome}].[{DBAgendaRelatorioDicInfo.xxxParaNome}]");
            resultado.Value.where.Should().Contain("like @xxxParaNome");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@xxxParaNome");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_xxxParaPessoas_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string xxxparapessoasComWhitespace)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxParaPessoas = xxxparapessoasComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_xxxParaPessoas_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var xxxparapessoasGigante = new string ('A', 1000);
            var filtro = new FilterAgendaRelatorio
            {
                xxxParaPessoas = xxxparapessoasGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{xxxparapessoasGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_xxxParaPessoas_ComCaracteresEspeciais_DeveProcessarCorretamente(string xxxparapessoasComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxParaPessoas = xxxparapessoasComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(xxxparapessoasComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_xxxParaPessoasAgendaRelatorio_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxParaPessoas = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_xxxParaPessoasAgendaRelatorio_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxParaPessoas = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_xxxParaPessoasAgendaRelatorio_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeAgendaRelatorio = "João Silva";
            var filtro = new FilterAgendaRelatorio
            {
                xxxParaPessoas = nomeAgendaRelatorio,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_xxxParaPessoasAgendaRelatorio_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxParaPessoas = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_xxxParaPessoasAgendaRelatorio_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxParaPessoas = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_xxxParaPessoasAgendaRelatorio_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeAgendaRelatorio)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxParaPessoas = nomeAgendaRelatorio,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_xxxParaPessoasAgendaRelatorio_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxParaPessoas = "João",
                vqaProcesso = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@xxxParaPessoas");
            resultado.Value.where.Should().Contain("@vqaProcesso");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @xxxParaPessoas");
            resultado.Value.where.Should().Contain("= @vqaProcesso");
        }

        [Fact]
        public void WFiltro_xxxParaPessoasAgendaRelatorio_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeAgendaRelatorio = "João Silva";
            var filtro = new FilterAgendaRelatorio
            {
                xxxParaPessoas = nomeAgendaRelatorio,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBAgendaRelatorioDicInfo.PTabelaNome}].[{DBAgendaRelatorioDicInfo.xxxParaPessoas}]");
            resultado.Value.where.Should().Contain("like @xxxParaPessoas");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@xxxParaPessoas");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_xxxBoxAudiencia_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string xxxboxaudienciaComWhitespace)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxBoxAudiencia = xxxboxaudienciaComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_xxxBoxAudiencia_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var xxxboxaudienciaGigante = new string ('A', 1000);
            var filtro = new FilterAgendaRelatorio
            {
                xxxBoxAudiencia = xxxboxaudienciaGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{xxxboxaudienciaGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_xxxBoxAudiencia_ComCaracteresEspeciais_DeveProcessarCorretamente(string xxxboxaudienciaComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxBoxAudiencia = xxxboxaudienciaComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(xxxboxaudienciaComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_xxxBoxAudienciaAgendaRelatorio_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxBoxAudiencia = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_xxxBoxAudienciaAgendaRelatorio_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxBoxAudiencia = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_xxxBoxAudienciaAgendaRelatorio_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeAgendaRelatorio = "João Silva";
            var filtro = new FilterAgendaRelatorio
            {
                xxxBoxAudiencia = nomeAgendaRelatorio,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_xxxBoxAudienciaAgendaRelatorio_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxBoxAudiencia = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_xxxBoxAudienciaAgendaRelatorio_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxBoxAudiencia = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_xxxBoxAudienciaAgendaRelatorio_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeAgendaRelatorio)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxBoxAudiencia = nomeAgendaRelatorio,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_xxxBoxAudienciaAgendaRelatorio_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxBoxAudiencia = "João",
                vqaProcesso = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@xxxBoxAudiencia");
            resultado.Value.where.Should().Contain("@vqaProcesso");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @xxxBoxAudiencia");
            resultado.Value.where.Should().Contain("= @vqaProcesso");
        }

        [Fact]
        public void WFiltro_xxxBoxAudienciaAgendaRelatorio_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeAgendaRelatorio = "João Silva";
            var filtro = new FilterAgendaRelatorio
            {
                xxxBoxAudiencia = nomeAgendaRelatorio,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBAgendaRelatorioDicInfo.PTabelaNome}].[{DBAgendaRelatorioDicInfo.xxxBoxAudiencia}]");
            resultado.Value.where.Should().Contain("like @xxxBoxAudiencia");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@xxxBoxAudiencia");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_xxxBoxAudienciaMobile_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string xxxboxaudienciamobileComWhitespace)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxBoxAudienciaMobile = xxxboxaudienciamobileComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_xxxBoxAudienciaMobile_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var xxxboxaudienciamobileGigante = new string ('A', 1000);
            var filtro = new FilterAgendaRelatorio
            {
                xxxBoxAudienciaMobile = xxxboxaudienciamobileGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{xxxboxaudienciamobileGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_xxxBoxAudienciaMobile_ComCaracteresEspeciais_DeveProcessarCorretamente(string xxxboxaudienciamobileComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxBoxAudienciaMobile = xxxboxaudienciamobileComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(xxxboxaudienciamobileComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_xxxBoxAudienciaMobileAgendaRelatorio_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxBoxAudienciaMobile = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_xxxBoxAudienciaMobileAgendaRelatorio_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxBoxAudienciaMobile = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_xxxBoxAudienciaMobileAgendaRelatorio_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeAgendaRelatorio = "João Silva";
            var filtro = new FilterAgendaRelatorio
            {
                xxxBoxAudienciaMobile = nomeAgendaRelatorio,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_xxxBoxAudienciaMobileAgendaRelatorio_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxBoxAudienciaMobile = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_xxxBoxAudienciaMobileAgendaRelatorio_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxBoxAudienciaMobile = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_xxxBoxAudienciaMobileAgendaRelatorio_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeAgendaRelatorio)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxBoxAudienciaMobile = nomeAgendaRelatorio,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_xxxBoxAudienciaMobileAgendaRelatorio_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxBoxAudienciaMobile = "João",
                vqaProcesso = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@xxxBoxAudienciaMobile");
            resultado.Value.where.Should().Contain("@vqaProcesso");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @xxxBoxAudienciaMobile");
            resultado.Value.where.Should().Contain("= @vqaProcesso");
        }

        [Fact]
        public void WFiltro_xxxBoxAudienciaMobileAgendaRelatorio_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeAgendaRelatorio = "João Silva";
            var filtro = new FilterAgendaRelatorio
            {
                xxxBoxAudienciaMobile = nomeAgendaRelatorio,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBAgendaRelatorioDicInfo.PTabelaNome}].[{DBAgendaRelatorioDicInfo.xxxBoxAudienciaMobile}]");
            resultado.Value.where.Should().Contain("like @xxxBoxAudienciaMobile");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@xxxBoxAudienciaMobile");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_xxxNomeAdvogado_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string xxxnomeadvogadoComWhitespace)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeAdvogado = xxxnomeadvogadoComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_xxxNomeAdvogado_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var xxxnomeadvogadoGigante = new string ('A', 1000);
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeAdvogado = xxxnomeadvogadoGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{xxxnomeadvogadoGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_xxxNomeAdvogado_ComCaracteresEspeciais_DeveProcessarCorretamente(string xxxnomeadvogadoComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeAdvogado = xxxnomeadvogadoComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(xxxnomeadvogadoComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_xxxNomeAdvogadoAgendaRelatorio_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeAdvogado = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_xxxNomeAdvogadoAgendaRelatorio_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeAdvogado = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_xxxNomeAdvogadoAgendaRelatorio_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeAgendaRelatorio = "João Silva";
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeAdvogado = nomeAgendaRelatorio,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_xxxNomeAdvogadoAgendaRelatorio_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeAdvogado = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_xxxNomeAdvogadoAgendaRelatorio_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeAdvogado = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_xxxNomeAdvogadoAgendaRelatorio_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeAgendaRelatorio)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeAdvogado = nomeAgendaRelatorio,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_xxxNomeAdvogadoAgendaRelatorio_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeAdvogado = "João",
                vqaProcesso = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@xxxNomeAdvogado");
            resultado.Value.where.Should().Contain("@vqaProcesso");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @xxxNomeAdvogado");
            resultado.Value.where.Should().Contain("= @vqaProcesso");
        }

        [Fact]
        public void WFiltro_xxxNomeAdvogadoAgendaRelatorio_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeAgendaRelatorio = "João Silva";
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeAdvogado = nomeAgendaRelatorio,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBAgendaRelatorioDicInfo.PTabelaNome}].[{DBAgendaRelatorioDicInfo.xxxNomeAdvogado}]");
            resultado.Value.where.Should().Contain("like @xxxNomeAdvogado");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@xxxNomeAdvogado");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_xxxNomeForo_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string xxxnomeforoComWhitespace)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeForo = xxxnomeforoComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_xxxNomeForo_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var xxxnomeforoGigante = new string ('A', 1000);
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeForo = xxxnomeforoGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{xxxnomeforoGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_xxxNomeForo_ComCaracteresEspeciais_DeveProcessarCorretamente(string xxxnomeforoComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeForo = xxxnomeforoComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(xxxnomeforoComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_xxxNomeForoAgendaRelatorio_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeForo = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_xxxNomeForoAgendaRelatorio_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeForo = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_xxxNomeForoAgendaRelatorio_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeAgendaRelatorio = "João Silva";
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeForo = nomeAgendaRelatorio,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_xxxNomeForoAgendaRelatorio_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeForo = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_xxxNomeForoAgendaRelatorio_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeForo = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_xxxNomeForoAgendaRelatorio_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeAgendaRelatorio)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeForo = nomeAgendaRelatorio,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_xxxNomeForoAgendaRelatorio_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeForo = "João",
                vqaProcesso = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@xxxNomeForo");
            resultado.Value.where.Should().Contain("@vqaProcesso");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @xxxNomeForo");
            resultado.Value.where.Should().Contain("= @vqaProcesso");
        }

        [Fact]
        public void WFiltro_xxxNomeForoAgendaRelatorio_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeAgendaRelatorio = "João Silva";
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeForo = nomeAgendaRelatorio,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBAgendaRelatorioDicInfo.PTabelaNome}].[{DBAgendaRelatorioDicInfo.xxxNomeForo}]");
            resultado.Value.where.Should().Contain("like @xxxNomeForo");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@xxxNomeForo");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_xxxNomeJustica_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string xxxnomejusticaComWhitespace)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeJustica = xxxnomejusticaComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_xxxNomeJustica_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var xxxnomejusticaGigante = new string ('A', 1000);
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeJustica = xxxnomejusticaGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{xxxnomejusticaGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_xxxNomeJustica_ComCaracteresEspeciais_DeveProcessarCorretamente(string xxxnomejusticaComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeJustica = xxxnomejusticaComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(xxxnomejusticaComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_xxxNomeJusticaAgendaRelatorio_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeJustica = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_xxxNomeJusticaAgendaRelatorio_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeJustica = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_xxxNomeJusticaAgendaRelatorio_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeAgendaRelatorio = "João Silva";
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeJustica = nomeAgendaRelatorio,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_xxxNomeJusticaAgendaRelatorio_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeJustica = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_xxxNomeJusticaAgendaRelatorio_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeJustica = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_xxxNomeJusticaAgendaRelatorio_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeAgendaRelatorio)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeJustica = nomeAgendaRelatorio,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_xxxNomeJusticaAgendaRelatorio_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeJustica = "João",
                vqaProcesso = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@xxxNomeJustica");
            resultado.Value.where.Should().Contain("@vqaProcesso");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @xxxNomeJustica");
            resultado.Value.where.Should().Contain("= @vqaProcesso");
        }

        [Fact]
        public void WFiltro_xxxNomeJusticaAgendaRelatorio_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeAgendaRelatorio = "João Silva";
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeJustica = nomeAgendaRelatorio,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBAgendaRelatorioDicInfo.PTabelaNome}].[{DBAgendaRelatorioDicInfo.xxxNomeJustica}]");
            resultado.Value.where.Should().Contain("like @xxxNomeJustica");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@xxxNomeJustica");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_xxxNomeArea_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string xxxnomeareaComWhitespace)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeArea = xxxnomeareaComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_xxxNomeArea_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var xxxnomeareaGigante = new string ('A', 1000);
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeArea = xxxnomeareaGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{xxxnomeareaGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_xxxNomeArea_ComCaracteresEspeciais_DeveProcessarCorretamente(string xxxnomeareaComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeArea = xxxnomeareaComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(xxxnomeareaComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_xxxNomeAreaAgendaRelatorio_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeArea = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_xxxNomeAreaAgendaRelatorio_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeArea = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_xxxNomeAreaAgendaRelatorio_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeAgendaRelatorio = "João Silva";
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeArea = nomeAgendaRelatorio,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_xxxNomeAreaAgendaRelatorio_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeArea = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_xxxNomeAreaAgendaRelatorio_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeArea = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_xxxNomeAreaAgendaRelatorio_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeAgendaRelatorio)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeArea = nomeAgendaRelatorio,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_xxxNomeAreaAgendaRelatorio_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeArea = "João",
                vqaProcesso = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@xxxNomeArea");
            resultado.Value.where.Should().Contain("@vqaProcesso");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @xxxNomeArea");
            resultado.Value.where.Should().Contain("= @vqaProcesso");
        }

        [Fact]
        public void WFiltro_xxxNomeAreaAgendaRelatorio_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeAgendaRelatorio = "João Silva";
            var filtro = new FilterAgendaRelatorio
            {
                xxxNomeArea = nomeAgendaRelatorio,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBAgendaRelatorioDicInfo.PTabelaNome}].[{DBAgendaRelatorioDicInfo.xxxNomeArea}]");
            resultado.Value.where.Should().Contain("like @xxxNomeArea");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@xxxNomeArea");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

#endregion
#region Integer Tests
#region filtro.vqaProcesso_end Tests
        [Fact]
        public void WFiltro_vqaProcesso_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                vqaProcesso_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_vqaProcesso_end_QuandoTemValorPositivo_SemvqaProcessoInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorvqaProcessoEnd = 5000;
            var filtro = new FilterAgendaRelatorio
            {
                vqaProcesso = int.MinValue, // Não define salário inicial
                vqaProcesso_end = valorvqaProcessoEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há vqaProcesso inicial válido, não deve incluir condição WHERE, mas o parâmetro vqaProcesso_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // vqaProcesso_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_vqaProcesso_end_QuandoSomenteValorInicial_SemvqaProcessoEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorvqaProcesso = 2500;
            var filtro = new FilterAgendaRelatorio
            {
                vqaProcesso = valorvqaProcesso,
                vqaProcesso_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBAgendaRelatorioDicInfo.PTabelaNome}].[{DBAgendaRelatorioDicInfo.vqaProcesso}] = @{DBAgendaRelatorioDicInfo.vqaProcesso}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBAgendaRelatorioDicInfo.vqaProcesso}");
            parametro.Value.Should().Be(valorvqaProcesso);
        }

        [Fact]
        public void WFiltro_vqaProcesso_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorvqaProcessoInicial = 1000;
            var valorvqaProcessoFinal = 5000;
            var filtro = new FilterAgendaRelatorio
            {
                vqaProcesso = valorvqaProcessoInicial,
                vqaProcesso_end = valorvqaProcessoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBAgendaRelatorioDicInfo.PTabelaNome}].{DBAgendaRelatorioDicInfo.vqaProcesso} BETWEEN @{DBAgendaRelatorioDicInfo.vqaProcesso} AND @{DBAgendaRelatorioDicInfo.vqaProcesso}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAgendaRelatorioDicInfo.vqaProcesso}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAgendaRelatorioDicInfo.vqaProcesso}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorvqaProcessoInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorvqaProcessoFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_vqaProcesso_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                vqaProcesso = valorInicial,
                vqaProcesso_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBAgendaRelatorioDicInfo.vqaProcesso}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBAgendaRelatorioDicInfo.vqaProcesso}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_vqaProcesso_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                vqaProcesso = 1000,
                vqaProcesso_end = 5000,
                xxxParaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBAgendaRelatorioDicInfo.vqaProcesso}");
            resultado.Value.where.Should().Contain($"@{DBAgendaRelatorioDicInfo.xxxParaNome}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_vqaProcesso_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                vqaProcesso = 1000,
                vqaProcesso_end = 5000,
                xxxParaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_vqaProcesso_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                vqaProcesso = 1000,
                vqaProcesso_end = 5000,
                xxxParaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_vqaProcesso_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                vqaProcesso = 1000,
                vqaProcesso_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBAgendaRelatorioDicInfo.PTabelaNome}].{DBAgendaRelatorioDicInfo.vqaProcesso} BETWEEN");
        }

        [Fact]
        public void WFiltro_vqaProcesso_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                vqaProcesso = 1000,
                vqaProcesso_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_vqaProcesso_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                vqaProcesso = 1000,
                vqaProcesso_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_vqaProcesso_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorvqaProcessoInicial = 2500;
            var valorvqaProcessoFinal = 4750;
            var filtro = new FilterAgendaRelatorio
            {
                vqaProcesso = valorvqaProcessoInicial,
                vqaProcesso_end = valorvqaProcessoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBAgendaRelatorioDicInfo.vqaProcesso}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBAgendaRelatorioDicInfo.vqaProcesso}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorvqaProcessoInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorvqaProcessoFinal);
        }

        [Fact]
        public void WFiltro_vqaProcesso_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                vqaProcesso = 0,
                vqaProcesso_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_vqaProcesso_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                vqaProcesso = 0,
                vqaProcesso_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_vqaProcesso_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                vqaProcesso = 1500,
                vqaProcesso_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.vqaProcesso == int.MinValue) && !(filtro.vqaProcesso_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBAgendaRelatorioDicInfo.PTabelaNome}].{DBAgendaRelatorioDicInfo.vqaProcesso} BETWEEN @{DBAgendaRelatorioDicInfo.vqaProcesso} AND @{DBAgendaRelatorioDicInfo.vqaProcesso}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_vqaProcesso_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                vqaProcesso = 2000,
                vqaProcesso_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.vqaProcesso == int.MinValue) && filtro.vqaProcesso_end == int.MinValue
            // Deve resultar em igualdade quando apenas vqaProcesso tem valor válido
            resultado.Value.where.Should().Be($"[{DBAgendaRelatorioDicInfo.PTabelaNome}].[{DBAgendaRelatorioDicInfo.vqaProcesso}] = @{DBAgendaRelatorioDicInfo.vqaProcesso}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_vqaProcesso_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                vqaProcesso = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.vqaProcesso Isolated Tests
        [Fact]
        public void WFiltro_vqaProcesso_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                vqaProcesso = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_vqaProcesso_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorvqaProcesso = 5;
            var filtro = new FilterAgendaRelatorio
            {
                vqaProcesso = valorvqaProcesso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBAgendaRelatorioDicInfo.PTabelaNome}].[{DBAgendaRelatorioDicInfo.vqaProcesso}] = @{DBAgendaRelatorioDicInfo.vqaProcesso}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBAgendaRelatorioDicInfo.vqaProcesso}");
            parametro.Value.Should().Be(valorvqaProcesso);
        }

        [Fact]
        public void WFiltro_vqaProcesso_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorvqaProcesso = 0;
            var filtro = new FilterAgendaRelatorio
            {
                vqaProcesso = valorvqaProcesso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBAgendaRelatorioDicInfo.vqaProcesso}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorvqaProcesso);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_vqaProcesso_DiferentesValoresValidos_DeveProcessarCorretamente(int valorvqaProcesso)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                vqaProcesso = valorvqaProcesso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorvqaProcesso);
            resultado.Value.where.Should().Contain($"= @{DBAgendaRelatorioDicInfo.vqaProcesso}");
        }

        [Fact]
        public void WFiltro_vqaProcesso_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                vqaProcesso = 1,
                xxxParaNome = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBAgendaRelatorioDicInfo.vqaProcesso}");
            resultado.Value.where.Should().Contain($"@{DBAgendaRelatorioDicInfo.xxxParaNome}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_vqaProcesso_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                vqaProcesso = 1,
                xxxParaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_vqaProcesso_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                vqaProcesso = 1,
                xxxParaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_vqaProcesso_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                vqaProcesso = 1,
                xxxParaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_vqaProcesso_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                vqaProcesso = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBAgendaRelatorioDicInfo.PTabelaNome}].[{DBAgendaRelatorioDicInfo.vqaProcesso}]");
        }

        [Fact]
        public void WFiltro_vqaProcesso_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                vqaProcesso = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_vqaProcesso_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                vqaProcesso = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_vqaProcesso_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                vqaProcesso = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_vqaProcesso_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorvqaProcesso = 42;
            var filtro = new FilterAgendaRelatorio
            {
                vqaProcesso = valorvqaProcesso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorvqaProcesso);
        }

#endregion
        [Fact]
        public void WFiltro_vqaProcesso_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                vqaProcesso = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_vqaProcesso_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorvqaProcesso = 1;
            var filtro = new FilterAgendaRelatorio
            {
                vqaProcesso = valorvqaProcesso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do vqaProcesso
            resultado.Value.where.Should().Contain($"[{DBAgendaRelatorioDicInfo.PTabelaNome}].[{DBAgendaRelatorioDicInfo.vqaProcesso}] = @vqaProcesso");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@vqaProcesso");
            parametro.Value.Should().Be(valorvqaProcesso);
        }

        [Fact]
        public void WFiltro_vqaProcesso_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                vqaProcesso = 1,
                xxxParaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@vqaProcesso");
            resultado.Value.where.Should().Contain($"@{DBAgendaRelatorioDicInfo.xxxParaNome}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_vqaProcesso_DiferentesValores_DeveFuncionar(int valorvqaProcesso)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                vqaProcesso = valorvqaProcesso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorvqaProcesso);
        }

#endregion
#region Decimal Tests
#endregion
#region DateTime Tests
        [Theory]
        [InlineData("31/12/9999")] // Data máxima
        [InlineData("01/01/1900")] // Data muito antiga
        [InlineData("29/02/2024")] // Ano bissexto
        public void WFiltro_vqaData_ComDatasExtremas_DeveProcessarCorretamente(string dataExtrema)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                vqaData = dataExtrema,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<DateTime>();
        }

        [Theory]
        [InlineData("32/12/2023")] // Dia inválido
        [InlineData("31/13/2023")] // Mês inválido
        [InlineData("29/02/2023")] // Não é ano bissexto
        [InlineData("abc/def/ghij")] // Formato completamente inválido
        public void WFiltro_vqaData_ComDatasInvalidas_NaoDeveAdicionarParametros(string dataInvalida)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                vqaData = dataInvalida,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().BeEmpty();
            resultado.Value.where.Should().BeEmpty();
        }

#region vqaData Tests
        [Fact]
        public void WFiltro_vqaData_WhenEmptyOrNull_ShouldNotAddParameters()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                vqaData = string.Empty,
                vqaData_end = null,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_vqaData_WhenValidSingleDate_ShouldAddParameterAndGenerateWhereClause()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterAgendaRelatorio
            {
                vqaData = testDate,
                vqaData_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(1);
            var parameter = result.Value.parametros.First();
            parameter.ParameterName.Should().Be($"@{DBAgendaRelatorioDicInfo.vqaData}");
            parameter.Value.Should().BeOfType<DateTime>();
            var expectedDate = DateTime.Parse(testDate);
            ((DateTime)parameter.Value).Should().Be(expectedDate);
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBAgendaRelatorioDicInfo.PTabelaNome}].[{DBAgendaRelatorioDicInfo.vqaData}], 103) = CONVERT(DATE, @{DBAgendaRelatorioDicInfo.vqaData}, 103)");
        }

        [Fact]
        public void WFiltro_vqaData_WhenValidDateRange_ShouldAddBothParametersAndGenerateBetweenClause()
        {
            // Arrange
            var startDate = "01/06/2023";
            var endDate = "30/06/2023";
            var filtro = new FilterAgendaRelatorio
            {
                vqaData = startDate,
                vqaData_end = endDate,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(2);
            var startParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAgendaRelatorioDicInfo.vqaData}");
            var endParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAgendaRelatorioDicInfo.vqaData}_end");
            startParameter.Should().NotBeNull();
            endParameter.Should().NotBeNull();
            startParameter!.Value.Should().BeOfType<DateTime>();
            endParameter!.Value.Should().BeOfType<DateTime>();
            ((DateTime)startParameter.Value).Should().Be(DateTime.Parse(startDate));
            ((DateTime)endParameter.Value).Should().Be(DateTime.Parse(endDate));
            result.Value.where.Should().Contain($"[{DBAgendaRelatorioDicInfo.PTabelaNome}].{DBAgendaRelatorioDicInfo.vqaData} BETWEEN @{DBAgendaRelatorioDicInfo.vqaData} AND @{DBAgendaRelatorioDicInfo.vqaData}_end");
        }

        [Fact]
        public void WFiltro_vqaData_WhenInvalidDateFormat_ShouldNotAddParameter()
        {
            // Arrange
            var invalidDate = "invalid-date";
            var filtro = new FilterAgendaRelatorio
            {
                vqaData = invalidDate,
                vqaData_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_vqaData_WhenStartDateValidButEndDateInvalid_ShouldOnlyAddStartParameterAndGenerateSingleDateClause()
        {
            // Arrange
            var validStartDate = "15/06/2023";
            var invalidEndDate = "invalid-date";
            var filtro = new FilterAgendaRelatorio
            {
                vqaData = validStartDate,
                vqaData_end = invalidEndDate,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(1);
            var parameter = result.Value.parametros.First();
            parameter.ParameterName.Should().Be($"@{DBAgendaRelatorioDicInfo.vqaData}");
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBAgendaRelatorioDicInfo.PTabelaNome}].[{DBAgendaRelatorioDicInfo.vqaData}], 103) = CONVERT(DATE, @{DBAgendaRelatorioDicInfo.vqaData}, 103)");
            result.Value.where.Should().NotContain("BETWEEN");
        }

        [Fact]
        public void WFiltro_vqaData_WhenStartDateInvalidButEndDateValid_ShouldNotAddAnyParameters()
        {
            // Arrange
            var invalidStartDate = "invalid-date";
            var validEndDate = "30/06/2023";
            var filtro = new FilterAgendaRelatorio
            {
                vqaData = invalidStartDate,
                vqaData_end = validEndDate,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_vqaData_WhenWhitespaceOnlyDates_ShouldNotAddParameters()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                vqaData = "   ",
                vqaData_end = "\t\n",
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_vqaData_WithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterAgendaRelatorio
            {
                xxxParaNome = "A",
                vqaData = testDate,
                vqaData_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(2); // Nome + vqaData
            result.Value.where.Should().Contain(TSql.And);
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBAgendaRelatorioDicInfo.PTabelaNome}].[{DBAgendaRelatorioDicInfo.vqaData}], 103) = CONVERT(DATE, @{DBAgendaRelatorioDicInfo.vqaData}, 103)");
        }

        [Fact]
        public void WFiltro_vqaData_WithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterAgendaRelatorio
            {
                xxxParaNome = "A",
                vqaData = testDate,
                vqaData_end = string.Empty,
                LogicalOperator = TSql.OR
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(TSql.OR);
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBAgendaRelatorioDicInfo.PTabelaNome}].[{DBAgendaRelatorioDicInfo.vqaData}], 103) = CONVERT(DATE, @{DBAgendaRelatorioDicInfo.vqaData}, 103)");
        }

        [Fact]
        public void WFiltro_vqaData_WhenOnlyEndDateProvided_ShouldNotAddParameters()
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                vqaData = string.Empty,
                vqaData_end = "30/06/2023",
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_vqaData_WhenDateTimeMinValue_ShouldNotAddParameters()
        {
            // Arrange
            var minValueDate = DateTime.MinValue.ToString("dd/MM/yyyy");
            var filtro = new FilterAgendaRelatorio
            {
                vqaData = minValueDate,
                vqaData_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // The IsEmptyDX extension method should catch DateTime.MinValue and return true
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_vqaData_AsFirstFilter_ShouldNotIncludeLogicalOperatorAtStart()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterAgendaRelatorio
            {
                vqaData = testDate,
                vqaData_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().NotStartWith(TSql.And);
            result.Value.where.Should().StartWith($"CONVERT(DATE,[{DBAgendaRelatorioDicInfo.PTabelaNome}].[{DBAgendaRelatorioDicInfo.vqaData}], 103)");
        }

        [Theory]
        [InlineData("15/06/2023", "2023-06-15T00:00:00")]
        [InlineData("01/01/2024", "2024-01-01T00:00:00")]
        [InlineData("31/12/2022", "2022-12-31T00:00:00")]
        public void WFiltro_vqaData_WhenVariousValidDateFormats_ShouldParseCorrectly(string inputDate, string expectedDateTimeString)
        {
            // Arrange
            var filtro = new FilterAgendaRelatorio
            {
                vqaData = inputDate,
                vqaData_end = string.Empty,
                LogicalOperator = TSql.And
            };
            var expectedDateTime = DateTime.Parse(expectedDateTimeString);
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(1);
            var parameter = result.Value.parametros.First();
            ((DateTime)parameter.Value).Should().Be(expectedDateTime);
        }

#endregion
#endregion
#region Bool Tests
#endregion
        [Fact]
        public void Dispose_CalledOnce_DisposesCorrectly()
        {
            // Act
            _service.Dispose();
            // Assert - Should not throw any exception
            Assert.True(true);
        }

        [Fact]
        public void Dispose_CalledTwice_DoesNotThrow()
        {
            // Act
            _service.Dispose();
            _service.Dispose();
            // Assert - Should not throw any exception
            Assert.True(true);
        }

        public virtual void Dispose()
        {
            _service?.Dispose();
        }
    }
}