// 100% auto-generated by Source Genesys WebApi Front & Back Creator
// copyright © 2000-2025 Menphis - Sistemas Inteligentes
// This file is part of the Source Genesys project                     
namespace MenphisSI.GerAdv.WFiltro.Tests
{
    public class ProcessOutputEngineServiceWFiltroTests : IDisposable
    {
        private readonly Mock<IOptions<AppSettings>> _mockAppSettings;
        private readonly Mock<IFProcessOutputEngineFactory> _mockProcessOutputEngineFactory;
        private readonly Mock<IProcessOutputEngineReader> _mockReader;
        private readonly Mock<IProcessOutputEngineValidation> _mockValidation;
        private readonly Mock<IProcessOutputEngineWriter> _mockWriter;
        private readonly Mock<IProcessOutputRequestService> _mockProcessOutputRequestService;
        private readonly Mock<HybridCache> _mockCache;
        private readonly Mock<IMemoryCache> _mockMemoryCache;
        private readonly ProcessOutputEngineService _service;
        public ProcessOutputEngineServiceWFiltroTests()
        {
            _mockAppSettings = new Mock<IOptions<AppSettings>>();
            _mockProcessOutputEngineFactory = new Mock<IFProcessOutputEngineFactory>();
            _mockReader = new Mock<IProcessOutputEngineReader>();
            _mockValidation = new Mock<IProcessOutputEngineValidation>();
            _mockWriter = new Mock<IProcessOutputEngineWriter>();
            _mockProcessOutputRequestService = new Mock<IProcessOutputRequestService>();
            _mockCache = new Mock<HybridCache>();
            _mockMemoryCache = new Mock<IMemoryCache>();
            var appSettings = new AppSettings();
            _mockAppSettings.Setup(x => x.Value).Returns(appSettings);
            _service = new ProcessOutputEngineService(_mockAppSettings.Object, _mockProcessOutputEngineFactory.Object, _mockReader.Object, _mockValidation.Object, _mockWriter.Object, _mockProcessOutputRequestService.Object, _mockCache.Object, _mockMemoryCache.Object);
        }

        [Fact]
        public void WFiltro_QuandoFiltroEhNull_DeveRetornarResultadoVazio()
        {
            // Arrange
            FilterProcessOutputEngine? filtro = null;
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().BeNull();
        }

        [Fact]
        public void WFiltro_QuandoTodosCamposSaoValoresPadrao_DeveRetornarResultadoVazio()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine(); // Todos os valores padrão
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_ComTodosOsCamposPreenchidos_DeveProcessarRapidamente()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Nome = "João",
                Database = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
                Tabela = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
                Campo = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
                Valor = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
                Output = "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM",
                Administrador = 2,
                OutputSource = 1,
                DisabledItem = 1,
                IDModulo = 1,
                IsOnlyProcesso = 2,
                MyID = 1,
                GUID = Guid.NewGuid().ToString(),
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var stopwatch = System.Diagnostics.Stopwatch.StartNew();
            var resultado = _service.WFiltro(filtro);
            stopwatch.Stop();
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().NotBeEmpty();
            resultado.Value.where.Should().NotBeEmpty();
            stopwatch.ElapsedMilliseconds.Should().BeLessThan(100); // Deve processar em menos de 100ms
        }

#region String Tests
        [Fact]
        public void WFiltro_Nome_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource = 1,
                Nome = "João",
                LogicalOperator = null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltroNome_LogicalOperatorVazioOuNulo_DeveUsarAndPorPadrao(string logicalOperator)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Nome = "João",
                OutputSource = 2,
                LogicalOperator = logicalOperator
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_Nome_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string nomeComWhitespace)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Nome = nomeComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_Nome_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var nomeGigante = new string ('A', 1000);
            var filtro = new FilterProcessOutputEngine
            {
                Nome = nomeGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{nomeGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_Nome_ComCaracteresEspeciais_DeveProcessarCorretamente(string nomeComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Nome = nomeComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(nomeComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_NomeProcessOutputEngine_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Nome = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_NomeProcessOutputEngine_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Nome = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_NomeProcessOutputEngine_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeProcessOutputEngine = "João Silva";
            var filtro = new FilterProcessOutputEngine
            {
                Nome = nomeProcessOutputEngine,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_NomeProcessOutputEngine_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Nome = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_NomeProcessOutputEngine_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Nome = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_NomeProcessOutputEngine_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeProcessOutputEngine)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Nome = nomeProcessOutputEngine,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_NomeProcessOutputEngine_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Nome = "João",
                OutputSource = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@poeNome");
            resultado.Value.where.Should().Contain("@poeOutputSource");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @poeNome");
            resultado.Value.where.Should().Contain("= @poeOutputSource");
        }

        [Fact]
        public void WFiltro_NomeProcessOutputEngine_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeProcessOutputEngine = "João Silva";
            var filtro = new FilterProcessOutputEngine
            {
                Nome = nomeProcessOutputEngine,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].[{DBProcessOutputEngineDicInfo.Nome}]");
            resultado.Value.where.Should().Contain("like @poeNome");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@poeNome");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_Database_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string databaseComWhitespace)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Database = databaseComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_Database_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var databaseGigante = new string ('A', 1000);
            var filtro = new FilterProcessOutputEngine
            {
                Database = databaseGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{databaseGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_Database_ComCaracteresEspeciais_DeveProcessarCorretamente(string databaseComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Database = databaseComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(databaseComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_DatabaseProcessOutputEngine_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Database = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_DatabaseProcessOutputEngine_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Database = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_DatabaseProcessOutputEngine_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeProcessOutputEngine = "João Silva";
            var filtro = new FilterProcessOutputEngine
            {
                Database = nomeProcessOutputEngine,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_DatabaseProcessOutputEngine_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Database = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_DatabaseProcessOutputEngine_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Database = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_DatabaseProcessOutputEngine_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeProcessOutputEngine)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Database = nomeProcessOutputEngine,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DatabaseProcessOutputEngine_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Database = "João",
                OutputSource = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@poeDatabase");
            resultado.Value.where.Should().Contain("@poeOutputSource");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @poeDatabase");
            resultado.Value.where.Should().Contain("= @poeOutputSource");
        }

        [Fact]
        public void WFiltro_DatabaseProcessOutputEngine_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeProcessOutputEngine = "João Silva";
            var filtro = new FilterProcessOutputEngine
            {
                Database = nomeProcessOutputEngine,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].[{DBProcessOutputEngineDicInfo.Database}]");
            resultado.Value.where.Should().Contain("like @poeDatabase");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@poeDatabase");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_Tabela_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string tabelaComWhitespace)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Tabela = tabelaComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_Tabela_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var tabelaGigante = new string ('A', 1000);
            var filtro = new FilterProcessOutputEngine
            {
                Tabela = tabelaGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{tabelaGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_Tabela_ComCaracteresEspeciais_DeveProcessarCorretamente(string tabelaComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Tabela = tabelaComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(tabelaComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_TabelaProcessOutputEngine_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Tabela = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_TabelaProcessOutputEngine_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Tabela = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_TabelaProcessOutputEngine_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeProcessOutputEngine = "João Silva";
            var filtro = new FilterProcessOutputEngine
            {
                Tabela = nomeProcessOutputEngine,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_TabelaProcessOutputEngine_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Tabela = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_TabelaProcessOutputEngine_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Tabela = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_TabelaProcessOutputEngine_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeProcessOutputEngine)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Tabela = nomeProcessOutputEngine,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_TabelaProcessOutputEngine_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Tabela = "João",
                OutputSource = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@poeTabela");
            resultado.Value.where.Should().Contain("@poeOutputSource");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @poeTabela");
            resultado.Value.where.Should().Contain("= @poeOutputSource");
        }

        [Fact]
        public void WFiltro_TabelaProcessOutputEngine_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeProcessOutputEngine = "João Silva";
            var filtro = new FilterProcessOutputEngine
            {
                Tabela = nomeProcessOutputEngine,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].[{DBProcessOutputEngineDicInfo.Tabela}]");
            resultado.Value.where.Should().Contain("like @poeTabela");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@poeTabela");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_Campo_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string campoComWhitespace)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Campo = campoComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_Campo_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var campoGigante = new string ('A', 1000);
            var filtro = new FilterProcessOutputEngine
            {
                Campo = campoGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{campoGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_Campo_ComCaracteresEspeciais_DeveProcessarCorretamente(string campoComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Campo = campoComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(campoComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_CampoProcessOutputEngine_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Campo = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_CampoProcessOutputEngine_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Campo = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_CampoProcessOutputEngine_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeProcessOutputEngine = "João Silva";
            var filtro = new FilterProcessOutputEngine
            {
                Campo = nomeProcessOutputEngine,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_CampoProcessOutputEngine_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Campo = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_CampoProcessOutputEngine_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Campo = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_CampoProcessOutputEngine_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeProcessOutputEngine)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Campo = nomeProcessOutputEngine,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_CampoProcessOutputEngine_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Campo = "João",
                OutputSource = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@poeCampo");
            resultado.Value.where.Should().Contain("@poeOutputSource");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @poeCampo");
            resultado.Value.where.Should().Contain("= @poeOutputSource");
        }

        [Fact]
        public void WFiltro_CampoProcessOutputEngine_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeProcessOutputEngine = "João Silva";
            var filtro = new FilterProcessOutputEngine
            {
                Campo = nomeProcessOutputEngine,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].[{DBProcessOutputEngineDicInfo.Campo}]");
            resultado.Value.where.Should().Contain("like @poeCampo");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@poeCampo");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_Valor_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string valorComWhitespace)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Valor = valorComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_Valor_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var valorGigante = new string ('A', 1000);
            var filtro = new FilterProcessOutputEngine
            {
                Valor = valorGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{valorGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_Valor_ComCaracteresEspeciais_DeveProcessarCorretamente(string valorComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Valor = valorComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(valorComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_ValorProcessOutputEngine_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Valor = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_ValorProcessOutputEngine_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Valor = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_ValorProcessOutputEngine_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeProcessOutputEngine = "João Silva";
            var filtro = new FilterProcessOutputEngine
            {
                Valor = nomeProcessOutputEngine,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_ValorProcessOutputEngine_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Valor = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_ValorProcessOutputEngine_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Valor = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_ValorProcessOutputEngine_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeProcessOutputEngine)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Valor = nomeProcessOutputEngine,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_ValorProcessOutputEngine_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Valor = "João",
                OutputSource = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@poeValor");
            resultado.Value.where.Should().Contain("@poeOutputSource");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @poeValor");
            resultado.Value.where.Should().Contain("= @poeOutputSource");
        }

        [Fact]
        public void WFiltro_ValorProcessOutputEngine_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeProcessOutputEngine = "João Silva";
            var filtro = new FilterProcessOutputEngine
            {
                Valor = nomeProcessOutputEngine,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].[{DBProcessOutputEngineDicInfo.Valor}]");
            resultado.Value.where.Should().Contain("like @poeValor");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@poeValor");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_Output_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string outputComWhitespace)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Output = outputComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_Output_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var outputGigante = new string ('A', 1000);
            var filtro = new FilterProcessOutputEngine
            {
                Output = outputGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{outputGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_Output_ComCaracteresEspeciais_DeveProcessarCorretamente(string outputComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Output = outputComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(outputComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_OutputProcessOutputEngine_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Output = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_OutputProcessOutputEngine_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Output = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_OutputProcessOutputEngine_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeProcessOutputEngine = "João Silva";
            var filtro = new FilterProcessOutputEngine
            {
                Output = nomeProcessOutputEngine,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_OutputProcessOutputEngine_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Output = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_OutputProcessOutputEngine_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Output = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_OutputProcessOutputEngine_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeProcessOutputEngine)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Output = nomeProcessOutputEngine,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_OutputProcessOutputEngine_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Output = "João",
                OutputSource = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@poeOutput");
            resultado.Value.where.Should().Contain("@poeOutputSource");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @poeOutput");
            resultado.Value.where.Should().Contain("= @poeOutputSource");
        }

        [Fact]
        public void WFiltro_OutputProcessOutputEngine_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeProcessOutputEngine = "João Silva";
            var filtro = new FilterProcessOutputEngine
            {
                Output = nomeProcessOutputEngine,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].[{DBProcessOutputEngineDicInfo.Output}]");
            resultado.Value.where.Should().Contain("like @poeOutput");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@poeOutput");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_GUID_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string guidComWhitespace)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                GUID = guidComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_GUID_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var guidGigante = new string ('A', 1000);
            var filtro = new FilterProcessOutputEngine
            {
                GUID = guidGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{guidGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_GUID_ComCaracteresEspeciais_DeveProcessarCorretamente(string guidComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                GUID = guidComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(guidComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_GUIDProcessOutputEngine_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                GUID = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_GUIDProcessOutputEngine_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                GUID = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_GUIDProcessOutputEngine_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeProcessOutputEngine = "João Silva";
            var filtro = new FilterProcessOutputEngine
            {
                GUID = nomeProcessOutputEngine,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_GUIDProcessOutputEngine_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                GUID = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_GUIDProcessOutputEngine_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                GUID = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_GUIDProcessOutputEngine_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeProcessOutputEngine)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                GUID = nomeProcessOutputEngine,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_GUIDProcessOutputEngine_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                GUID = "João",
                OutputSource = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@poeGUID");
            resultado.Value.where.Should().Contain("@poeOutputSource");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @poeGUID");
            resultado.Value.where.Should().Contain("= @poeOutputSource");
        }

        [Fact]
        public void WFiltro_GUIDProcessOutputEngine_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeProcessOutputEngine = "João Silva";
            var filtro = new FilterProcessOutputEngine
            {
                GUID = nomeProcessOutputEngine,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].[{DBProcessOutputEngineDicInfo.GUID}]");
            resultado.Value.where.Should().Contain("like @poeGUID");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@poeGUID");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

#endregion
#region Integer Tests
#region filtro.OutputSource_end Tests
        [Fact]
        public void WFiltro_OutputSource_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_OutputSource_end_QuandoTemValorPositivo_SemOutputSourceInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorOutputSourceEnd = 5000;
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource = int.MinValue, // Não define salário inicial
                OutputSource_end = valorOutputSourceEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há OutputSource inicial válido, não deve incluir condição WHERE, mas o parâmetro OutputSource_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // OutputSource_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_OutputSource_end_QuandoSomenteValorInicial_SemOutputSourceEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorOutputSource = 2500;
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource = valorOutputSource,
                OutputSource_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].[{DBProcessOutputEngineDicInfo.OutputSource}] = @{DBProcessOutputEngineDicInfo.OutputSource}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBProcessOutputEngineDicInfo.OutputSource}");
            parametro.Value.Should().Be(valorOutputSource);
        }

        [Fact]
        public void WFiltro_OutputSource_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorOutputSourceInicial = 1000;
            var valorOutputSourceFinal = 5000;
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource = valorOutputSourceInicial,
                OutputSource_end = valorOutputSourceFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].{DBProcessOutputEngineDicInfo.OutputSource} BETWEEN @{DBProcessOutputEngineDicInfo.OutputSource} AND @{DBProcessOutputEngineDicInfo.OutputSource}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBProcessOutputEngineDicInfo.OutputSource}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBProcessOutputEngineDicInfo.OutputSource}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorOutputSourceInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorOutputSourceFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_OutputSource_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource = valorInicial,
                OutputSource_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBProcessOutputEngineDicInfo.OutputSource}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBProcessOutputEngineDicInfo.OutputSource}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_OutputSource_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource = 1000,
                OutputSource_end = 5000,
                Database = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBProcessOutputEngineDicInfo.OutputSource}");
            resultado.Value.where.Should().Contain($"@{DBProcessOutputEngineDicInfo.Database}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_OutputSource_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource = 1000,
                OutputSource_end = 5000,
                Database = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_OutputSource_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource = 1000,
                OutputSource_end = 5000,
                Database = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_OutputSource_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource = 1000,
                OutputSource_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].{DBProcessOutputEngineDicInfo.OutputSource} BETWEEN");
        }

        [Fact]
        public void WFiltro_OutputSource_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource = 1000,
                OutputSource_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_OutputSource_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource = 1000,
                OutputSource_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_OutputSource_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorOutputSourceInicial = 2500;
            var valorOutputSourceFinal = 4750;
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource = valorOutputSourceInicial,
                OutputSource_end = valorOutputSourceFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBProcessOutputEngineDicInfo.OutputSource}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBProcessOutputEngineDicInfo.OutputSource}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorOutputSourceInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorOutputSourceFinal);
        }

        [Fact]
        public void WFiltro_OutputSource_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource = 0,
                OutputSource_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_OutputSource_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource = 0,
                OutputSource_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_OutputSource_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource = 1500,
                OutputSource_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.OutputSource == int.MinValue) && !(filtro.OutputSource_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].{DBProcessOutputEngineDicInfo.OutputSource} BETWEEN @{DBProcessOutputEngineDicInfo.OutputSource} AND @{DBProcessOutputEngineDicInfo.OutputSource}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_OutputSource_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource = 2000,
                OutputSource_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.OutputSource == int.MinValue) && filtro.OutputSource_end == int.MinValue
            // Deve resultar em igualdade quando apenas OutputSource tem valor válido
            resultado.Value.where.Should().Be($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].[{DBProcessOutputEngineDicInfo.OutputSource}] = @{DBProcessOutputEngineDicInfo.OutputSource}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_OutputSource_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.OutputSource Isolated Tests
        [Fact]
        public void WFiltro_OutputSource_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_OutputSource_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorOutputSource = 5;
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource = valorOutputSource,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].[{DBProcessOutputEngineDicInfo.OutputSource}] = @{DBProcessOutputEngineDicInfo.OutputSource}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBProcessOutputEngineDicInfo.OutputSource}");
            parametro.Value.Should().Be(valorOutputSource);
        }

        [Fact]
        public void WFiltro_OutputSource_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorOutputSource = 0;
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource = valorOutputSource,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBProcessOutputEngineDicInfo.OutputSource}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorOutputSource);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_OutputSource_DiferentesValoresValidos_DeveProcessarCorretamente(int valorOutputSource)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource = valorOutputSource,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorOutputSource);
            resultado.Value.where.Should().Contain($"= @{DBProcessOutputEngineDicInfo.OutputSource}");
        }

        [Fact]
        public void WFiltro_OutputSource_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource = 1,
                Database = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBProcessOutputEngineDicInfo.OutputSource}");
            resultado.Value.where.Should().Contain($"@{DBProcessOutputEngineDicInfo.Database}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_OutputSource_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource = 1,
                Database = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_OutputSource_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource = 1,
                Database = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_OutputSource_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource = 1,
                Database = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_OutputSource_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].[{DBProcessOutputEngineDicInfo.OutputSource}]");
        }

        [Fact]
        public void WFiltro_OutputSource_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_OutputSource_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_OutputSource_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_OutputSource_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorOutputSource = 42;
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource = valorOutputSource,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorOutputSource);
        }

#endregion
        [Fact]
        public void WFiltro_OutputSource_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_OutputSource_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorOutputSource = 1;
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource = valorOutputSource,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do OutputSource
            resultado.Value.where.Should().Contain($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].[{DBProcessOutputEngineDicInfo.OutputSource}] = @poeOutputSource");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@poeOutputSource");
            parametro.Value.Should().Be(valorOutputSource);
        }

        [Fact]
        public void WFiltro_OutputSource_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource = 1,
                Database = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@poeOutputSource");
            resultado.Value.where.Should().Contain($"@{DBProcessOutputEngineDicInfo.Database}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_OutputSource_DiferentesValores_DeveFuncionar(int valorOutputSource)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                OutputSource = valorOutputSource,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorOutputSource);
        }

#region filtro.IDModulo_end Tests
        [Fact]
        public void WFiltro_IDModulo_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                IDModulo_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_IDModulo_end_QuandoTemValorPositivo_SemIDModuloInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorIDModuloEnd = 5000;
            var filtro = new FilterProcessOutputEngine
            {
                IDModulo = int.MinValue, // Não define salário inicial
                IDModulo_end = valorIDModuloEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há IDModulo inicial válido, não deve incluir condição WHERE, mas o parâmetro IDModulo_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // IDModulo_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_IDModulo_end_QuandoSomenteValorInicial_SemIDModuloEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorIDModulo = 2500;
            var filtro = new FilterProcessOutputEngine
            {
                IDModulo = valorIDModulo,
                IDModulo_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].[{DBProcessOutputEngineDicInfo.IDModulo}] = @{DBProcessOutputEngineDicInfo.IDModulo}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBProcessOutputEngineDicInfo.IDModulo}");
            parametro.Value.Should().Be(valorIDModulo);
        }

        [Fact]
        public void WFiltro_IDModulo_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorIDModuloInicial = 1000;
            var valorIDModuloFinal = 5000;
            var filtro = new FilterProcessOutputEngine
            {
                IDModulo = valorIDModuloInicial,
                IDModulo_end = valorIDModuloFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].{DBProcessOutputEngineDicInfo.IDModulo} BETWEEN @{DBProcessOutputEngineDicInfo.IDModulo} AND @{DBProcessOutputEngineDicInfo.IDModulo}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBProcessOutputEngineDicInfo.IDModulo}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBProcessOutputEngineDicInfo.IDModulo}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorIDModuloInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorIDModuloFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_IDModulo_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                IDModulo = valorInicial,
                IDModulo_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBProcessOutputEngineDicInfo.IDModulo}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBProcessOutputEngineDicInfo.IDModulo}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_IDModulo_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                IDModulo = 1000,
                IDModulo_end = 5000,
                Database = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBProcessOutputEngineDicInfo.IDModulo}");
            resultado.Value.where.Should().Contain($"@{DBProcessOutputEngineDicInfo.Database}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_IDModulo_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                IDModulo = 1000,
                IDModulo_end = 5000,
                Database = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_IDModulo_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                IDModulo = 1000,
                IDModulo_end = 5000,
                Database = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_IDModulo_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                IDModulo = 1000,
                IDModulo_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].{DBProcessOutputEngineDicInfo.IDModulo} BETWEEN");
        }

        [Fact]
        public void WFiltro_IDModulo_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                IDModulo = 1000,
                IDModulo_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_IDModulo_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                IDModulo = 1000,
                IDModulo_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_IDModulo_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorIDModuloInicial = 2500;
            var valorIDModuloFinal = 4750;
            var filtro = new FilterProcessOutputEngine
            {
                IDModulo = valorIDModuloInicial,
                IDModulo_end = valorIDModuloFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBProcessOutputEngineDicInfo.IDModulo}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBProcessOutputEngineDicInfo.IDModulo}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorIDModuloInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorIDModuloFinal);
        }

        [Fact]
        public void WFiltro_IDModulo_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                IDModulo = 0,
                IDModulo_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_IDModulo_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                IDModulo = 0,
                IDModulo_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_IDModulo_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                IDModulo = 1500,
                IDModulo_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.IDModulo == int.MinValue) && !(filtro.IDModulo_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].{DBProcessOutputEngineDicInfo.IDModulo} BETWEEN @{DBProcessOutputEngineDicInfo.IDModulo} AND @{DBProcessOutputEngineDicInfo.IDModulo}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_IDModulo_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                IDModulo = 2000,
                IDModulo_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.IDModulo == int.MinValue) && filtro.IDModulo_end == int.MinValue
            // Deve resultar em igualdade quando apenas IDModulo tem valor válido
            resultado.Value.where.Should().Be($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].[{DBProcessOutputEngineDicInfo.IDModulo}] = @{DBProcessOutputEngineDicInfo.IDModulo}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_IDModulo_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                IDModulo = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.IDModulo Isolated Tests
        [Fact]
        public void WFiltro_IDModulo_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                IDModulo = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_IDModulo_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorIDModulo = 5;
            var filtro = new FilterProcessOutputEngine
            {
                IDModulo = valorIDModulo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].[{DBProcessOutputEngineDicInfo.IDModulo}] = @{DBProcessOutputEngineDicInfo.IDModulo}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBProcessOutputEngineDicInfo.IDModulo}");
            parametro.Value.Should().Be(valorIDModulo);
        }

        [Fact]
        public void WFiltro_IDModulo_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorIDModulo = 0;
            var filtro = new FilterProcessOutputEngine
            {
                IDModulo = valorIDModulo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBProcessOutputEngineDicInfo.IDModulo}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorIDModulo);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_IDModulo_DiferentesValoresValidos_DeveProcessarCorretamente(int valorIDModulo)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                IDModulo = valorIDModulo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorIDModulo);
            resultado.Value.where.Should().Contain($"= @{DBProcessOutputEngineDicInfo.IDModulo}");
        }

        [Fact]
        public void WFiltro_IDModulo_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                IDModulo = 1,
                Database = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBProcessOutputEngineDicInfo.IDModulo}");
            resultado.Value.where.Should().Contain($"@{DBProcessOutputEngineDicInfo.Database}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_IDModulo_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                IDModulo = 1,
                Database = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_IDModulo_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                IDModulo = 1,
                Database = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_IDModulo_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                IDModulo = 1,
                Database = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_IDModulo_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                IDModulo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].[{DBProcessOutputEngineDicInfo.IDModulo}]");
        }

        [Fact]
        public void WFiltro_IDModulo_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                IDModulo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_IDModulo_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                IDModulo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_IDModulo_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                IDModulo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_IDModulo_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorIDModulo = 42;
            var filtro = new FilterProcessOutputEngine
            {
                IDModulo = valorIDModulo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorIDModulo);
        }

#endregion
        [Fact]
        public void WFiltro_IDModulo_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                IDModulo = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_IDModulo_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorIDModulo = 1;
            var filtro = new FilterProcessOutputEngine
            {
                IDModulo = valorIDModulo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do IDModulo
            resultado.Value.where.Should().Contain($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].[{DBProcessOutputEngineDicInfo.IDModulo}] = @poeIDModulo");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@poeIDModulo");
            parametro.Value.Should().Be(valorIDModulo);
        }

        [Fact]
        public void WFiltro_IDModulo_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                IDModulo = 1,
                Database = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@poeIDModulo");
            resultado.Value.where.Should().Contain($"@{DBProcessOutputEngineDicInfo.Database}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_IDModulo_DiferentesValores_DeveFuncionar(int valorIDModulo)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                IDModulo = valorIDModulo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorIDModulo);
        }

#region filtro.MyID_end Tests
        [Fact]
        public void WFiltro_MyID_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                MyID_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_MyID_end_QuandoTemValorPositivo_SemMyIDInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorMyIDEnd = 5000;
            var filtro = new FilterProcessOutputEngine
            {
                MyID = int.MinValue, // Não define salário inicial
                MyID_end = valorMyIDEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há MyID inicial válido, não deve incluir condição WHERE, mas o parâmetro MyID_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // MyID_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_MyID_end_QuandoSomenteValorInicial_SemMyIDEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorMyID = 2500;
            var filtro = new FilterProcessOutputEngine
            {
                MyID = valorMyID,
                MyID_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].[{DBProcessOutputEngineDicInfo.MyID}] = @{DBProcessOutputEngineDicInfo.MyID}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBProcessOutputEngineDicInfo.MyID}");
            parametro.Value.Should().Be(valorMyID);
        }

        [Fact]
        public void WFiltro_MyID_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorMyIDInicial = 1000;
            var valorMyIDFinal = 5000;
            var filtro = new FilterProcessOutputEngine
            {
                MyID = valorMyIDInicial,
                MyID_end = valorMyIDFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].{DBProcessOutputEngineDicInfo.MyID} BETWEEN @{DBProcessOutputEngineDicInfo.MyID} AND @{DBProcessOutputEngineDicInfo.MyID}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBProcessOutputEngineDicInfo.MyID}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBProcessOutputEngineDicInfo.MyID}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorMyIDInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorMyIDFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_MyID_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                MyID = valorInicial,
                MyID_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBProcessOutputEngineDicInfo.MyID}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBProcessOutputEngineDicInfo.MyID}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_MyID_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                MyID = 1000,
                MyID_end = 5000,
                Database = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBProcessOutputEngineDicInfo.MyID}");
            resultado.Value.where.Should().Contain($"@{DBProcessOutputEngineDicInfo.Database}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_MyID_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                MyID = 1000,
                MyID_end = 5000,
                Database = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_MyID_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                MyID = 1000,
                MyID_end = 5000,
                Database = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_MyID_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                MyID = 1000,
                MyID_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].{DBProcessOutputEngineDicInfo.MyID} BETWEEN");
        }

        [Fact]
        public void WFiltro_MyID_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                MyID = 1000,
                MyID_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_MyID_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                MyID = 1000,
                MyID_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_MyID_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorMyIDInicial = 2500;
            var valorMyIDFinal = 4750;
            var filtro = new FilterProcessOutputEngine
            {
                MyID = valorMyIDInicial,
                MyID_end = valorMyIDFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBProcessOutputEngineDicInfo.MyID}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBProcessOutputEngineDicInfo.MyID}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorMyIDInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorMyIDFinal);
        }

        [Fact]
        public void WFiltro_MyID_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                MyID = 0,
                MyID_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_MyID_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                MyID = 0,
                MyID_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_MyID_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                MyID = 1500,
                MyID_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.MyID == int.MinValue) && !(filtro.MyID_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].{DBProcessOutputEngineDicInfo.MyID} BETWEEN @{DBProcessOutputEngineDicInfo.MyID} AND @{DBProcessOutputEngineDicInfo.MyID}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_MyID_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                MyID = 2000,
                MyID_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.MyID == int.MinValue) && filtro.MyID_end == int.MinValue
            // Deve resultar em igualdade quando apenas MyID tem valor válido
            resultado.Value.where.Should().Be($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].[{DBProcessOutputEngineDicInfo.MyID}] = @{DBProcessOutputEngineDicInfo.MyID}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_MyID_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                MyID = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.MyID Isolated Tests
        [Fact]
        public void WFiltro_MyID_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                MyID = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_MyID_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorMyID = 5;
            var filtro = new FilterProcessOutputEngine
            {
                MyID = valorMyID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].[{DBProcessOutputEngineDicInfo.MyID}] = @{DBProcessOutputEngineDicInfo.MyID}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBProcessOutputEngineDicInfo.MyID}");
            parametro.Value.Should().Be(valorMyID);
        }

        [Fact]
        public void WFiltro_MyID_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorMyID = 0;
            var filtro = new FilterProcessOutputEngine
            {
                MyID = valorMyID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBProcessOutputEngineDicInfo.MyID}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorMyID);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_MyID_DiferentesValoresValidos_DeveProcessarCorretamente(int valorMyID)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                MyID = valorMyID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorMyID);
            resultado.Value.where.Should().Contain($"= @{DBProcessOutputEngineDicInfo.MyID}");
        }

        [Fact]
        public void WFiltro_MyID_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                MyID = 1,
                Database = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBProcessOutputEngineDicInfo.MyID}");
            resultado.Value.where.Should().Contain($"@{DBProcessOutputEngineDicInfo.Database}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_MyID_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                MyID = 1,
                Database = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_MyID_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                MyID = 1,
                Database = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_MyID_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                MyID = 1,
                Database = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_MyID_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                MyID = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].[{DBProcessOutputEngineDicInfo.MyID}]");
        }

        [Fact]
        public void WFiltro_MyID_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                MyID = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_MyID_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                MyID = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_MyID_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                MyID = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_MyID_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorMyID = 42;
            var filtro = new FilterProcessOutputEngine
            {
                MyID = valorMyID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorMyID);
        }

#endregion
        [Fact]
        public void WFiltro_MyID_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                MyID = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_MyID_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorMyID = 1;
            var filtro = new FilterProcessOutputEngine
            {
                MyID = valorMyID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do MyID
            resultado.Value.where.Should().Contain($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].[{DBProcessOutputEngineDicInfo.MyID}] = @poeMyID");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@poeMyID");
            parametro.Value.Should().Be(valorMyID);
        }

        [Fact]
        public void WFiltro_MyID_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                MyID = 1,
                Database = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@poeMyID");
            resultado.Value.where.Should().Contain($"@{DBProcessOutputEngineDicInfo.Database}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_MyID_DiferentesValores_DeveFuncionar(int valorMyID)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                MyID = valorMyID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorMyID);
        }

#region filtro.Codigo_filtro_end Tests
        [Fact]
        public void WFiltro_Codigo_filtro_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Codigo_filtro_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Codigo_filtro_end_QuandoTemValorPositivo_SemCodigo_filtroInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorCodigo_filtroEnd = 5000;
            var filtro = new FilterProcessOutputEngine
            {
                Codigo_filtro = int.MinValue, // Não define salário inicial
                Codigo_filtro_end = valorCodigo_filtroEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Codigo_filtro inicial válido, não deve incluir condição WHERE, mas o parâmetro Codigo_filtro_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Codigo_filtro_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Codigo_filtro_end_QuandoSomenteValorInicial_SemCodigo_filtroEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorCodigo_filtro = 2500;
            var filtro = new FilterProcessOutputEngine
            {
                Codigo_filtro = valorCodigo_filtro,
                Codigo_filtro_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].[{DBProcessOutputEngineDicInfo.CampoCodigo}] = @{DBProcessOutputEngineDicInfo.CampoCodigo}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBProcessOutputEngineDicInfo.CampoCodigo}");
            parametro.Value.Should().Be(valorCodigo_filtro);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorCodigo_filtroInicial = 1000;
            var valorCodigo_filtroFinal = 5000;
            var filtro = new FilterProcessOutputEngine
            {
                Codigo_filtro = valorCodigo_filtroInicial,
                Codigo_filtro_end = valorCodigo_filtroFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].{DBProcessOutputEngineDicInfo.CampoCodigo} BETWEEN @{DBProcessOutputEngineDicInfo.CampoCodigo} AND @{DBProcessOutputEngineDicInfo.CampoCodigo}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBProcessOutputEngineDicInfo.CampoCodigo}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBProcessOutputEngineDicInfo.CampoCodigo}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorCodigo_filtroInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorCodigo_filtroFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Codigo_filtro_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Codigo_filtro = valorInicial,
                Codigo_filtro_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBProcessOutputEngineDicInfo.CampoCodigo}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBProcessOutputEngineDicInfo.CampoCodigo}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                Database = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBProcessOutputEngineDicInfo.CampoCodigo}");
            resultado.Value.where.Should().Contain($"@{DBProcessOutputEngineDicInfo.Database}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                Database = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                Database = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].{DBProcessOutputEngineDicInfo.CampoCodigo} BETWEEN");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorCodigo_filtroInicial = 2500;
            var valorCodigo_filtroFinal = 4750;
            var filtro = new FilterProcessOutputEngine
            {
                Codigo_filtro = valorCodigo_filtroInicial,
                Codigo_filtro_end = valorCodigo_filtroFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBProcessOutputEngineDicInfo.CampoCodigo}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBProcessOutputEngineDicInfo.CampoCodigo}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorCodigo_filtroInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorCodigo_filtroFinal);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Codigo_filtro = 0,
                Codigo_filtro_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Codigo_filtro = 0,
                Codigo_filtro_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Codigo_filtro = 1500,
                Codigo_filtro_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Codigo_filtro == int.MinValue) && !(filtro.Codigo_filtro_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].{DBProcessOutputEngineDicInfo.CampoCodigo} BETWEEN @{DBProcessOutputEngineDicInfo.CampoCodigo} AND @{DBProcessOutputEngineDicInfo.CampoCodigo}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Codigo_filtro = 2000,
                Codigo_filtro_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Codigo_filtro == int.MinValue) && filtro.Codigo_filtro_end == int.MinValue
            // Deve resultar em igualdade quando apenas Codigo_filtro tem valor válido
            resultado.Value.where.Should().Be($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].[{DBProcessOutputEngineDicInfo.CampoCodigo}] = @{DBProcessOutputEngineDicInfo.CampoCodigo}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Codigo_filtro_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Codigo_filtro = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Codigo_filtro Isolated Tests
        [Fact]
        public void WFiltro_Codigo_filtro_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Codigo_filtro = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorCodigo_filtro = 5;
            var filtro = new FilterProcessOutputEngine
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].[{DBProcessOutputEngineDicInfo.CampoCodigo}] = @{DBProcessOutputEngineDicInfo.CampoCodigo}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBProcessOutputEngineDicInfo.CampoCodigo}");
            parametro.Value.Should().Be(valorCodigo_filtro);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorCodigo_filtro = 0;
            var filtro = new FilterProcessOutputEngine
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBProcessOutputEngineDicInfo.CampoCodigo}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCodigo_filtro);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Codigo_filtro_DiferentesValoresValidos_DeveProcessarCorretamente(int valorCodigo_filtro)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCodigo_filtro);
            resultado.Value.where.Should().Contain($"= @{DBProcessOutputEngineDicInfo.CampoCodigo}");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Codigo_filtro = 1,
                Database = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBProcessOutputEngineDicInfo.CampoCodigo}");
            resultado.Value.where.Should().Contain($"@{DBProcessOutputEngineDicInfo.Database}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Codigo_filtro = 1,
                Database = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Codigo_filtro = 1,
                Database = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Codigo_filtro = 1,
                Database = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Codigo_filtro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].[{DBProcessOutputEngineDicInfo.CampoCodigo}]");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Codigo_filtro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Codigo_filtro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Codigo_filtro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorCodigo_filtro = 42;
            var filtro = new FilterProcessOutputEngine
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorCodigo_filtro);
        }

#endregion
        [Fact]
        public void WFiltro_Codigo_filtro_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Codigo_filtro = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorCodigo_filtro = 1;
            var filtro = new FilterProcessOutputEngine
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Codigo_filtro
            resultado.Value.where.Should().Contain($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].[{DBProcessOutputEngineDicInfo.CampoCodigo}] = @{DBProcessOutputEngineDicInfo.CampoCodigo}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBProcessOutputEngineDicInfo.CampoCodigo}");
            parametro.Value.Should().Be(valorCodigo_filtro);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Codigo_filtro = 1,
                Database = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@{DBProcessOutputEngineDicInfo.CampoCodigo}");
            resultado.Value.where.Should().Contain($"@{DBProcessOutputEngineDicInfo.Database}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Codigo_filtro_DiferentesValores_DeveFuncionar(int valorCodigo_filtro)
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCodigo_filtro);
        }

#endregion
#region Decimal Tests
#endregion
#region DateTime Tests
#endregion
#region Bool Tests
#region Administrador Filter Tests
        [Fact]
        public void WFiltro_AdministradorEqualsIntMinValue_ShouldNotAddParameterOrWhereClause()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Administrador = int.MinValue
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().NotContain(p => p.ParameterName.Contains(DBProcessOutputEngineDicInfo.Administrador));
            result.Value.where.Should().NotContain(DBProcessOutputEngineDicInfo.Administrador);
        }

        [Fact]
        public void WFiltro_AdministradorHasValidValue_ShouldAddParameterAndWhereClause()
        {
            // Arrange
            var AdministradorValue = 1;
            var filtro = new FilterProcessOutputEngine
            {
                Administrador = AdministradorValue,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // Check parameter
            var AdministradorParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBProcessOutputEngineDicInfo.Administrador}");
            AdministradorParameter.Should().NotBeNull();
            AdministradorParameter.Value.Should().Be(AdministradorValue);
            // Check where clause
            result.Value.where.Should().Contain($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].[{DBProcessOutputEngineDicInfo.Administrador}] = @{DBProcessOutputEngineDicInfo.Administrador}");
        }

        [Fact]
        public void WFiltro_AdministradorWithDifferentValues_ShouldAddCorrectParameterValue()
        {
            // Arrange & Act & Assert for Administrador = 0 (typically female)
            var filtroFemale = new FilterProcessOutputEngine
            {
                Administrador = 0
            };
            var resultFemale = _service.WFiltro(filtroFemale);
            resultFemale.Should().NotBeNull();
            var femaleParam = resultFemale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBProcessOutputEngineDicInfo.Administrador}");
            femaleParam.Should().NotBeNull();
            femaleParam.Value.Should().Be(0);
            // Arrange & Act & Assert for Administrador = 1 (typically male)
            var filtroMale = new FilterProcessOutputEngine
            {
                Administrador = 1
            };
            var resultMale = _service.WFiltro(filtroMale);
            resultMale.Should().NotBeNull();
            var maleParam = resultMale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBProcessOutputEngineDicInfo.Administrador}");
            maleParam.Should().NotBeNull();
            maleParam.Value.Should().Be(1);
        }

        [Fact]
        public void WFiltro_AdministradorAsFirstFilter_ShouldNotIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Administrador = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().StartWith($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].[{DBProcessOutputEngineDicInfo.Administrador}] = @{DBProcessOutputEngineDicInfo.Administrador}");
            result.Value.where.Should().NotStartWith(" AND ");
        }

        [Fact]
        public void WFiltro_AdministradorWithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Database = "Database",
                Administrador = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain($" AND ");
        }

        [Fact]
        public void WFiltro_AdministradorWithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Database = "Database",
                Administrador = 1,
                LogicalOperator = " OR "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(" OR ");
        }

#endregion
#region DisabledItem Filter Tests
        [Fact]
        public void WFiltro_DisabledItemEqualsIntMinValue_ShouldNotAddParameterOrWhereClause()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                DisabledItem = int.MinValue
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().NotContain(p => p.ParameterName.Contains(DBProcessOutputEngineDicInfo.DisabledItem));
            result.Value.where.Should().NotContain(DBProcessOutputEngineDicInfo.DisabledItem);
        }

        [Fact]
        public void WFiltro_DisabledItemHasValidValue_ShouldAddParameterAndWhereClause()
        {
            // Arrange
            var DisabledItemValue = 1;
            var filtro = new FilterProcessOutputEngine
            {
                DisabledItem = DisabledItemValue,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // Check parameter
            var DisabledItemParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBProcessOutputEngineDicInfo.DisabledItem}");
            DisabledItemParameter.Should().NotBeNull();
            DisabledItemParameter.Value.Should().Be(DisabledItemValue);
            // Check where clause
            result.Value.where.Should().Contain($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].[{DBProcessOutputEngineDicInfo.DisabledItem}] = @{DBProcessOutputEngineDicInfo.DisabledItem}");
        }

        [Fact]
        public void WFiltro_DisabledItemWithDifferentValues_ShouldAddCorrectParameterValue()
        {
            // Arrange & Act & Assert for DisabledItem = 0 (typically female)
            var filtroFemale = new FilterProcessOutputEngine
            {
                DisabledItem = 0
            };
            var resultFemale = _service.WFiltro(filtroFemale);
            resultFemale.Should().NotBeNull();
            var femaleParam = resultFemale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBProcessOutputEngineDicInfo.DisabledItem}");
            femaleParam.Should().NotBeNull();
            femaleParam.Value.Should().Be(0);
            // Arrange & Act & Assert for DisabledItem = 1 (typically male)
            var filtroMale = new FilterProcessOutputEngine
            {
                DisabledItem = 1
            };
            var resultMale = _service.WFiltro(filtroMale);
            resultMale.Should().NotBeNull();
            var maleParam = resultMale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBProcessOutputEngineDicInfo.DisabledItem}");
            maleParam.Should().NotBeNull();
            maleParam.Value.Should().Be(1);
        }

        [Fact]
        public void WFiltro_DisabledItemAsFirstFilter_ShouldNotIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                DisabledItem = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().StartWith($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].[{DBProcessOutputEngineDicInfo.DisabledItem}] = @{DBProcessOutputEngineDicInfo.DisabledItem}");
            result.Value.where.Should().NotStartWith(" AND ");
        }

        [Fact]
        public void WFiltro_DisabledItemWithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Database = "Database",
                DisabledItem = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain($" AND ");
        }

        [Fact]
        public void WFiltro_DisabledItemWithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Database = "Database",
                DisabledItem = 1,
                LogicalOperator = " OR "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(" OR ");
        }

#endregion
#region IsOnlyProcesso Filter Tests
        [Fact]
        public void WFiltro_IsOnlyProcessoEqualsIntMinValue_ShouldNotAddParameterOrWhereClause()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                IsOnlyProcesso = int.MinValue
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().NotContain(p => p.ParameterName.Contains(DBProcessOutputEngineDicInfo.IsOnlyProcesso));
            result.Value.where.Should().NotContain(DBProcessOutputEngineDicInfo.IsOnlyProcesso);
        }

        [Fact]
        public void WFiltro_IsOnlyProcessoHasValidValue_ShouldAddParameterAndWhereClause()
        {
            // Arrange
            var IsOnlyProcessoValue = 1;
            var filtro = new FilterProcessOutputEngine
            {
                IsOnlyProcesso = IsOnlyProcessoValue,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // Check parameter
            var IsOnlyProcessoParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBProcessOutputEngineDicInfo.IsOnlyProcesso}");
            IsOnlyProcessoParameter.Should().NotBeNull();
            IsOnlyProcessoParameter.Value.Should().Be(IsOnlyProcessoValue);
            // Check where clause
            result.Value.where.Should().Contain($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].[{DBProcessOutputEngineDicInfo.IsOnlyProcesso}] = @{DBProcessOutputEngineDicInfo.IsOnlyProcesso}");
        }

        [Fact]
        public void WFiltro_IsOnlyProcessoWithDifferentValues_ShouldAddCorrectParameterValue()
        {
            // Arrange & Act & Assert for IsOnlyProcesso = 0 (typically female)
            var filtroFemale = new FilterProcessOutputEngine
            {
                IsOnlyProcesso = 0
            };
            var resultFemale = _service.WFiltro(filtroFemale);
            resultFemale.Should().NotBeNull();
            var femaleParam = resultFemale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBProcessOutputEngineDicInfo.IsOnlyProcesso}");
            femaleParam.Should().NotBeNull();
            femaleParam.Value.Should().Be(0);
            // Arrange & Act & Assert for IsOnlyProcesso = 1 (typically male)
            var filtroMale = new FilterProcessOutputEngine
            {
                IsOnlyProcesso = 1
            };
            var resultMale = _service.WFiltro(filtroMale);
            resultMale.Should().NotBeNull();
            var maleParam = resultMale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBProcessOutputEngineDicInfo.IsOnlyProcesso}");
            maleParam.Should().NotBeNull();
            maleParam.Value.Should().Be(1);
        }

        [Fact]
        public void WFiltro_IsOnlyProcessoAsFirstFilter_ShouldNotIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                IsOnlyProcesso = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().StartWith($"[{DBProcessOutputEngineDicInfo.PTabelaNome}].[{DBProcessOutputEngineDicInfo.IsOnlyProcesso}] = @{DBProcessOutputEngineDicInfo.IsOnlyProcesso}");
            result.Value.where.Should().NotStartWith(" AND ");
        }

        [Fact]
        public void WFiltro_IsOnlyProcessoWithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Database = "Database",
                IsOnlyProcesso = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain($" AND ");
        }

        [Fact]
        public void WFiltro_IsOnlyProcessoWithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var filtro = new FilterProcessOutputEngine
            {
                Database = "Database",
                IsOnlyProcesso = 1,
                LogicalOperator = " OR "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(" OR ");
        }

#endregion
#endregion
        [Fact]
        public void Dispose_CalledOnce_DisposesCorrectly()
        {
            // Act
            _service.Dispose();
            // Assert - Should not throw any exception
            Assert.True(true);
        }

        [Fact]
        public void Dispose_CalledTwice_DoesNotThrow()
        {
            // Act
            _service.Dispose();
            _service.Dispose();
            // Assert - Should not throw any exception
            Assert.True(true);
        }

        public virtual void Dispose()
        {
            _service?.Dispose();
        }
    }
}