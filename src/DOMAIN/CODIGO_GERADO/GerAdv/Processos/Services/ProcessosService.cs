// 100% auto-generated by Source Genesys WebApi Front & Back Creator
// copyright © 2000-2025 Menphis - Sistemas Inteligentes
// This file is part of the Source Genesys project                     
#pragma warning disable IDE0130 // Namespace does not match folder structure

namespace MenphisSI.GerAdv.Services;
#pragma warning restore IDE0130 // Namespace does not match folder structure

public partial class ProcessosService(IOptions<AppSettings> appSettings, IFProcessosFactory processosFactory, IProcessosReader reader, IProcessosValidation validation, IProcessosWriter writer, IAdvogadosReader advogadosReader, IJusticaReader justicaReader, IPrepostosReader prepostosReader, IClientesReader clientesReader, IOponentesReader oponentesReader, IAreaReader areaReader, ICidadeReader cidadeReader, ISituacaoReader situacaoReader, IRitoReader ritoReader, IAtividadesReader atividadesReader, IAgendaService agendaService, IAgendaFinanceiroService agendafinanceiroService, IAgendaRepetirService agendarepetirService, IAndamentosMDService andamentosmdService, IApensoService apensoService, IApenso2Service apenso2Service, IContaCorrenteService contacorrenteService, IContatoCRMService contatocrmService, IContratosService contratosService, IDocumentosService documentosService, IEnderecoSistemaService enderecosistemaService, IHistoricoService historicoService, IHonorariosDadosContratoService honorariosdadoscontratoService, IHorasTrabService horastrabService, IInstanciaService instanciaService, ILigacoesService ligacoesService, ILivroCaixaService livrocaixaService, INENotasService nenotasService, IParceriaProcService parceriaprocService, IParteClienteOutrasService parteclienteoutrasService, IPenhoraService penhoraService, IPrecatoriaService precatoriaService, IProCDAService procdaService, IProcessosObsReportService processosobsreportService, IProcessosParadosService processosparadosService, IProcessOutputRequestService processoutputrequestService, IProDepositosService prodepositosService, IProDespesasService prodespesasService, IProObservacoesService proobservacoesService, IProPartesService propartesService, IProProcuradoresService proprocuradoresService, IProResumosService proresumosService, IProSucumbenciaService prosucumbenciaService, IProValoresService provaloresService, IRecadosService recadosService, ITerceirosService terceirosService, IUltimosProcessosService ultimosprocessosService, IHttpContextAccessor httpContextAccessor, HybridCache cache, IMemoryCache memory) : IProcessosService, IDisposable
{
    private readonly IHttpContextAccessor _httpContextAccessor = httpContextAccessor;
    private readonly IOptions<AppSettings> _appSettings = appSettings;
    private readonly HybridCache _cache = cache;
    private readonly IMemoryCache _memoryCache = memory;
    private bool _disposed;
    private readonly IFProcessosFactory processosFactory = processosFactory;
    private readonly IProcessosReader reader = reader;
    private readonly IProcessosValidation validation = validation;
    private readonly IProcessosWriter writer = writer;
    private readonly IAdvogadosReader advogadosReader = advogadosReader;
    private readonly IJusticaReader justicaReader = justicaReader;
    private readonly IPrepostosReader prepostosReader = prepostosReader;
    private readonly IClientesReader clientesReader = clientesReader;
    private readonly IOponentesReader oponentesReader = oponentesReader;
    private readonly IAreaReader areaReader = areaReader;
    private readonly ICidadeReader cidadeReader = cidadeReader;
    private readonly ISituacaoReader situacaoReader = situacaoReader;
    private readonly IRitoReader ritoReader = ritoReader;
    private readonly IAtividadesReader atividadesReader = atividadesReader;
    private readonly IAgendaService agendaService = agendaService;
    private readonly IAgendaFinanceiroService agendafinanceiroService = agendafinanceiroService;
    private readonly IAgendaRepetirService agendarepetirService = agendarepetirService;
    private readonly IAndamentosMDService andamentosmdService = andamentosmdService;
    private readonly IApensoService apensoService = apensoService;
    private readonly IApenso2Service apenso2Service = apenso2Service;
    private readonly IContaCorrenteService contacorrenteService = contacorrenteService;
    private readonly IContatoCRMService contatocrmService = contatocrmService;
    private readonly IContratosService contratosService = contratosService;
    private readonly IDocumentosService documentosService = documentosService;
    private readonly IEnderecoSistemaService enderecosistemaService = enderecosistemaService;
    private readonly IHistoricoService historicoService = historicoService;
    private readonly IHonorariosDadosContratoService honorariosdadoscontratoService = honorariosdadoscontratoService;
    private readonly IHorasTrabService horastrabService = horastrabService;
    private readonly IInstanciaService instanciaService = instanciaService;
    private readonly ILigacoesService ligacoesService = ligacoesService;
    private readonly ILivroCaixaService livrocaixaService = livrocaixaService;
    private readonly INENotasService nenotasService = nenotasService;
    private readonly IParceriaProcService parceriaprocService = parceriaprocService;
    private readonly IParteClienteOutrasService parteclienteoutrasService = parteclienteoutrasService;
    private readonly IPenhoraService penhoraService = penhoraService;
    private readonly IPrecatoriaService precatoriaService = precatoriaService;
    private readonly IProCDAService procdaService = procdaService;
    private readonly IProcessosObsReportService processosobsreportService = processosobsreportService;
    private readonly IProcessosParadosService processosparadosService = processosparadosService;
    private readonly IProcessOutputRequestService processoutputrequestService = processoutputrequestService;
    private readonly IProDepositosService prodepositosService = prodepositosService;
    private readonly IProDespesasService prodespesasService = prodespesasService;
    private readonly IProObservacoesService proobservacoesService = proobservacoesService;
    private readonly IProPartesService propartesService = propartesService;
    private readonly IProProcuradoresService proprocuradoresService = proprocuradoresService;
    private readonly IProResumosService proresumosService = proresumosService;
    private readonly IProSucumbenciaService prosucumbenciaService = prosucumbenciaService;
    private readonly IProValoresService provaloresService = provaloresService;
    private readonly IRecadosService recadosService = recadosService;
    private readonly ITerceirosService terceirosService = terceirosService;
    private readonly IUltimosProcessosService ultimosprocessosService = ultimosprocessosService;
    public async Task<IEnumerable<ProcessosResponseAll>> GetAll(int max, [FromRoute, Required] string uri, CancellationToken token = default)
    {
        max = Math.Min(Math.Max(max, 1), BaseConsts.PMaxItens);
        ThrowIfDisposed();
        if (!Uris.ValidaUri(uri, _appSettings))
        {
            throw new Exception("Processos: URI inválida");
        }

        var entryOptions = new HybridCacheEntryOptions
        {
            Expiration = TimeSpan.FromMinutes(BaseConsts.PMaxMinutesCache),
            LocalCacheExpiration = TimeSpan.FromMinutes(BaseConsts.PMaxMinutesCache)
        };
        using var oCnn = Configuracoes.GetConnectionByUri(uri);
        var keyCache = await reader.ReadStringAuditor(uri, "", [], oCnn);
        var cacheKey = $"{uri}-Processos-Filter-{keyCache}";
        var result = await _cache.GetOrCreateAsync(cacheKey, async cancel => await GetDataAllAsync(max, string.Empty, [], uri, cancel), entryOptions, cancellationToken: token);
        return result;
    }

    public async Task<IEnumerable<ProcessosResponseAll>> Filter(Filters.FilterProcessos filtro, [FromRoute, Required] string uri)
    {
        ThrowIfDisposed();
        using var oCnn = Configuracoes.GetConnectionByUri(uri);
        if (oCnn == null)
        {
            throw new DatabaseConnectionException();
        }

        var filtroResult = filtro == null ? null : WFiltro(filtro!);
        string where = filtroResult?.where ?? string.Empty;
        List<SqlParameter> parameters = filtroResult?.parametros ?? [];
        var keyCache = await reader.ReadStringAuditor(uri, where, parameters, oCnn);
        var cacheKey = $"{uri}-Processos-Filter-{where.GetHashCode()}{parameters.GetHashCode()}{keyCache}";
        var entryOptions = new HybridCacheEntryOptions
        {
            Expiration = TimeSpan.FromSeconds(BaseConsts.PMaxGetListSecondsCacheId),
            LocalCacheExpiration = TimeSpan.FromSeconds(BaseConsts.PMaxGetListSecondsCacheId)
        };
        var result = await _cache.GetOrCreateAsync(cacheKey, async cancel => await GetDataAllAsync(BaseConsts.PMaxItens, string.IsNullOrEmpty(where) ? string.Empty : TSql.Where + where, parameters, uri, cancel), entryOptions, cancellationToken: new());
        return result;
    }

    public async Task<ProcessosResponse?> GetById([FromQuery] int id, [FromRoute, Required] string uri, CancellationToken token)
    {
        ThrowIfDisposed();
        if (id < 1)
        {
            return new ProcessosResponse();
        }

        var entryOptions = new HybridCacheEntryOptions
        {
            Expiration = TimeSpan.FromSeconds(BaseConsts.PMaxSecondsCacheId),
            LocalCacheExpiration = TimeSpan.FromSeconds(BaseConsts.PMaxSecondsCacheId)
        };
        using var oCnn = Configuracoes.GetConnectionByUri(uri);
        try
        {
            var keyCache = await reader.ReadStringAuditor(id, uri, oCnn);
            var result = await _cache.GetOrCreateAsync($"{uri}-Processos-GetById-{id}-{keyCache}", async cancel => await GetDataByIdAsync(id, oCnn, cancel), entryOptions, cancellationToken: token);
            return result;
        }
        catch (Exception)
        {
            throw new Exception($"Processos - {uri}-: GetById");
        }
    }

    private async Task<ProcessosResponse?> GetDataByIdAsync(int id, MsiSqlConnection oCnn, CancellationToken token) => await reader.Read(id, oCnn);
    public async Task<ProcessosResponse?> AddAndUpdate([FromBody] Models.Processos regProcessos, [FromRoute, Required] string uri)
    {
        ThrowIfDisposed();
        if (!Uris.ValidaUri(uri, _appSettings))
        {
            throw new Exception("Processos: URI inválida");
        }

        if (regProcessos == null)
        {
            return null;
        }

        using var oCnn = Configuracoes.GetConnectionByUriRw(uri);
        if (oCnn == null)
        {
            return null;
        }

        try
        {
            var validade = await validation.ValidateReg(regProcessos, this, advogadosReader, justicaReader, prepostosReader, clientesReader, oponentesReader, areaReader, cidadeReader, situacaoReader, ritoReader, atividadesReader, uri, oCnn);
            if (!validade)
            {
                throw new Exception("Erro inesperado ao vaidadar 0x0!");
            }
        }
        catch (SGValidationException ex)
        {
            throw new Exception(ex.Message);
        }
        catch (Exception)
        {
            throw new Exception("Erro inesperado ao vaidadar 0x1!");
        }

        int operadorId = UserTools.GetAuthenticatedUserId(_httpContextAccessor);
        using var saved = await writer.WriteAsync(regProcessos, operadorId, oCnn);
        return reader.Read(saved, oCnn);
    }

    public async Task<ProcessosResponse?> Validation([FromBody] Models.Processos regProcessos, [FromRoute, Required] string uri)
    {
        ThrowIfDisposed();
        if (!Uris.ValidaUri(uri, _appSettings))
        {
            throw new Exception("Processos: URI inválida");
        }

        if (regProcessos == null)
        {
            return null;
        }

        using var oCnn = Configuracoes.GetConnectionByUriRw(uri);
        if (oCnn == null)
        {
            return null;
        }

        try
        {
            var validade = await validation.ValidateReg(regProcessos, this, advogadosReader, justicaReader, prepostosReader, clientesReader, oponentesReader, areaReader, cidadeReader, situacaoReader, ritoReader, atividadesReader, uri, oCnn);
            if (!validade)
            {
                throw new Exception("Erro inesperado ao vaidadar 0x0!");
            }
        }
        catch (SGValidationException ex)
        {
            throw new Exception(ex.Message);
        }
        catch (Exception)
        {
            throw new Exception("Erro inesperado ao vaidadar 0x1!");
        }

        if (regProcessos.Id.IsEmptyIDNumber())
        {
            return new ProcessosResponse();
        }

        return await reader.Read(regProcessos.Id, oCnn);
    }

    public async Task<ProcessosResponse?> Delete([FromQuery] int id, [FromRoute, Required] string uri)
    {
        ThrowIfDisposed();
        if (!Uris.ValidaUri(uri, _appSettings))
        {
            throw new Exception("Processos: URI inválida");
        }

        if (id.IsEmptyIDNumber())
        {
            return null;
        }

        var nOperador = UserTools.GetAuthenticatedUserId(_httpContextAccessor);
        using var oCnn = Configuracoes.GetConnectionByUriRw(uri);
        if (oCnn == null)
        {
            return null;
        }

        try
        {
            var deleteValidation = await validation.CanDelete(id, this, agendaService, agendafinanceiroService, agendarepetirService, andamentosmdService, apensoService, apenso2Service, contacorrenteService, contatocrmService, contratosService, documentosService, enderecosistemaService, historicoService, honorariosdadoscontratoService, horastrabService, instanciaService, ligacoesService, livrocaixaService, nenotasService, parceriaprocService, parteclienteoutrasService, penhoraService, precatoriaService, procdaService, processosobsreportService, processosparadosService, processoutputrequestService, prodepositosService, prodespesasService, proobservacoesService, propartesService, proprocuradoresService, proresumosService, prosucumbenciaService, provaloresService, recadosService, terceirosService, ultimosprocessosService, uri, oCnn);
            if (!deleteValidation)
            {
                throw new Exception("Erro inesperado ao vaidadar 0x0!");
            }
        }
        catch (SGValidationException ex)
        {
            throw new Exception(ex.Message);
        }
        catch (Exception)
        {
            throw new Exception("Erro inesperado ao vaidadar 0x1!");
        }

        var processos = await reader.Read(id, oCnn);
        try
        {
            if (processos != null)
            {
                await writer.Delete(processos, nOperador, oCnn);
                if (_memoryCache is MemoryCache memCache)
                {
                    memCache.Compact(1.0);
                }
            }
        }
        catch (Exception ex)
        {
            throw new Exception(ex.Message);
        }

        return processos;
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (_disposed)
            return;
        if (disposing)
        {
        //_cache?.Dispose();
        }

        _disposed = true;
    }

    private void ThrowIfDisposed()
    {
        if (_disposed)
        {
            throw new ObjectDisposedException(GetType().Name);
        }
    }
}