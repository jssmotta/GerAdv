// 100% auto-generated by Source Genesys WebApi Front & Back Creator
// copyright © 2000-2025 Menphis - Sistemas Inteligentes
// This file is part of the Source Genesys project                     
namespace MenphisSI.GerAdv.WFiltro.Tests
{
    public class AdvogadosServiceWFiltroTests : IDisposable
    {
        private readonly Mock<IOptions<AppSettings>> _mockAppSettings;
        private readonly Mock<IFAdvogadosFactory> _mockAdvogadosFactory;
        private readonly Mock<IAdvogadosReader> _mockReader;
        private readonly Mock<IAdvogadosValidation> _mockValidation;
        private readonly Mock<IAdvogadosWriter> _mockWriter;
        private readonly Mock<IAgendaService> _mockAgendaService;
        private readonly Mock<IContratosService> _mockContratosService;
        private readonly Mock<IHorasTrabService> _mockHorasTrabService;
        private readonly Mock<IParceriaProcService> _mockParceriaProcService;
        private readonly Mock<IProProcuradoresService> _mockProProcuradoresService;
        private readonly Mock<ICargosReader> _mockCargosReader;
        private readonly Mock<IEscritoriosReader> _mockEscritoriosReader;
        private readonly Mock<ICidadeReader> _mockCidadeReader;
        private readonly Mock<IHttpContextAccessor> _mockHttpContextAccessor;
        private readonly Mock<HybridCache> _mockCache;
        private readonly Mock<IMemoryCache> _mockMemoryCache;
        private readonly AdvogadosService _service;
        public AdvogadosServiceWFiltroTests()
        {
            _mockAppSettings = new Mock<IOptions<AppSettings>>();
            _mockAdvogadosFactory = new Mock<IFAdvogadosFactory>();
            _mockReader = new Mock<IAdvogadosReader>();
            _mockValidation = new Mock<IAdvogadosValidation>();
            _mockWriter = new Mock<IAdvogadosWriter>();
            _mockAgendaService = new Mock<IAgendaService>();
            _mockContratosService = new Mock<IContratosService>();
            _mockHorasTrabService = new Mock<IHorasTrabService>();
            _mockParceriaProcService = new Mock<IParceriaProcService>();
            _mockProProcuradoresService = new Mock<IProProcuradoresService>();
            _mockCargosReader = new Mock<ICargosReader>();
            _mockEscritoriosReader = new Mock<IEscritoriosReader>();
            _mockCidadeReader = new Mock<ICidadeReader>();
            _mockHttpContextAccessor = new Mock<IHttpContextAccessor>();
            _mockCache = new Mock<HybridCache>();
            _mockMemoryCache = new Mock<IMemoryCache>();
            var appSettings = new AppSettings();
            _mockAppSettings.Setup(x => x.Value).Returns(appSettings);
            _service = new AdvogadosService(_mockAppSettings.Object, _mockAdvogadosFactory.Object, _mockReader.Object, _mockValidation.Object, _mockWriter.Object, _mockCargosReader.Object, _mockEscritoriosReader.Object, _mockCidadeReader.Object, _mockAgendaService.Object, _mockContratosService.Object, _mockHorasTrabService.Object, _mockParceriaProcService.Object, _mockProProcuradoresService.Object, _mockHttpContextAccessor.Object, _mockCache.Object, _mockMemoryCache.Object);
        }

        [Fact]
        public void WFiltro_QuandoFiltroEhNull_DeveRetornarResultadoVazio()
        {
            // Arrange
            FilterAdvogados? filtro = null;
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().BeNull();
        }

        [Fact]
        public void WFiltro_QuandoTodosCamposSaoValoresPadrao_DeveRetornarResultadoVazio()
        {
            // Arrange
            var filtro = new FilterAdvogados(); // Todos os valores padrão
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_ComTodosOsCamposPreenchidos_DeveProcessarRapidamente()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cargo = 1,
                EMailPro = "test@email.com",
                CPF = "544.506.718-13",
                Nome = "João",
                RG = "12.345.678-9",
                Casa = 2,
                NomeMae = "João",
                Escritorio = 1,
                Estagiario = 1,
                OAB = "AAAAAAAAAA",
                NomeCompleto = "João",
                Endereco = "Rua das Flores, 123",
                Cidade = 1,
                CEP = "01234-567",
                Sexo = 2,
                Bairro = "Centro",
                CTPSSerie = "AAAAAAAA",
                CTPS = "AAAAAAAAAAAAA",
                Fone = "(11) 99999-9999",
                Fax = "(11) 88888-9999",
                Comissao = 1,
                DtInicio = "24/04/1975",
                DtFim = "24/04/1975",
                DtNasc = "24/04/1975",
                Salario = 1m,
                Secretaria = "AAAAAAAAAAAAAAAAAA",
                TextoProcuracao = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
                EMail = "test@email.com",
                Especializacao = "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM",
                Pasta = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
                Observacao = "Observação teste",
                ContaBancaria = "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM",
                ParcTop = 1,
                Class = "A",
                Top = 2,
                GUID = Guid.NewGuid().ToString(),
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var stopwatch = System.Diagnostics.Stopwatch.StartNew();
            var resultado = _service.WFiltro(filtro);
            stopwatch.Stop();
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().NotBeEmpty();
            resultado.Value.where.Should().NotBeEmpty();
            stopwatch.ElapsedMilliseconds.Should().BeLessThan(100); // Deve processar em menos de 100ms
        }

#region String Tests
        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_EMailPro_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string emailproComWhitespace)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                EMailPro = emailproComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_EMailPro_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var emailproGigante = new string ('A', 1000);
            var filtro = new FilterAdvogados
            {
                EMailPro = emailproGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{emailproGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_EMailPro_ComCaracteresEspeciais_DeveProcessarCorretamente(string emailproComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                EMailPro = emailproComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(emailproComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_EMailProAdvogados_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                EMailPro = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_EMailProAdvogados_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                EMailPro = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_EMailProAdvogados_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                EMailPro = nomeAdvogados,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_EMailProAdvogados_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                EMailPro = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_EMailProAdvogados_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                EMailPro = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_EMailProAdvogados_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeAdvogados)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                EMailPro = nomeAdvogados,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_EMailProAdvogados_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                EMailPro = "João",
                Escritorio = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@advEMailPro");
            resultado.Value.where.Should().Contain("@advEscritorio");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @advEMailPro");
            resultado.Value.where.Should().Contain("= @advEscritorio");
        }

        [Fact]
        public void WFiltro_EMailProAdvogados_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                EMailPro = nomeAdvogados,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.EMailPro}]");
            resultado.Value.where.Should().Contain("like @advEMailPro");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@advEMailPro");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Fact]
        public void WFiltro_CPFAdvogados_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                CPF = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_CPFAdvogados_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                CPF = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_CPFAdvogados_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                CPF = nomeAdvogados,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_CPFAdvogados_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                CPF = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_CPFAdvogados_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                CPF = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_CPFAdvogados_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeAdvogados)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                CPF = nomeAdvogados,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_CPFAdvogados_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                CPF = "João",
                Escritorio = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@advCPF");
            resultado.Value.where.Should().Contain("@advEscritorio");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @advCPF");
            resultado.Value.where.Should().Contain("= @advEscritorio");
        }

        [Fact]
        public void WFiltro_CPFAdvogados_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                CPF = nomeAdvogados,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.CPF}]");
            resultado.Value.where.Should().Contain("like @advCPF");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@advCPF");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Fact]
        public void WFiltro_Nome_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Escritorio = 1,
                Nome = "João",
                LogicalOperator = null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltroNome_LogicalOperatorVazioOuNulo_DeveUsarAndPorPadrao(string logicalOperator)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Nome = "João",
                Escritorio = 2,
                LogicalOperator = logicalOperator
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_Nome_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string nomeComWhitespace)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Nome = nomeComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_Nome_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var nomeGigante = new string ('A', 1000);
            var filtro = new FilterAdvogados
            {
                Nome = nomeGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{nomeGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_Nome_ComCaracteresEspeciais_DeveProcessarCorretamente(string nomeComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Nome = nomeComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(nomeComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_NomeAdvogados_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Nome = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_NomeAdvogados_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Nome = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_NomeAdvogados_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                Nome = nomeAdvogados,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_NomeAdvogados_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Nome = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_NomeAdvogados_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Nome = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_NomeAdvogados_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeAdvogados)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Nome = nomeAdvogados,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_NomeAdvogados_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Nome = "João",
                Escritorio = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@advNome");
            resultado.Value.where.Should().Contain("@advEscritorio");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @advNome");
            resultado.Value.where.Should().Contain("= @advEscritorio");
        }

        [Fact]
        public void WFiltro_NomeAdvogados_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                Nome = nomeAdvogados,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Nome}]");
            resultado.Value.where.Should().Contain("like @advNome");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@advNome");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_RG_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string rgComWhitespace)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                RG = rgComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_RG_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var rgGigante = new string ('A', 1000);
            var filtro = new FilterAdvogados
            {
                RG = rgGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{rgGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_RG_ComCaracteresEspeciais_DeveProcessarCorretamente(string rgComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                RG = rgComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(rgComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_RGAdvogados_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                RG = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_RGAdvogados_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                RG = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_RGAdvogados_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                RG = nomeAdvogados,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_RGAdvogados_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                RG = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_RGAdvogados_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                RG = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_RGAdvogados_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeAdvogados)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                RG = nomeAdvogados,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_RGAdvogados_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                RG = "João",
                Escritorio = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@advRG");
            resultado.Value.where.Should().Contain("@advEscritorio");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @advRG");
            resultado.Value.where.Should().Contain("= @advEscritorio");
        }

        [Fact]
        public void WFiltro_RGAdvogados_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                RG = nomeAdvogados,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.RG}]");
            resultado.Value.where.Should().Contain("like @advRG");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@advRG");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_NomeMae_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string nomemaeComWhitespace)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                NomeMae = nomemaeComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_NomeMae_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var nomemaeGigante = new string ('A', 1000);
            var filtro = new FilterAdvogados
            {
                NomeMae = nomemaeGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{nomemaeGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_NomeMae_ComCaracteresEspeciais_DeveProcessarCorretamente(string nomemaeComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                NomeMae = nomemaeComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(nomemaeComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_NomeMaeAdvogados_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                NomeMae = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_NomeMaeAdvogados_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                NomeMae = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_NomeMaeAdvogados_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                NomeMae = nomeAdvogados,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_NomeMaeAdvogados_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                NomeMae = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_NomeMaeAdvogados_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                NomeMae = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_NomeMaeAdvogados_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeAdvogados)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                NomeMae = nomeAdvogados,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_NomeMaeAdvogados_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                NomeMae = "João",
                Escritorio = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@advNomeMae");
            resultado.Value.where.Should().Contain("@advEscritorio");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @advNomeMae");
            resultado.Value.where.Should().Contain("= @advEscritorio");
        }

        [Fact]
        public void WFiltro_NomeMaeAdvogados_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                NomeMae = nomeAdvogados,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.NomeMae}]");
            resultado.Value.where.Should().Contain("like @advNomeMae");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@advNomeMae");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Fact]
        public void WFiltro_OABAdvogados_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                OAB = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_OABAdvogados_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                OAB = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_OABAdvogados_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                OAB = nomeAdvogados,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_OABAdvogados_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                OAB = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_OABAdvogados_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                OAB = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_OABAdvogados_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeAdvogados)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                OAB = nomeAdvogados,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_OABAdvogados_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                OAB = "João",
                Escritorio = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@advOAB");
            resultado.Value.where.Should().Contain("@advEscritorio");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @advOAB");
            resultado.Value.where.Should().Contain("= @advEscritorio");
        }

        [Fact]
        public void WFiltro_OABAdvogados_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                OAB = nomeAdvogados,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.OAB}]");
            resultado.Value.where.Should().Contain("like @advOAB");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@advOAB");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_NomeCompleto_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string nomecompletoComWhitespace)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                NomeCompleto = nomecompletoComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_NomeCompleto_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var nomecompletoGigante = new string ('A', 1000);
            var filtro = new FilterAdvogados
            {
                NomeCompleto = nomecompletoGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{nomecompletoGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_NomeCompleto_ComCaracteresEspeciais_DeveProcessarCorretamente(string nomecompletoComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                NomeCompleto = nomecompletoComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(nomecompletoComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_NomeCompletoAdvogados_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                NomeCompleto = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_NomeCompletoAdvogados_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                NomeCompleto = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_NomeCompletoAdvogados_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                NomeCompleto = nomeAdvogados,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_NomeCompletoAdvogados_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                NomeCompleto = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_NomeCompletoAdvogados_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                NomeCompleto = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_NomeCompletoAdvogados_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeAdvogados)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                NomeCompleto = nomeAdvogados,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_NomeCompletoAdvogados_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                NomeCompleto = "João",
                Escritorio = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@advNomeCompleto");
            resultado.Value.where.Should().Contain("@advEscritorio");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @advNomeCompleto");
            resultado.Value.where.Should().Contain("= @advEscritorio");
        }

        [Fact]
        public void WFiltro_NomeCompletoAdvogados_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                NomeCompleto = nomeAdvogados,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.NomeCompleto}]");
            resultado.Value.where.Should().Contain("like @advNomeCompleto");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@advNomeCompleto");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_Endereco_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string enderecoComWhitespace)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Endereco = enderecoComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_Endereco_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var enderecoGigante = new string ('A', 1000);
            var filtro = new FilterAdvogados
            {
                Endereco = enderecoGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{enderecoGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_Endereco_ComCaracteresEspeciais_DeveProcessarCorretamente(string enderecoComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Endereco = enderecoComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(enderecoComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_EnderecoAdvogados_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Endereco = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_EnderecoAdvogados_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Endereco = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_EnderecoAdvogados_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                Endereco = nomeAdvogados,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_EnderecoAdvogados_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Endereco = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_EnderecoAdvogados_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Endereco = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_EnderecoAdvogados_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeAdvogados)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Endereco = nomeAdvogados,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_EnderecoAdvogados_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Endereco = "João",
                Escritorio = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@advEndereco");
            resultado.Value.where.Should().Contain("@advEscritorio");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @advEndereco");
            resultado.Value.where.Should().Contain("= @advEscritorio");
        }

        [Fact]
        public void WFiltro_EnderecoAdvogados_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                Endereco = nomeAdvogados,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Endereco}]");
            resultado.Value.where.Should().Contain("like @advEndereco");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@advEndereco");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Fact]
        public void WFiltro_CEPAdvogados_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                CEP = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_CEPAdvogados_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                CEP = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_CEPAdvogados_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                CEP = nomeAdvogados,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_CEPAdvogados_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                CEP = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_CEPAdvogados_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                CEP = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_CEPAdvogados_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeAdvogados)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                CEP = nomeAdvogados,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_CEPAdvogados_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                CEP = "João",
                Escritorio = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@advCEP");
            resultado.Value.where.Should().Contain("@advEscritorio");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @advCEP");
            resultado.Value.where.Should().Contain("= @advEscritorio");
        }

        [Fact]
        public void WFiltro_CEPAdvogados_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                CEP = nomeAdvogados,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.CEP}]");
            resultado.Value.where.Should().Contain("like @advCEP");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@advCEP");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_Bairro_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string bairroComWhitespace)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Bairro = bairroComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_Bairro_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var bairroGigante = new string ('A', 1000);
            var filtro = new FilterAdvogados
            {
                Bairro = bairroGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{bairroGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_Bairro_ComCaracteresEspeciais_DeveProcessarCorretamente(string bairroComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Bairro = bairroComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(bairroComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_BairroAdvogados_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Bairro = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_BairroAdvogados_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Bairro = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_BairroAdvogados_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                Bairro = nomeAdvogados,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_BairroAdvogados_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Bairro = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_BairroAdvogados_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Bairro = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_BairroAdvogados_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeAdvogados)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Bairro = nomeAdvogados,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_BairroAdvogados_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Bairro = "João",
                Escritorio = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@advBairro");
            resultado.Value.where.Should().Contain("@advEscritorio");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @advBairro");
            resultado.Value.where.Should().Contain("= @advEscritorio");
        }

        [Fact]
        public void WFiltro_BairroAdvogados_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                Bairro = nomeAdvogados,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Bairro}]");
            resultado.Value.where.Should().Contain("like @advBairro");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@advBairro");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Fact]
        public void WFiltro_CTPSSerieAdvogados_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                CTPSSerie = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_CTPSSerieAdvogados_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                CTPSSerie = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_CTPSSerieAdvogados_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                CTPSSerie = nomeAdvogados,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_CTPSSerieAdvogados_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                CTPSSerie = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_CTPSSerieAdvogados_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                CTPSSerie = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_CTPSSerieAdvogados_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeAdvogados)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                CTPSSerie = nomeAdvogados,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_CTPSSerieAdvogados_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                CTPSSerie = "João",
                Escritorio = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@advCTPSSerie");
            resultado.Value.where.Should().Contain("@advEscritorio");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @advCTPSSerie");
            resultado.Value.where.Should().Contain("= @advEscritorio");
        }

        [Fact]
        public void WFiltro_CTPSSerieAdvogados_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                CTPSSerie = nomeAdvogados,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.CTPSSerie}]");
            resultado.Value.where.Should().Contain("like @advCTPSSerie");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@advCTPSSerie");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Fact]
        public void WFiltro_CTPSAdvogados_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                CTPS = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_CTPSAdvogados_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                CTPS = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_CTPSAdvogados_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                CTPS = nomeAdvogados,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_CTPSAdvogados_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                CTPS = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_CTPSAdvogados_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                CTPS = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_CTPSAdvogados_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeAdvogados)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                CTPS = nomeAdvogados,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_CTPSAdvogados_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                CTPS = "João",
                Escritorio = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@advCTPS");
            resultado.Value.where.Should().Contain("@advEscritorio");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @advCTPS");
            resultado.Value.where.Should().Contain("= @advEscritorio");
        }

        [Fact]
        public void WFiltro_CTPSAdvogados_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                CTPS = nomeAdvogados,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.CTPS}]");
            resultado.Value.where.Should().Contain("like @advCTPS");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@advCTPS");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_Fone_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string foneComWhitespace)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Fone = foneComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_Fone_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var foneGigante = new string ('A', 1000);
            var filtro = new FilterAdvogados
            {
                Fone = foneGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{foneGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_Fone_ComCaracteresEspeciais_DeveProcessarCorretamente(string foneComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Fone = foneComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(foneComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_FoneAdvogados_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Fone = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_FoneAdvogados_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Fone = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_FoneAdvogados_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                Fone = nomeAdvogados,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_FoneAdvogados_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Fone = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_FoneAdvogados_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Fone = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_FoneAdvogados_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeAdvogados)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Fone = nomeAdvogados,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_FoneAdvogados_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Fone = "João",
                Escritorio = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@advFone");
            resultado.Value.where.Should().Contain("@advEscritorio");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @advFone");
            resultado.Value.where.Should().Contain("= @advEscritorio");
        }

        [Fact]
        public void WFiltro_FoneAdvogados_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                Fone = nomeAdvogados,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Fone}]");
            resultado.Value.where.Should().Contain("like @advFone");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@advFone");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_Fax_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string faxComWhitespace)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Fax = faxComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_Fax_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var faxGigante = new string ('A', 1000);
            var filtro = new FilterAdvogados
            {
                Fax = faxGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{faxGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_Fax_ComCaracteresEspeciais_DeveProcessarCorretamente(string faxComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Fax = faxComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(faxComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_FaxAdvogados_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Fax = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_FaxAdvogados_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Fax = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_FaxAdvogados_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                Fax = nomeAdvogados,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_FaxAdvogados_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Fax = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_FaxAdvogados_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Fax = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_FaxAdvogados_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeAdvogados)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Fax = nomeAdvogados,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_FaxAdvogados_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Fax = "João",
                Escritorio = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@advFax");
            resultado.Value.where.Should().Contain("@advEscritorio");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @advFax");
            resultado.Value.where.Should().Contain("= @advEscritorio");
        }

        [Fact]
        public void WFiltro_FaxAdvogados_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                Fax = nomeAdvogados,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Fax}]");
            resultado.Value.where.Should().Contain("like @advFax");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@advFax");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_Secretaria_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string secretariaComWhitespace)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Secretaria = secretariaComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_Secretaria_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var secretariaGigante = new string ('A', 1000);
            var filtro = new FilterAdvogados
            {
                Secretaria = secretariaGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{secretariaGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_Secretaria_ComCaracteresEspeciais_DeveProcessarCorretamente(string secretariaComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Secretaria = secretariaComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(secretariaComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_SecretariaAdvogados_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Secretaria = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_SecretariaAdvogados_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Secretaria = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_SecretariaAdvogados_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                Secretaria = nomeAdvogados,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_SecretariaAdvogados_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Secretaria = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_SecretariaAdvogados_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Secretaria = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_SecretariaAdvogados_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeAdvogados)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Secretaria = nomeAdvogados,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_SecretariaAdvogados_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Secretaria = "João",
                Escritorio = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@advSecretaria");
            resultado.Value.where.Should().Contain("@advEscritorio");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @advSecretaria");
            resultado.Value.where.Should().Contain("= @advEscritorio");
        }

        [Fact]
        public void WFiltro_SecretariaAdvogados_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                Secretaria = nomeAdvogados,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Secretaria}]");
            resultado.Value.where.Should().Contain("like @advSecretaria");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@advSecretaria");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_TextoProcuracao_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string textoprocuracaoComWhitespace)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                TextoProcuracao = textoprocuracaoComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_TextoProcuracao_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var textoprocuracaoGigante = new string ('A', 1000);
            var filtro = new FilterAdvogados
            {
                TextoProcuracao = textoprocuracaoGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{textoprocuracaoGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_TextoProcuracao_ComCaracteresEspeciais_DeveProcessarCorretamente(string textoprocuracaoComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                TextoProcuracao = textoprocuracaoComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(textoprocuracaoComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_TextoProcuracaoAdvogados_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                TextoProcuracao = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_TextoProcuracaoAdvogados_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                TextoProcuracao = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_TextoProcuracaoAdvogados_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                TextoProcuracao = nomeAdvogados,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_TextoProcuracaoAdvogados_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                TextoProcuracao = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_TextoProcuracaoAdvogados_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                TextoProcuracao = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_TextoProcuracaoAdvogados_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeAdvogados)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                TextoProcuracao = nomeAdvogados,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_TextoProcuracaoAdvogados_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                TextoProcuracao = "João",
                Escritorio = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@advTextoProcuracao");
            resultado.Value.where.Should().Contain("@advEscritorio");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @advTextoProcuracao");
            resultado.Value.where.Should().Contain("= @advEscritorio");
        }

        [Fact]
        public void WFiltro_TextoProcuracaoAdvogados_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                TextoProcuracao = nomeAdvogados,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.TextoProcuracao}]");
            resultado.Value.where.Should().Contain("like @advTextoProcuracao");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@advTextoProcuracao");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_EMail_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string emailComWhitespace)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                EMail = emailComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_EMail_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var emailGigante = new string ('A', 1000);
            var filtro = new FilterAdvogados
            {
                EMail = emailGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{emailGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_EMail_ComCaracteresEspeciais_DeveProcessarCorretamente(string emailComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                EMail = emailComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(emailComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_EMailAdvogados_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                EMail = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_EMailAdvogados_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                EMail = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_EMailAdvogados_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                EMail = nomeAdvogados,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_EMailAdvogados_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                EMail = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_EMailAdvogados_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                EMail = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_EMailAdvogados_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeAdvogados)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                EMail = nomeAdvogados,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_EMailAdvogados_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                EMail = "João",
                Escritorio = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@advEMail");
            resultado.Value.where.Should().Contain("@advEscritorio");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @advEMail");
            resultado.Value.where.Should().Contain("= @advEscritorio");
        }

        [Fact]
        public void WFiltro_EMailAdvogados_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                EMail = nomeAdvogados,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.EMail}]");
            resultado.Value.where.Should().Contain("like @advEMail");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@advEMail");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_Especializacao_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string especializacaoComWhitespace)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Especializacao = especializacaoComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_Especializacao_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var especializacaoGigante = new string ('A', 1000);
            var filtro = new FilterAdvogados
            {
                Especializacao = especializacaoGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{especializacaoGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_Especializacao_ComCaracteresEspeciais_DeveProcessarCorretamente(string especializacaoComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Especializacao = especializacaoComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(especializacaoComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_EspecializacaoAdvogados_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Especializacao = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_EspecializacaoAdvogados_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Especializacao = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_EspecializacaoAdvogados_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                Especializacao = nomeAdvogados,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_EspecializacaoAdvogados_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Especializacao = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_EspecializacaoAdvogados_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Especializacao = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_EspecializacaoAdvogados_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeAdvogados)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Especializacao = nomeAdvogados,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_EspecializacaoAdvogados_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Especializacao = "João",
                Escritorio = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@advEspecializacao");
            resultado.Value.where.Should().Contain("@advEscritorio");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @advEspecializacao");
            resultado.Value.where.Should().Contain("= @advEscritorio");
        }

        [Fact]
        public void WFiltro_EspecializacaoAdvogados_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                Especializacao = nomeAdvogados,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Especializacao}]");
            resultado.Value.where.Should().Contain("like @advEspecializacao");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@advEspecializacao");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_Pasta_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string pastaComWhitespace)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Pasta = pastaComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_Pasta_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var pastaGigante = new string ('A', 1000);
            var filtro = new FilterAdvogados
            {
                Pasta = pastaGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{pastaGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_Pasta_ComCaracteresEspeciais_DeveProcessarCorretamente(string pastaComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Pasta = pastaComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(pastaComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_PastaAdvogados_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Pasta = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_PastaAdvogados_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Pasta = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_PastaAdvogados_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                Pasta = nomeAdvogados,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_PastaAdvogados_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Pasta = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_PastaAdvogados_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Pasta = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_PastaAdvogados_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeAdvogados)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Pasta = nomeAdvogados,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_PastaAdvogados_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Pasta = "João",
                Escritorio = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@advPasta");
            resultado.Value.where.Should().Contain("@advEscritorio");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @advPasta");
            resultado.Value.where.Should().Contain("= @advEscritorio");
        }

        [Fact]
        public void WFiltro_PastaAdvogados_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                Pasta = nomeAdvogados,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Pasta}]");
            resultado.Value.where.Should().Contain("like @advPasta");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@advPasta");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_Observacao_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string observacaoComWhitespace)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Observacao = observacaoComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_Observacao_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var observacaoGigante = new string ('A', 1000);
            var filtro = new FilterAdvogados
            {
                Observacao = observacaoGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{observacaoGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_Observacao_ComCaracteresEspeciais_DeveProcessarCorretamente(string observacaoComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Observacao = observacaoComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(observacaoComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_ObservacaoAdvogados_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Observacao = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_ObservacaoAdvogados_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Observacao = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_ObservacaoAdvogados_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                Observacao = nomeAdvogados,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_ObservacaoAdvogados_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Observacao = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_ObservacaoAdvogados_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Observacao = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_ObservacaoAdvogados_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeAdvogados)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Observacao = nomeAdvogados,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_ObservacaoAdvogados_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Observacao = "João",
                Escritorio = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@advObservacao");
            resultado.Value.where.Should().Contain("@advEscritorio");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @advObservacao");
            resultado.Value.where.Should().Contain("= @advEscritorio");
        }

        [Fact]
        public void WFiltro_ObservacaoAdvogados_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                Observacao = nomeAdvogados,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Observacao}]");
            resultado.Value.where.Should().Contain("like @advObservacao");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@advObservacao");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_ContaBancaria_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string contabancariaComWhitespace)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                ContaBancaria = contabancariaComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_ContaBancaria_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var contabancariaGigante = new string ('A', 1000);
            var filtro = new FilterAdvogados
            {
                ContaBancaria = contabancariaGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{contabancariaGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_ContaBancaria_ComCaracteresEspeciais_DeveProcessarCorretamente(string contabancariaComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                ContaBancaria = contabancariaComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(contabancariaComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_ContaBancariaAdvogados_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                ContaBancaria = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_ContaBancariaAdvogados_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                ContaBancaria = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_ContaBancariaAdvogados_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                ContaBancaria = nomeAdvogados,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_ContaBancariaAdvogados_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                ContaBancaria = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_ContaBancariaAdvogados_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                ContaBancaria = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_ContaBancariaAdvogados_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeAdvogados)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                ContaBancaria = nomeAdvogados,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_ContaBancariaAdvogados_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                ContaBancaria = "João",
                Escritorio = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@advContaBancaria");
            resultado.Value.where.Should().Contain("@advEscritorio");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @advContaBancaria");
            resultado.Value.where.Should().Contain("= @advEscritorio");
        }

        [Fact]
        public void WFiltro_ContaBancariaAdvogados_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                ContaBancaria = nomeAdvogados,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.ContaBancaria}]");
            resultado.Value.where.Should().Contain("like @advContaBancaria");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@advContaBancaria");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Fact]
        public void WFiltro_ClassAdvogados_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Class = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_ClassAdvogados_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Class = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_ClassAdvogados_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                Class = nomeAdvogados,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_ClassAdvogados_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Class = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_ClassAdvogados_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Class = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_ClassAdvogados_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeAdvogados)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Class = nomeAdvogados,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_ClassAdvogados_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Class = "João",
                Escritorio = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@advClass");
            resultado.Value.where.Should().Contain("@advEscritorio");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @advClass");
            resultado.Value.where.Should().Contain("= @advEscritorio");
        }

        [Fact]
        public void WFiltro_ClassAdvogados_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                Class = nomeAdvogados,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Class}]");
            resultado.Value.where.Should().Contain("like @advClass");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@advClass");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_GUID_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string guidComWhitespace)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                GUID = guidComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_GUID_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var guidGigante = new string ('A', 1000);
            var filtro = new FilterAdvogados
            {
                GUID = guidGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{guidGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_GUID_ComCaracteresEspeciais_DeveProcessarCorretamente(string guidComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                GUID = guidComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(guidComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_GUIDAdvogados_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                GUID = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_GUIDAdvogados_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                GUID = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_GUIDAdvogados_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                GUID = nomeAdvogados,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_GUIDAdvogados_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                GUID = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_GUIDAdvogados_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                GUID = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_GUIDAdvogados_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeAdvogados)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                GUID = nomeAdvogados,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_GUIDAdvogados_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                GUID = "João",
                Escritorio = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@advGUID");
            resultado.Value.where.Should().Contain("@advEscritorio");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @advGUID");
            resultado.Value.where.Should().Contain("= @advEscritorio");
        }

        [Fact]
        public void WFiltro_GUIDAdvogados_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeAdvogados = "João Silva";
            var filtro = new FilterAdvogados
            {
                GUID = nomeAdvogados,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.GUID}]");
            resultado.Value.where.Should().Contain("like @advGUID");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@advGUID");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

#endregion
#region Integer Tests
#region filtro.Cargo_end Tests
        [Fact]
        public void WFiltro_Cargo_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cargo_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Cargo_end_QuandoTemValorPositivo_SemCargoInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorCargoEnd = 5000;
            var filtro = new FilterAdvogados
            {
                Cargo = int.MinValue, // Não define salário inicial
                Cargo_end = valorCargoEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Cargo inicial válido, não deve incluir condição WHERE, mas o parâmetro Cargo_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Cargo_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Cargo_end_QuandoSomenteValorInicial_SemCargoEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorCargo = 2500;
            var filtro = new FilterAdvogados
            {
                Cargo = valorCargo,
                Cargo_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Cargo}] = @{DBAdvogadosDicInfo.Cargo}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBAdvogadosDicInfo.Cargo}");
            parametro.Value.Should().Be(valorCargo);
        }

        [Fact]
        public void WFiltro_Cargo_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorCargoInicial = 1000;
            var valorCargoFinal = 5000;
            var filtro = new FilterAdvogados
            {
                Cargo = valorCargoInicial,
                Cargo_end = valorCargoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].{DBAdvogadosDicInfo.Cargo} BETWEEN @{DBAdvogadosDicInfo.Cargo} AND @{DBAdvogadosDicInfo.Cargo}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Cargo}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Cargo}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorCargoInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorCargoFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Cargo_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cargo = valorInicial,
                Cargo_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Cargo}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Cargo}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Cargo_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cargo = 1000,
                Cargo_end = 5000,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBAdvogadosDicInfo.Cargo}");
            resultado.Value.where.Should().Contain($"@{DBAdvogadosDicInfo.EMailPro}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Cargo_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cargo = 1000,
                Cargo_end = 5000,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Cargo_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cargo = 1000,
                Cargo_end = 5000,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Cargo_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cargo = 1000,
                Cargo_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].{DBAdvogadosDicInfo.Cargo} BETWEEN");
        }

        [Fact]
        public void WFiltro_Cargo_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cargo = 1000,
                Cargo_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Cargo_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cargo = 1000,
                Cargo_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Cargo_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorCargoInicial = 2500;
            var valorCargoFinal = 4750;
            var filtro = new FilterAdvogados
            {
                Cargo = valorCargoInicial,
                Cargo_end = valorCargoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Cargo}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Cargo}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorCargoInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorCargoFinal);
        }

        [Fact]
        public void WFiltro_Cargo_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cargo = 0,
                Cargo_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Cargo_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cargo = 0,
                Cargo_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Cargo_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cargo = 1500,
                Cargo_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Cargo == int.MinValue) && !(filtro.Cargo_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBAdvogadosDicInfo.PTabelaNome}].{DBAdvogadosDicInfo.Cargo} BETWEEN @{DBAdvogadosDicInfo.Cargo} AND @{DBAdvogadosDicInfo.Cargo}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Cargo_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cargo = 2000,
                Cargo_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Cargo == int.MinValue) && filtro.Cargo_end == int.MinValue
            // Deve resultar em igualdade quando apenas Cargo tem valor válido
            resultado.Value.where.Should().Be($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Cargo}] = @{DBAdvogadosDicInfo.Cargo}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Cargo_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cargo = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Cargo Isolated Tests
        [Fact]
        public void WFiltro_Cargo_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cargo = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Cargo_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorCargo = 5;
            var filtro = new FilterAdvogados
            {
                Cargo = valorCargo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Cargo}] = @{DBAdvogadosDicInfo.Cargo}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBAdvogadosDicInfo.Cargo}");
            parametro.Value.Should().Be(valorCargo);
        }

        [Fact]
        public void WFiltro_Cargo_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorCargo = 0;
            var filtro = new FilterAdvogados
            {
                Cargo = valorCargo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBAdvogadosDicInfo.Cargo}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCargo);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Cargo_DiferentesValoresValidos_DeveProcessarCorretamente(int valorCargo)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cargo = valorCargo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCargo);
            resultado.Value.where.Should().Contain($"= @{DBAdvogadosDicInfo.Cargo}");
        }

        [Fact]
        public void WFiltro_Cargo_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cargo = 1,
                EMailPro = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBAdvogadosDicInfo.Cargo}");
            resultado.Value.where.Should().Contain($"@{DBAdvogadosDicInfo.EMailPro}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Cargo_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cargo = 1,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Cargo_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cargo = 1,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Cargo_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cargo = 1,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Cargo_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cargo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Cargo}]");
        }

        [Fact]
        public void WFiltro_Cargo_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cargo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Cargo_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cargo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Cargo_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cargo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Cargo_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorCargo = 42;
            var filtro = new FilterAdvogados
            {
                Cargo = valorCargo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorCargo);
        }

#endregion
        [Fact]
        public void WFiltro_Cargo_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cargo = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Cargo_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorCargo = 1;
            var filtro = new FilterAdvogados
            {
                Cargo = valorCargo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Cargo
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Cargo}] = @advCargo");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@advCargo");
            parametro.Value.Should().Be(valorCargo);
        }

        [Fact]
        public void WFiltro_Cargo_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cargo = 1,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@advCargo");
            resultado.Value.where.Should().Contain($"@{DBAdvogadosDicInfo.EMailPro}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Cargo_DiferentesValores_DeveFuncionar(int valorCargo)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cargo = valorCargo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCargo);
        }

#region filtro.Escritorio_end Tests
        [Fact]
        public void WFiltro_Escritorio_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Escritorio_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Escritorio_end_QuandoTemValorPositivo_SemEscritorioInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorEscritorioEnd = 5000;
            var filtro = new FilterAdvogados
            {
                Escritorio = int.MinValue, // Não define salário inicial
                Escritorio_end = valorEscritorioEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Escritorio inicial válido, não deve incluir condição WHERE, mas o parâmetro Escritorio_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Escritorio_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Escritorio_end_QuandoSomenteValorInicial_SemEscritorioEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorEscritorio = 2500;
            var filtro = new FilterAdvogados
            {
                Escritorio = valorEscritorio,
                Escritorio_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Escritorio}] = @{DBAdvogadosDicInfo.Escritorio}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBAdvogadosDicInfo.Escritorio}");
            parametro.Value.Should().Be(valorEscritorio);
        }

        [Fact]
        public void WFiltro_Escritorio_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorEscritorioInicial = 1000;
            var valorEscritorioFinal = 5000;
            var filtro = new FilterAdvogados
            {
                Escritorio = valorEscritorioInicial,
                Escritorio_end = valorEscritorioFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].{DBAdvogadosDicInfo.Escritorio} BETWEEN @{DBAdvogadosDicInfo.Escritorio} AND @{DBAdvogadosDicInfo.Escritorio}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Escritorio}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Escritorio}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorEscritorioInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorEscritorioFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Escritorio_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Escritorio = valorInicial,
                Escritorio_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Escritorio}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Escritorio}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Escritorio_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Escritorio = 1000,
                Escritorio_end = 5000,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBAdvogadosDicInfo.Escritorio}");
            resultado.Value.where.Should().Contain($"@{DBAdvogadosDicInfo.EMailPro}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Escritorio_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Escritorio = 1000,
                Escritorio_end = 5000,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Escritorio_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Escritorio = 1000,
                Escritorio_end = 5000,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Escritorio_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Escritorio = 1000,
                Escritorio_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].{DBAdvogadosDicInfo.Escritorio} BETWEEN");
        }

        [Fact]
        public void WFiltro_Escritorio_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Escritorio = 1000,
                Escritorio_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Escritorio_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Escritorio = 1000,
                Escritorio_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Escritorio_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorEscritorioInicial = 2500;
            var valorEscritorioFinal = 4750;
            var filtro = new FilterAdvogados
            {
                Escritorio = valorEscritorioInicial,
                Escritorio_end = valorEscritorioFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Escritorio}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Escritorio}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorEscritorioInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorEscritorioFinal);
        }

        [Fact]
        public void WFiltro_Escritorio_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Escritorio = 0,
                Escritorio_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Escritorio_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Escritorio = 0,
                Escritorio_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Escritorio_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Escritorio = 1500,
                Escritorio_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Escritorio == int.MinValue) && !(filtro.Escritorio_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBAdvogadosDicInfo.PTabelaNome}].{DBAdvogadosDicInfo.Escritorio} BETWEEN @{DBAdvogadosDicInfo.Escritorio} AND @{DBAdvogadosDicInfo.Escritorio}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Escritorio_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Escritorio = 2000,
                Escritorio_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Escritorio == int.MinValue) && filtro.Escritorio_end == int.MinValue
            // Deve resultar em igualdade quando apenas Escritorio tem valor válido
            resultado.Value.where.Should().Be($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Escritorio}] = @{DBAdvogadosDicInfo.Escritorio}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Escritorio_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Escritorio = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Escritorio Isolated Tests
        [Fact]
        public void WFiltro_Escritorio_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Escritorio = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Escritorio_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorEscritorio = 5;
            var filtro = new FilterAdvogados
            {
                Escritorio = valorEscritorio,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Escritorio}] = @{DBAdvogadosDicInfo.Escritorio}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBAdvogadosDicInfo.Escritorio}");
            parametro.Value.Should().Be(valorEscritorio);
        }

        [Fact]
        public void WFiltro_Escritorio_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorEscritorio = 0;
            var filtro = new FilterAdvogados
            {
                Escritorio = valorEscritorio,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBAdvogadosDicInfo.Escritorio}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorEscritorio);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Escritorio_DiferentesValoresValidos_DeveProcessarCorretamente(int valorEscritorio)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Escritorio = valorEscritorio,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorEscritorio);
            resultado.Value.where.Should().Contain($"= @{DBAdvogadosDicInfo.Escritorio}");
        }

        [Fact]
        public void WFiltro_Escritorio_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Escritorio = 1,
                EMailPro = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBAdvogadosDicInfo.Escritorio}");
            resultado.Value.where.Should().Contain($"@{DBAdvogadosDicInfo.EMailPro}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Escritorio_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Escritorio = 1,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Escritorio_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Escritorio = 1,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Escritorio_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Escritorio = 1,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Escritorio_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Escritorio = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Escritorio}]");
        }

        [Fact]
        public void WFiltro_Escritorio_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Escritorio = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Escritorio_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Escritorio = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Escritorio_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Escritorio = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Escritorio_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorEscritorio = 42;
            var filtro = new FilterAdvogados
            {
                Escritorio = valorEscritorio,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorEscritorio);
        }

#endregion
        [Fact]
        public void WFiltro_Escritorio_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Escritorio = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Escritorio_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorEscritorio = 1;
            var filtro = new FilterAdvogados
            {
                Escritorio = valorEscritorio,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Escritorio
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Escritorio}] = @advEscritorio");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@advEscritorio");
            parametro.Value.Should().Be(valorEscritorio);
        }

        [Fact]
        public void WFiltro_Escritorio_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Escritorio = 1,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@advEscritorio");
            resultado.Value.where.Should().Contain($"@{DBAdvogadosDicInfo.EMailPro}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Escritorio_DiferentesValores_DeveFuncionar(int valorEscritorio)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Escritorio = valorEscritorio,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorEscritorio);
        }

#region filtro.Cidade_end Tests
        [Fact]
        public void WFiltro_Cidade_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cidade_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Cidade_end_QuandoTemValorPositivo_SemCidadeInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorCidadeEnd = 5000;
            var filtro = new FilterAdvogados
            {
                Cidade = int.MinValue, // Não define salário inicial
                Cidade_end = valorCidadeEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Cidade inicial válido, não deve incluir condição WHERE, mas o parâmetro Cidade_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Cidade_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Cidade_end_QuandoSomenteValorInicial_SemCidadeEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorCidade = 2500;
            var filtro = new FilterAdvogados
            {
                Cidade = valorCidade,
                Cidade_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Cidade}] = @{DBAdvogadosDicInfo.Cidade}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBAdvogadosDicInfo.Cidade}");
            parametro.Value.Should().Be(valorCidade);
        }

        [Fact]
        public void WFiltro_Cidade_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorCidadeInicial = 1000;
            var valorCidadeFinal = 5000;
            var filtro = new FilterAdvogados
            {
                Cidade = valorCidadeInicial,
                Cidade_end = valorCidadeFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].{DBAdvogadosDicInfo.Cidade} BETWEEN @{DBAdvogadosDicInfo.Cidade} AND @{DBAdvogadosDicInfo.Cidade}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Cidade}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Cidade}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorCidadeInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorCidadeFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Cidade_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cidade = valorInicial,
                Cidade_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Cidade}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Cidade}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Cidade_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cidade = 1000,
                Cidade_end = 5000,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBAdvogadosDicInfo.Cidade}");
            resultado.Value.where.Should().Contain($"@{DBAdvogadosDicInfo.EMailPro}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Cidade_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cidade = 1000,
                Cidade_end = 5000,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Cidade_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cidade = 1000,
                Cidade_end = 5000,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Cidade_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cidade = 1000,
                Cidade_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].{DBAdvogadosDicInfo.Cidade} BETWEEN");
        }

        [Fact]
        public void WFiltro_Cidade_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cidade = 1000,
                Cidade_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Cidade_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cidade = 1000,
                Cidade_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Cidade_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorCidadeInicial = 2500;
            var valorCidadeFinal = 4750;
            var filtro = new FilterAdvogados
            {
                Cidade = valorCidadeInicial,
                Cidade_end = valorCidadeFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Cidade}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Cidade}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorCidadeInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorCidadeFinal);
        }

        [Fact]
        public void WFiltro_Cidade_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cidade = 0,
                Cidade_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Cidade_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cidade = 0,
                Cidade_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Cidade_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cidade = 1500,
                Cidade_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Cidade == int.MinValue) && !(filtro.Cidade_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBAdvogadosDicInfo.PTabelaNome}].{DBAdvogadosDicInfo.Cidade} BETWEEN @{DBAdvogadosDicInfo.Cidade} AND @{DBAdvogadosDicInfo.Cidade}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Cidade_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cidade = 2000,
                Cidade_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Cidade == int.MinValue) && filtro.Cidade_end == int.MinValue
            // Deve resultar em igualdade quando apenas Cidade tem valor válido
            resultado.Value.where.Should().Be($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Cidade}] = @{DBAdvogadosDicInfo.Cidade}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Cidade_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cidade = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Cidade Isolated Tests
        [Fact]
        public void WFiltro_Cidade_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cidade = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Cidade_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorCidade = 5;
            var filtro = new FilterAdvogados
            {
                Cidade = valorCidade,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Cidade}] = @{DBAdvogadosDicInfo.Cidade}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBAdvogadosDicInfo.Cidade}");
            parametro.Value.Should().Be(valorCidade);
        }

        [Fact]
        public void WFiltro_Cidade_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorCidade = 0;
            var filtro = new FilterAdvogados
            {
                Cidade = valorCidade,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBAdvogadosDicInfo.Cidade}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCidade);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Cidade_DiferentesValoresValidos_DeveProcessarCorretamente(int valorCidade)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cidade = valorCidade,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCidade);
            resultado.Value.where.Should().Contain($"= @{DBAdvogadosDicInfo.Cidade}");
        }

        [Fact]
        public void WFiltro_Cidade_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cidade = 1,
                EMailPro = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBAdvogadosDicInfo.Cidade}");
            resultado.Value.where.Should().Contain($"@{DBAdvogadosDicInfo.EMailPro}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Cidade_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cidade = 1,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Cidade_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cidade = 1,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Cidade_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cidade = 1,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Cidade_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cidade = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Cidade}]");
        }

        [Fact]
        public void WFiltro_Cidade_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cidade = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Cidade_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cidade = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Cidade_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cidade = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Cidade_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorCidade = 42;
            var filtro = new FilterAdvogados
            {
                Cidade = valorCidade,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorCidade);
        }

#endregion
        [Fact]
        public void WFiltro_Cidade_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cidade = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Cidade_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorCidade = 1;
            var filtro = new FilterAdvogados
            {
                Cidade = valorCidade,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Cidade
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Cidade}] = @advCidade");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@advCidade");
            parametro.Value.Should().Be(valorCidade);
        }

        [Fact]
        public void WFiltro_Cidade_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cidade = 1,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@advCidade");
            resultado.Value.where.Should().Contain($"@{DBAdvogadosDicInfo.EMailPro}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Cidade_DiferentesValores_DeveFuncionar(int valorCidade)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Cidade = valorCidade,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCidade);
        }

#region filtro.Comissao_end Tests
        [Fact]
        public void WFiltro_Comissao_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Comissao_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Comissao_end_QuandoTemValorPositivo_SemComissaoInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorComissaoEnd = 5000;
            var filtro = new FilterAdvogados
            {
                Comissao = int.MinValue, // Não define salário inicial
                Comissao_end = valorComissaoEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Comissao inicial válido, não deve incluir condição WHERE, mas o parâmetro Comissao_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Comissao_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Comissao_end_QuandoSomenteValorInicial_SemComissaoEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorComissao = 2500;
            var filtro = new FilterAdvogados
            {
                Comissao = valorComissao,
                Comissao_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Comissao}] = @{DBAdvogadosDicInfo.Comissao}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBAdvogadosDicInfo.Comissao}");
            parametro.Value.Should().Be(valorComissao);
        }

        [Fact]
        public void WFiltro_Comissao_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorComissaoInicial = 1000;
            var valorComissaoFinal = 5000;
            var filtro = new FilterAdvogados
            {
                Comissao = valorComissaoInicial,
                Comissao_end = valorComissaoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].{DBAdvogadosDicInfo.Comissao} BETWEEN @{DBAdvogadosDicInfo.Comissao} AND @{DBAdvogadosDicInfo.Comissao}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Comissao}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Comissao}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorComissaoInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorComissaoFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Comissao_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Comissao = valorInicial,
                Comissao_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Comissao}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Comissao}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Comissao_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Comissao = 1000,
                Comissao_end = 5000,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBAdvogadosDicInfo.Comissao}");
            resultado.Value.where.Should().Contain($"@{DBAdvogadosDicInfo.EMailPro}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Comissao_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Comissao = 1000,
                Comissao_end = 5000,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Comissao_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Comissao = 1000,
                Comissao_end = 5000,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Comissao_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Comissao = 1000,
                Comissao_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].{DBAdvogadosDicInfo.Comissao} BETWEEN");
        }

        [Fact]
        public void WFiltro_Comissao_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Comissao = 1000,
                Comissao_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Comissao_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Comissao = 1000,
                Comissao_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Comissao_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorComissaoInicial = 2500;
            var valorComissaoFinal = 4750;
            var filtro = new FilterAdvogados
            {
                Comissao = valorComissaoInicial,
                Comissao_end = valorComissaoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Comissao}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Comissao}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorComissaoInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorComissaoFinal);
        }

        [Fact]
        public void WFiltro_Comissao_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Comissao = 0,
                Comissao_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Comissao_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Comissao = 0,
                Comissao_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Comissao_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Comissao = 1500,
                Comissao_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Comissao == int.MinValue) && !(filtro.Comissao_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBAdvogadosDicInfo.PTabelaNome}].{DBAdvogadosDicInfo.Comissao} BETWEEN @{DBAdvogadosDicInfo.Comissao} AND @{DBAdvogadosDicInfo.Comissao}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Comissao_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Comissao = 2000,
                Comissao_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Comissao == int.MinValue) && filtro.Comissao_end == int.MinValue
            // Deve resultar em igualdade quando apenas Comissao tem valor válido
            resultado.Value.where.Should().Be($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Comissao}] = @{DBAdvogadosDicInfo.Comissao}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Comissao_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Comissao = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Comissao Isolated Tests
        [Fact]
        public void WFiltro_Comissao_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Comissao = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Comissao_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorComissao = 5;
            var filtro = new FilterAdvogados
            {
                Comissao = valorComissao,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Comissao}] = @{DBAdvogadosDicInfo.Comissao}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBAdvogadosDicInfo.Comissao}");
            parametro.Value.Should().Be(valorComissao);
        }

        [Fact]
        public void WFiltro_Comissao_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorComissao = 0;
            var filtro = new FilterAdvogados
            {
                Comissao = valorComissao,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBAdvogadosDicInfo.Comissao}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorComissao);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Comissao_DiferentesValoresValidos_DeveProcessarCorretamente(int valorComissao)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Comissao = valorComissao,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorComissao);
            resultado.Value.where.Should().Contain($"= @{DBAdvogadosDicInfo.Comissao}");
        }

        [Fact]
        public void WFiltro_Comissao_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Comissao = 1,
                EMailPro = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBAdvogadosDicInfo.Comissao}");
            resultado.Value.where.Should().Contain($"@{DBAdvogadosDicInfo.EMailPro}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Comissao_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Comissao = 1,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Comissao_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Comissao = 1,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Comissao_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Comissao = 1,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Comissao_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Comissao = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Comissao}]");
        }

        [Fact]
        public void WFiltro_Comissao_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Comissao = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Comissao_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Comissao = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Comissao_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Comissao = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Comissao_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorComissao = 42;
            var filtro = new FilterAdvogados
            {
                Comissao = valorComissao,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorComissao);
        }

#endregion
        [Fact]
        public void WFiltro_Comissao_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Comissao = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Comissao_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorComissao = 1;
            var filtro = new FilterAdvogados
            {
                Comissao = valorComissao,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Comissao
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Comissao}] = @advComissao");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@advComissao");
            parametro.Value.Should().Be(valorComissao);
        }

        [Fact]
        public void WFiltro_Comissao_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Comissao = 1,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@advComissao");
            resultado.Value.where.Should().Contain($"@{DBAdvogadosDicInfo.EMailPro}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Comissao_DiferentesValores_DeveFuncionar(int valorComissao)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Comissao = valorComissao,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorComissao);
        }

#region filtro.Codigo_filtro_end Tests
        [Fact]
        public void WFiltro_Codigo_filtro_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Codigo_filtro_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Codigo_filtro_end_QuandoTemValorPositivo_SemCodigo_filtroInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorCodigo_filtroEnd = 5000;
            var filtro = new FilterAdvogados
            {
                Codigo_filtro = int.MinValue, // Não define salário inicial
                Codigo_filtro_end = valorCodigo_filtroEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Codigo_filtro inicial válido, não deve incluir condição WHERE, mas o parâmetro Codigo_filtro_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Codigo_filtro_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Codigo_filtro_end_QuandoSomenteValorInicial_SemCodigo_filtroEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorCodigo_filtro = 2500;
            var filtro = new FilterAdvogados
            {
                Codigo_filtro = valorCodigo_filtro,
                Codigo_filtro_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.CampoCodigo}] = @{DBAdvogadosDicInfo.CampoCodigo}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBAdvogadosDicInfo.CampoCodigo}");
            parametro.Value.Should().Be(valorCodigo_filtro);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorCodigo_filtroInicial = 1000;
            var valorCodigo_filtroFinal = 5000;
            var filtro = new FilterAdvogados
            {
                Codigo_filtro = valorCodigo_filtroInicial,
                Codigo_filtro_end = valorCodigo_filtroFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].{DBAdvogadosDicInfo.CampoCodigo} BETWEEN @{DBAdvogadosDicInfo.CampoCodigo} AND @{DBAdvogadosDicInfo.CampoCodigo}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAdvogadosDicInfo.CampoCodigo}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAdvogadosDicInfo.CampoCodigo}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorCodigo_filtroInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorCodigo_filtroFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Codigo_filtro_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Codigo_filtro = valorInicial,
                Codigo_filtro_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBAdvogadosDicInfo.CampoCodigo}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBAdvogadosDicInfo.CampoCodigo}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBAdvogadosDicInfo.CampoCodigo}");
            resultado.Value.where.Should().Contain($"@{DBAdvogadosDicInfo.EMailPro}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].{DBAdvogadosDicInfo.CampoCodigo} BETWEEN");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorCodigo_filtroInicial = 2500;
            var valorCodigo_filtroFinal = 4750;
            var filtro = new FilterAdvogados
            {
                Codigo_filtro = valorCodigo_filtroInicial,
                Codigo_filtro_end = valorCodigo_filtroFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBAdvogadosDicInfo.CampoCodigo}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBAdvogadosDicInfo.CampoCodigo}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorCodigo_filtroInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorCodigo_filtroFinal);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Codigo_filtro = 0,
                Codigo_filtro_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Codigo_filtro = 0,
                Codigo_filtro_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Codigo_filtro = 1500,
                Codigo_filtro_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Codigo_filtro == int.MinValue) && !(filtro.Codigo_filtro_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBAdvogadosDicInfo.PTabelaNome}].{DBAdvogadosDicInfo.CampoCodigo} BETWEEN @{DBAdvogadosDicInfo.CampoCodigo} AND @{DBAdvogadosDicInfo.CampoCodigo}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Codigo_filtro = 2000,
                Codigo_filtro_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Codigo_filtro == int.MinValue) && filtro.Codigo_filtro_end == int.MinValue
            // Deve resultar em igualdade quando apenas Codigo_filtro tem valor válido
            resultado.Value.where.Should().Be($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.CampoCodigo}] = @{DBAdvogadosDicInfo.CampoCodigo}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Codigo_filtro_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Codigo_filtro = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Codigo_filtro Isolated Tests
        [Fact]
        public void WFiltro_Codigo_filtro_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Codigo_filtro = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorCodigo_filtro = 5;
            var filtro = new FilterAdvogados
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.CampoCodigo}] = @{DBAdvogadosDicInfo.CampoCodigo}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBAdvogadosDicInfo.CampoCodigo}");
            parametro.Value.Should().Be(valorCodigo_filtro);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorCodigo_filtro = 0;
            var filtro = new FilterAdvogados
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBAdvogadosDicInfo.CampoCodigo}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCodigo_filtro);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Codigo_filtro_DiferentesValoresValidos_DeveProcessarCorretamente(int valorCodigo_filtro)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCodigo_filtro);
            resultado.Value.where.Should().Contain($"= @{DBAdvogadosDicInfo.CampoCodigo}");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Codigo_filtro = 1,
                EMailPro = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBAdvogadosDicInfo.CampoCodigo}");
            resultado.Value.where.Should().Contain($"@{DBAdvogadosDicInfo.EMailPro}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Codigo_filtro = 1,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Codigo_filtro = 1,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Codigo_filtro = 1,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Codigo_filtro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.CampoCodigo}]");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Codigo_filtro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Codigo_filtro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Codigo_filtro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorCodigo_filtro = 42;
            var filtro = new FilterAdvogados
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorCodigo_filtro);
        }

#endregion
        [Fact]
        public void WFiltro_Codigo_filtro_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Codigo_filtro = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorCodigo_filtro = 1;
            var filtro = new FilterAdvogados
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Codigo_filtro
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.CampoCodigo}] = @{DBAdvogadosDicInfo.CampoCodigo}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBAdvogadosDicInfo.CampoCodigo}");
            parametro.Value.Should().Be(valorCodigo_filtro);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Codigo_filtro = 1,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@{DBAdvogadosDicInfo.CampoCodigo}");
            resultado.Value.where.Should().Contain($"@{DBAdvogadosDicInfo.EMailPro}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Codigo_filtro_DiferentesValores_DeveFuncionar(int valorCodigo_filtro)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCodigo_filtro);
        }

#endregion
#region Decimal Tests
#region filtro.Salario_end Tests
        [Fact]
        public void WFiltro_Salario_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Salario_end = decimal.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Salario_end_QuandoTemValorPositivo_SemSalarioInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorSalarioEnd = 5000m;
            var filtro = new FilterAdvogados
            {
                Salario = decimal.MinValue, // Não define salário inicial
                Salario_end = valorSalarioEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Salario inicial válido, não deve incluir condição WHERE, mas o parâmetro Salario_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Salario_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Salario_end_QuandoSomenteValorInicial_SemSalarioEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorSalario = 2500m;
            var filtro = new FilterAdvogados
            {
                Salario = valorSalario,
                Salario_end = decimal.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Salario}] = @{DBAdvogadosDicInfo.Salario}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBAdvogadosDicInfo.Salario}");
            parametro.Value.Should().Be(valorSalario);
        }

        [Fact]
        public void WFiltro_Salario_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorSalarioInicial = 1000m;
            var valorSalarioFinal = 5000m;
            var filtro = new FilterAdvogados
            {
                Salario = valorSalarioInicial,
                Salario_end = valorSalarioFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].{DBAdvogadosDicInfo.Salario} BETWEEN @{DBAdvogadosDicInfo.Salario} AND @{DBAdvogadosDicInfo.Salario}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Salario}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Salario}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorSalarioInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorSalarioFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500.50, 7500.75)]
        [InlineData(10000, 50000)]
        public void WFiltro_Salario_RangeDiferentesValores_DeveProcessarCorretamente(decimal valorInicial, decimal valorFinal)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Salario = valorInicial,
                Salario_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Salario}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Salario}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Salario_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Salario = 1000m,
                Salario_end = 5000m,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBAdvogadosDicInfo.Salario}");
            resultado.Value.where.Should().Contain($"@{DBAdvogadosDicInfo.EMailPro}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Salario_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Salario = 1000m,
                Salario_end = 5000m,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Salario_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Salario = 1000m,
                Salario_end = 5000m,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Salario_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Salario = 1000m,
                Salario_end = 5000m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].{DBAdvogadosDicInfo.Salario} BETWEEN");
        }

        [Fact]
        public void WFiltro_Salario_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Salario = 1000m,
                Salario_end = 5000m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Salario_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Salario = 1000m,
                Salario_end = 5000m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Salario_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorSalarioInicial = 1500.50m;
            var valorSalarioFinal = 3750.75m;
            var filtro = new FilterAdvogados
            {
                Salario = valorSalarioInicial,
                Salario_end = valorSalarioFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Salario}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Salario}_end");
            parametroInicial.Value.Should().BeOfType<decimal>();
            parametroInicial.Value.Should().Be(valorSalarioInicial);
            parametroFinal.Value.Should().BeOfType<decimal>();
            parametroFinal.Value.Should().Be(valorSalarioFinal);
        }

        [Fact]
        public void WFiltro_Salario_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Salario = 0m,
                Salario_end = 0m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Salario_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Salario = 0m,
                Salario_end = decimal.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Salario_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Salario = 1500m,
                Salario_end = 4500m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Salario == decimal.MinValue) && !(filtro.Salario_end == decimal.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBAdvogadosDicInfo.PTabelaNome}].{DBAdvogadosDicInfo.Salario} BETWEEN @{DBAdvogadosDicInfo.Salario} AND @{DBAdvogadosDicInfo.Salario}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Salario_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Salario = 2000m,
                Salario_end = decimal.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Salario == decimal.MinValue) && filtro.Salario_end == decimal.MinValue
            // Deve resultar em igualdade quando apenas Salario tem valor válido
            resultado.Value.where.Should().Be($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Salario}] = @{DBAdvogadosDicInfo.Salario}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData("79228162514264337593543950335")]
        [InlineData("-79228162514264337593543950335")] // MinValue é usado como "não filtrar"
        [InlineData("0.01")]
        [InlineData("-999999.99")]
        public void WFiltro_Salario_ComValoresExtremos_DeveProcessarCorretamente(string valorExtremoStr)
        {
            // Arrange
            var valorExtremo = decimal.Parse(valorExtremoStr, System.Globalization.CultureInfo.InvariantCulture);
            var filtro = new FilterAdvogados
            {
                Salario = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(valorExtremo == decimal.MinValue ? 0 : 1);
            if (valorExtremo != decimal.MinValue)
            {
                resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
            }
        }

#region filtro.Salario Isolated Tests
        [Fact]
        public void WFiltro_Salario_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Salario = decimal.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Salario_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorSalario = 5;
            var filtro = new FilterAdvogados
            {
                Salario = valorSalario,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Salario}] = @{DBAdvogadosDicInfo.Salario}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBAdvogadosDicInfo.Salario}");
            parametro.Value.Should().Be(valorSalario);
        }

        [Fact]
        public void WFiltro_Salario_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorSalario = 0;
            var filtro = new FilterAdvogados
            {
                Salario = valorSalario,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBAdvogadosDicInfo.Salario}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorSalario);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Salario_DiferentesValoresValidos_DeveProcessarCorretamente(decimal valorSalario)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Salario = valorSalario,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorSalario);
            resultado.Value.where.Should().Contain($"= @{DBAdvogadosDicInfo.Salario}");
        }

        [Fact]
        public void WFiltro_Salario_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Salario = 1,
                EMailPro = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBAdvogadosDicInfo.Salario}");
            resultado.Value.where.Should().Contain($"@{DBAdvogadosDicInfo.EMailPro}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Salario_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Salario = 1,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Salario_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Salario = 1,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Salario_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Salario = 1,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Salario_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Salario = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Salario}]");
        }

        [Fact]
        public void WFiltro_Salario_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Salario = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Salario_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Salario = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Salario_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Salario = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Salario_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            var valorSalario = (decimal)42.12;
            var filtro = new FilterAdvogados
            {
                Salario = valorSalario,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<decimal>();
            parametro.Value.Should().Be(valorSalario);
        }

#endregion
        [Fact]
        public void WFiltro_Salario_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Salario = decimal.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Salario_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            decimal valorSalario = 1;
            var filtro = new FilterAdvogados
            {
                Salario = valorSalario,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Salario
            resultado.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Salario}] = @advSalario");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@advSalario");
            parametro.Value.Should().Be(valorSalario);
        }

        [Fact]
        public void WFiltro_Salario_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Salario = (decimal)1,
                EMailPro = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@advSalario");
            resultado.Value.where.Should().Contain($"@{DBAdvogadosDicInfo.EMailPro}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1.2)]
        [InlineData(999.40)]
        public void WFiltro_Salario_DiferentesValores_DeveFuncionar(decimal valorSalario)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Salario = valorSalario,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorSalario);
        }

#endregion
#region DateTime Tests
        [Theory]
        [InlineData("31/12/9999")] // Data máxima
        [InlineData("01/01/1900")] // Data muito antiga
        [InlineData("29/02/2024")] // Ano bissexto
        public void WFiltro_DtInicio_ComDatasExtremas_DeveProcessarCorretamente(string dataExtrema)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                DtInicio = dataExtrema,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<DateTime>();
        }

        [Theory]
        [InlineData("32/12/2023")] // Dia inválido
        [InlineData("31/13/2023")] // Mês inválido
        [InlineData("29/02/2023")] // Não é ano bissexto
        [InlineData("abc/def/ghij")] // Formato completamente inválido
        public void WFiltro_DtInicio_ComDatasInvalidas_NaoDeveAdicionarParametros(string dataInvalida)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                DtInicio = dataInvalida,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().BeEmpty();
            resultado.Value.where.Should().BeEmpty();
        }

#region DtInicio Tests
        [Fact]
        public void WFiltro_DtInicio_WhenEmptyOrNull_ShouldNotAddParameters()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                DtInicio = string.Empty,
                DtInicio_end = null,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DtInicio_WhenValidSingleDate_ShouldAddParameterAndGenerateWhereClause()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterAdvogados
            {
                DtInicio = testDate,
                DtInicio_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(1);
            var parameter = result.Value.parametros.First();
            parameter.ParameterName.Should().Be($"@{DBAdvogadosDicInfo.DtInicio}");
            parameter.Value.Should().BeOfType<DateTime>();
            var expectedDate = DateTime.Parse(testDate);
            ((DateTime)parameter.Value).Should().Be(expectedDate);
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.DtInicio}], 103) = CONVERT(DATE, @{DBAdvogadosDicInfo.DtInicio}, 103)");
        }

        [Fact]
        public void WFiltro_DtInicio_WhenValidDateRange_ShouldAddBothParametersAndGenerateBetweenClause()
        {
            // Arrange
            var startDate = "01/06/2023";
            var endDate = "30/06/2023";
            var filtro = new FilterAdvogados
            {
                DtInicio = startDate,
                DtInicio_end = endDate,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(2);
            var startParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAdvogadosDicInfo.DtInicio}");
            var endParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAdvogadosDicInfo.DtInicio}_end");
            startParameter.Should().NotBeNull();
            endParameter.Should().NotBeNull();
            startParameter!.Value.Should().BeOfType<DateTime>();
            endParameter!.Value.Should().BeOfType<DateTime>();
            ((DateTime)startParameter.Value).Should().Be(DateTime.Parse(startDate));
            ((DateTime)endParameter.Value).Should().Be(DateTime.Parse(endDate));
            result.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].{DBAdvogadosDicInfo.DtInicio} BETWEEN @{DBAdvogadosDicInfo.DtInicio} AND @{DBAdvogadosDicInfo.DtInicio}_end");
        }

        [Fact]
        public void WFiltro_DtInicio_WhenInvalidDateFormat_ShouldNotAddParameter()
        {
            // Arrange
            var invalidDate = "invalid-date";
            var filtro = new FilterAdvogados
            {
                DtInicio = invalidDate,
                DtInicio_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DtInicio_WhenStartDateValidButEndDateInvalid_ShouldOnlyAddStartParameterAndGenerateSingleDateClause()
        {
            // Arrange
            var validStartDate = "15/06/2023";
            var invalidEndDate = "invalid-date";
            var filtro = new FilterAdvogados
            {
                DtInicio = validStartDate,
                DtInicio_end = invalidEndDate,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(1);
            var parameter = result.Value.parametros.First();
            parameter.ParameterName.Should().Be($"@{DBAdvogadosDicInfo.DtInicio}");
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.DtInicio}], 103) = CONVERT(DATE, @{DBAdvogadosDicInfo.DtInicio}, 103)");
            result.Value.where.Should().NotContain("BETWEEN");
        }

        [Fact]
        public void WFiltro_DtInicio_WhenStartDateInvalidButEndDateValid_ShouldNotAddAnyParameters()
        {
            // Arrange
            var invalidStartDate = "invalid-date";
            var validEndDate = "30/06/2023";
            var filtro = new FilterAdvogados
            {
                DtInicio = invalidStartDate,
                DtInicio_end = validEndDate,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DtInicio_WhenWhitespaceOnlyDates_ShouldNotAddParameters()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                DtInicio = "   ",
                DtInicio_end = "\t\n",
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DtInicio_WithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterAdvogados
            {
                EMailPro = "A",
                DtInicio = testDate,
                DtInicio_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(2); // Nome + DtInicio
            result.Value.where.Should().Contain(TSql.And);
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.DtInicio}], 103) = CONVERT(DATE, @{DBAdvogadosDicInfo.DtInicio}, 103)");
        }

        [Fact]
        public void WFiltro_DtInicio_WithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterAdvogados
            {
                EMailPro = "A",
                DtInicio = testDate,
                DtInicio_end = string.Empty,
                LogicalOperator = TSql.OR
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(TSql.OR);
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.DtInicio}], 103) = CONVERT(DATE, @{DBAdvogadosDicInfo.DtInicio}, 103)");
        }

        [Fact]
        public void WFiltro_DtInicio_WhenOnlyEndDateProvided_ShouldNotAddParameters()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                DtInicio = string.Empty,
                DtInicio_end = "30/06/2023",
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DtInicio_WhenDateTimeMinValue_ShouldNotAddParameters()
        {
            // Arrange
            var minValueDate = DateTime.MinValue.ToString("dd/MM/yyyy");
            var filtro = new FilterAdvogados
            {
                DtInicio = minValueDate,
                DtInicio_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // The IsEmptyDX extension method should catch DateTime.MinValue and return true
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DtInicio_AsFirstFilter_ShouldNotIncludeLogicalOperatorAtStart()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterAdvogados
            {
                DtInicio = testDate,
                DtInicio_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().NotStartWith(TSql.And);
            result.Value.where.Should().StartWith($"CONVERT(DATE,[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.DtInicio}], 103)");
        }

        [Theory]
        [InlineData("15/06/2023", "2023-06-15T00:00:00")]
        [InlineData("01/01/2024", "2024-01-01T00:00:00")]
        [InlineData("31/12/2022", "2022-12-31T00:00:00")]
        public void WFiltro_DtInicio_WhenVariousValidDateFormats_ShouldParseCorrectly(string inputDate, string expectedDateTimeString)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                DtInicio = inputDate,
                DtInicio_end = string.Empty,
                LogicalOperator = TSql.And
            };
            var expectedDateTime = DateTime.Parse(expectedDateTimeString);
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(1);
            var parameter = result.Value.parametros.First();
            ((DateTime)parameter.Value).Should().Be(expectedDateTime);
        }

#endregion
        [Theory]
        [InlineData("31/12/9999")] // Data máxima
        [InlineData("01/01/1900")] // Data muito antiga
        [InlineData("29/02/2024")] // Ano bissexto
        public void WFiltro_DtFim_ComDatasExtremas_DeveProcessarCorretamente(string dataExtrema)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                DtFim = dataExtrema,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<DateTime>();
        }

        [Theory]
        [InlineData("32/12/2023")] // Dia inválido
        [InlineData("31/13/2023")] // Mês inválido
        [InlineData("29/02/2023")] // Não é ano bissexto
        [InlineData("abc/def/ghij")] // Formato completamente inválido
        public void WFiltro_DtFim_ComDatasInvalidas_NaoDeveAdicionarParametros(string dataInvalida)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                DtFim = dataInvalida,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().BeEmpty();
            resultado.Value.where.Should().BeEmpty();
        }

#region DtFim Tests
        [Fact]
        public void WFiltro_DtFim_WhenEmptyOrNull_ShouldNotAddParameters()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                DtFim = string.Empty,
                DtFim_end = null,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DtFim_WhenValidSingleDate_ShouldAddParameterAndGenerateWhereClause()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterAdvogados
            {
                DtFim = testDate,
                DtFim_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(1);
            var parameter = result.Value.parametros.First();
            parameter.ParameterName.Should().Be($"@{DBAdvogadosDicInfo.DtFim}");
            parameter.Value.Should().BeOfType<DateTime>();
            var expectedDate = DateTime.Parse(testDate);
            ((DateTime)parameter.Value).Should().Be(expectedDate);
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.DtFim}], 103) = CONVERT(DATE, @{DBAdvogadosDicInfo.DtFim}, 103)");
        }

        [Fact]
        public void WFiltro_DtFim_WhenValidDateRange_ShouldAddBothParametersAndGenerateBetweenClause()
        {
            // Arrange
            var startDate = "01/06/2023";
            var endDate = "30/06/2023";
            var filtro = new FilterAdvogados
            {
                DtFim = startDate,
                DtFim_end = endDate,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(2);
            var startParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAdvogadosDicInfo.DtFim}");
            var endParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAdvogadosDicInfo.DtFim}_end");
            startParameter.Should().NotBeNull();
            endParameter.Should().NotBeNull();
            startParameter!.Value.Should().BeOfType<DateTime>();
            endParameter!.Value.Should().BeOfType<DateTime>();
            ((DateTime)startParameter.Value).Should().Be(DateTime.Parse(startDate));
            ((DateTime)endParameter.Value).Should().Be(DateTime.Parse(endDate));
            result.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].{DBAdvogadosDicInfo.DtFim} BETWEEN @{DBAdvogadosDicInfo.DtFim} AND @{DBAdvogadosDicInfo.DtFim}_end");
        }

        [Fact]
        public void WFiltro_DtFim_WhenInvalidDateFormat_ShouldNotAddParameter()
        {
            // Arrange
            var invalidDate = "invalid-date";
            var filtro = new FilterAdvogados
            {
                DtFim = invalidDate,
                DtFim_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DtFim_WhenStartDateValidButEndDateInvalid_ShouldOnlyAddStartParameterAndGenerateSingleDateClause()
        {
            // Arrange
            var validStartDate = "15/06/2023";
            var invalidEndDate = "invalid-date";
            var filtro = new FilterAdvogados
            {
                DtFim = validStartDate,
                DtFim_end = invalidEndDate,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(1);
            var parameter = result.Value.parametros.First();
            parameter.ParameterName.Should().Be($"@{DBAdvogadosDicInfo.DtFim}");
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.DtFim}], 103) = CONVERT(DATE, @{DBAdvogadosDicInfo.DtFim}, 103)");
            result.Value.where.Should().NotContain("BETWEEN");
        }

        [Fact]
        public void WFiltro_DtFim_WhenStartDateInvalidButEndDateValid_ShouldNotAddAnyParameters()
        {
            // Arrange
            var invalidStartDate = "invalid-date";
            var validEndDate = "30/06/2023";
            var filtro = new FilterAdvogados
            {
                DtFim = invalidStartDate,
                DtFim_end = validEndDate,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DtFim_WhenWhitespaceOnlyDates_ShouldNotAddParameters()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                DtFim = "   ",
                DtFim_end = "\t\n",
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DtFim_WithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterAdvogados
            {
                EMailPro = "A",
                DtFim = testDate,
                DtFim_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(2); // Nome + DtFim
            result.Value.where.Should().Contain(TSql.And);
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.DtFim}], 103) = CONVERT(DATE, @{DBAdvogadosDicInfo.DtFim}, 103)");
        }

        [Fact]
        public void WFiltro_DtFim_WithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterAdvogados
            {
                EMailPro = "A",
                DtFim = testDate,
                DtFim_end = string.Empty,
                LogicalOperator = TSql.OR
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(TSql.OR);
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.DtFim}], 103) = CONVERT(DATE, @{DBAdvogadosDicInfo.DtFim}, 103)");
        }

        [Fact]
        public void WFiltro_DtFim_WhenOnlyEndDateProvided_ShouldNotAddParameters()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                DtFim = string.Empty,
                DtFim_end = "30/06/2023",
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DtFim_WhenDateTimeMinValue_ShouldNotAddParameters()
        {
            // Arrange
            var minValueDate = DateTime.MinValue.ToString("dd/MM/yyyy");
            var filtro = new FilterAdvogados
            {
                DtFim = minValueDate,
                DtFim_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // The IsEmptyDX extension method should catch DateTime.MinValue and return true
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DtFim_AsFirstFilter_ShouldNotIncludeLogicalOperatorAtStart()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterAdvogados
            {
                DtFim = testDate,
                DtFim_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().NotStartWith(TSql.And);
            result.Value.where.Should().StartWith($"CONVERT(DATE,[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.DtFim}], 103)");
        }

        [Theory]
        [InlineData("15/06/2023", "2023-06-15T00:00:00")]
        [InlineData("01/01/2024", "2024-01-01T00:00:00")]
        [InlineData("31/12/2022", "2022-12-31T00:00:00")]
        public void WFiltro_DtFim_WhenVariousValidDateFormats_ShouldParseCorrectly(string inputDate, string expectedDateTimeString)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                DtFim = inputDate,
                DtFim_end = string.Empty,
                LogicalOperator = TSql.And
            };
            var expectedDateTime = DateTime.Parse(expectedDateTimeString);
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(1);
            var parameter = result.Value.parametros.First();
            ((DateTime)parameter.Value).Should().Be(expectedDateTime);
        }

#endregion
        [Theory]
        [InlineData("31/12/9999")] // Data máxima
        [InlineData("01/01/1900")] // Data muito antiga
        [InlineData("29/02/2024")] // Ano bissexto
        public void WFiltro_DtNasc_ComDatasExtremas_DeveProcessarCorretamente(string dataExtrema)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                DtNasc = dataExtrema,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<DateTime>();
        }

        [Theory]
        [InlineData("32/12/2023")] // Dia inválido
        [InlineData("31/13/2023")] // Mês inválido
        [InlineData("29/02/2023")] // Não é ano bissexto
        [InlineData("abc/def/ghij")] // Formato completamente inválido
        public void WFiltro_DtNasc_ComDatasInvalidas_NaoDeveAdicionarParametros(string dataInvalida)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                DtNasc = dataInvalida,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().BeEmpty();
            resultado.Value.where.Should().BeEmpty();
        }

#region DtNasc Tests
        [Fact]
        public void WFiltro_DtNasc_WhenEmptyOrNull_ShouldNotAddParameters()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                DtNasc = string.Empty,
                DtNasc_end = null,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DtNasc_WhenValidSingleDate_ShouldAddParameterAndGenerateWhereClause()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterAdvogados
            {
                DtNasc = testDate,
                DtNasc_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(1);
            var parameter = result.Value.parametros.First();
            parameter.ParameterName.Should().Be($"@{DBAdvogadosDicInfo.DtNasc}");
            parameter.Value.Should().BeOfType<DateTime>();
            var expectedDate = DateTime.Parse(testDate);
            ((DateTime)parameter.Value).Should().Be(expectedDate);
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.DtNasc}], 103) = CONVERT(DATE, @{DBAdvogadosDicInfo.DtNasc}, 103)");
        }

        [Fact]
        public void WFiltro_DtNasc_WhenValidDateRange_ShouldAddBothParametersAndGenerateBetweenClause()
        {
            // Arrange
            var startDate = "01/06/2023";
            var endDate = "30/06/2023";
            var filtro = new FilterAdvogados
            {
                DtNasc = startDate,
                DtNasc_end = endDate,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(2);
            var startParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAdvogadosDicInfo.DtNasc}");
            var endParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAdvogadosDicInfo.DtNasc}_end");
            startParameter.Should().NotBeNull();
            endParameter.Should().NotBeNull();
            startParameter!.Value.Should().BeOfType<DateTime>();
            endParameter!.Value.Should().BeOfType<DateTime>();
            ((DateTime)startParameter.Value).Should().Be(DateTime.Parse(startDate));
            ((DateTime)endParameter.Value).Should().Be(DateTime.Parse(endDate));
            result.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].{DBAdvogadosDicInfo.DtNasc} BETWEEN @{DBAdvogadosDicInfo.DtNasc} AND @{DBAdvogadosDicInfo.DtNasc}_end");
        }

        [Fact]
        public void WFiltro_DtNasc_WhenInvalidDateFormat_ShouldNotAddParameter()
        {
            // Arrange
            var invalidDate = "invalid-date";
            var filtro = new FilterAdvogados
            {
                DtNasc = invalidDate,
                DtNasc_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DtNasc_WhenStartDateValidButEndDateInvalid_ShouldOnlyAddStartParameterAndGenerateSingleDateClause()
        {
            // Arrange
            var validStartDate = "15/06/2023";
            var invalidEndDate = "invalid-date";
            var filtro = new FilterAdvogados
            {
                DtNasc = validStartDate,
                DtNasc_end = invalidEndDate,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(1);
            var parameter = result.Value.parametros.First();
            parameter.ParameterName.Should().Be($"@{DBAdvogadosDicInfo.DtNasc}");
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.DtNasc}], 103) = CONVERT(DATE, @{DBAdvogadosDicInfo.DtNasc}, 103)");
            result.Value.where.Should().NotContain("BETWEEN");
        }

        [Fact]
        public void WFiltro_DtNasc_WhenStartDateInvalidButEndDateValid_ShouldNotAddAnyParameters()
        {
            // Arrange
            var invalidStartDate = "invalid-date";
            var validEndDate = "30/06/2023";
            var filtro = new FilterAdvogados
            {
                DtNasc = invalidStartDate,
                DtNasc_end = validEndDate,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DtNasc_WhenWhitespaceOnlyDates_ShouldNotAddParameters()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                DtNasc = "   ",
                DtNasc_end = "\t\n",
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DtNasc_WithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterAdvogados
            {
                EMailPro = "A",
                DtNasc = testDate,
                DtNasc_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(2); // Nome + DtNasc
            result.Value.where.Should().Contain(TSql.And);
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.DtNasc}], 103) = CONVERT(DATE, @{DBAdvogadosDicInfo.DtNasc}, 103)");
        }

        [Fact]
        public void WFiltro_DtNasc_WithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterAdvogados
            {
                EMailPro = "A",
                DtNasc = testDate,
                DtNasc_end = string.Empty,
                LogicalOperator = TSql.OR
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(TSql.OR);
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.DtNasc}], 103) = CONVERT(DATE, @{DBAdvogadosDicInfo.DtNasc}, 103)");
        }

        [Fact]
        public void WFiltro_DtNasc_WhenOnlyEndDateProvided_ShouldNotAddParameters()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                DtNasc = string.Empty,
                DtNasc_end = "30/06/2023",
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DtNasc_WhenDateTimeMinValue_ShouldNotAddParameters()
        {
            // Arrange
            var minValueDate = DateTime.MinValue.ToString("dd/MM/yyyy");
            var filtro = new FilterAdvogados
            {
                DtNasc = minValueDate,
                DtNasc_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // The IsEmptyDX extension method should catch DateTime.MinValue and return true
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DtNasc_AsFirstFilter_ShouldNotIncludeLogicalOperatorAtStart()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterAdvogados
            {
                DtNasc = testDate,
                DtNasc_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().NotStartWith(TSql.And);
            result.Value.where.Should().StartWith($"CONVERT(DATE,[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.DtNasc}], 103)");
        }

        [Theory]
        [InlineData("15/06/2023", "2023-06-15T00:00:00")]
        [InlineData("01/01/2024", "2024-01-01T00:00:00")]
        [InlineData("31/12/2022", "2022-12-31T00:00:00")]
        public void WFiltro_DtNasc_WhenVariousValidDateFormats_ShouldParseCorrectly(string inputDate, string expectedDateTimeString)
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                DtNasc = inputDate,
                DtNasc_end = string.Empty,
                LogicalOperator = TSql.And
            };
            var expectedDateTime = DateTime.Parse(expectedDateTimeString);
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(1);
            var parameter = result.Value.parametros.First();
            ((DateTime)parameter.Value).Should().Be(expectedDateTime);
        }

#endregion
#endregion
#region Bool Tests
#region Casa Filter Tests
        [Fact]
        public void WFiltro_CasaEqualsIntMinValue_ShouldNotAddParameterOrWhereClause()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Casa = int.MinValue
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().NotContain(p => p.ParameterName.Contains(DBAdvogadosDicInfo.Casa));
            result.Value.where.Should().NotContain(DBAdvogadosDicInfo.Casa);
        }

        [Fact]
        public void WFiltro_CasaHasValidValue_ShouldAddParameterAndWhereClause()
        {
            // Arrange
            var CasaValue = 1;
            var filtro = new FilterAdvogados
            {
                Casa = CasaValue,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // Check parameter
            var CasaParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Casa}");
            CasaParameter.Should().NotBeNull();
            CasaParameter.Value.Should().Be(CasaValue);
            // Check where clause
            result.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Casa}] = @{DBAdvogadosDicInfo.Casa}");
        }

        [Fact]
        public void WFiltro_CasaWithDifferentValues_ShouldAddCorrectParameterValue()
        {
            // Arrange & Act & Assert for Casa = 0 (typically female)
            var filtroFemale = new FilterAdvogados
            {
                Casa = 0
            };
            var resultFemale = _service.WFiltro(filtroFemale);
            resultFemale.Should().NotBeNull();
            var femaleParam = resultFemale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Casa}");
            femaleParam.Should().NotBeNull();
            femaleParam.Value.Should().Be(0);
            // Arrange & Act & Assert for Casa = 1 (typically male)
            var filtroMale = new FilterAdvogados
            {
                Casa = 1
            };
            var resultMale = _service.WFiltro(filtroMale);
            resultMale.Should().NotBeNull();
            var maleParam = resultMale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Casa}");
            maleParam.Should().NotBeNull();
            maleParam.Value.Should().Be(1);
        }

        [Fact]
        public void WFiltro_CasaAsFirstFilter_ShouldNotIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Casa = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().StartWith($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Casa}] = @{DBAdvogadosDicInfo.Casa}");
            result.Value.where.Should().NotStartWith(" AND ");
        }

        [Fact]
        public void WFiltro_CasaWithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                EMailPro = "EMailPro",
                Casa = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain($" AND ");
        }

        [Fact]
        public void WFiltro_CasaWithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                EMailPro = "EMailPro",
                Casa = 1,
                LogicalOperator = " OR "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(" OR ");
        }

#endregion
#region Estagiario Filter Tests
        [Fact]
        public void WFiltro_EstagiarioEqualsIntMinValue_ShouldNotAddParameterOrWhereClause()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Estagiario = int.MinValue
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().NotContain(p => p.ParameterName.Contains(DBAdvogadosDicInfo.Estagiario));
            result.Value.where.Should().NotContain(DBAdvogadosDicInfo.Estagiario);
        }

        [Fact]
        public void WFiltro_EstagiarioHasValidValue_ShouldAddParameterAndWhereClause()
        {
            // Arrange
            var EstagiarioValue = 1;
            var filtro = new FilterAdvogados
            {
                Estagiario = EstagiarioValue,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // Check parameter
            var EstagiarioParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Estagiario}");
            EstagiarioParameter.Should().NotBeNull();
            EstagiarioParameter.Value.Should().Be(EstagiarioValue);
            // Check where clause
            result.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Estagiario}] = @{DBAdvogadosDicInfo.Estagiario}");
        }

        [Fact]
        public void WFiltro_EstagiarioWithDifferentValues_ShouldAddCorrectParameterValue()
        {
            // Arrange & Act & Assert for Estagiario = 0 (typically female)
            var filtroFemale = new FilterAdvogados
            {
                Estagiario = 0
            };
            var resultFemale = _service.WFiltro(filtroFemale);
            resultFemale.Should().NotBeNull();
            var femaleParam = resultFemale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Estagiario}");
            femaleParam.Should().NotBeNull();
            femaleParam.Value.Should().Be(0);
            // Arrange & Act & Assert for Estagiario = 1 (typically male)
            var filtroMale = new FilterAdvogados
            {
                Estagiario = 1
            };
            var resultMale = _service.WFiltro(filtroMale);
            resultMale.Should().NotBeNull();
            var maleParam = resultMale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Estagiario}");
            maleParam.Should().NotBeNull();
            maleParam.Value.Should().Be(1);
        }

        [Fact]
        public void WFiltro_EstagiarioAsFirstFilter_ShouldNotIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Estagiario = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().StartWith($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Estagiario}] = @{DBAdvogadosDicInfo.Estagiario}");
            result.Value.where.Should().NotStartWith(" AND ");
        }

        [Fact]
        public void WFiltro_EstagiarioWithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                EMailPro = "EMailPro",
                Estagiario = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain($" AND ");
        }

        [Fact]
        public void WFiltro_EstagiarioWithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                EMailPro = "EMailPro",
                Estagiario = 1,
                LogicalOperator = " OR "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(" OR ");
        }

#endregion
#region Sexo Filter Tests
        [Fact]
        public void WFiltro_SexoEqualsIntMinValue_ShouldNotAddParameterOrWhereClause()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Sexo = int.MinValue
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().NotContain(p => p.ParameterName.Contains(DBAdvogadosDicInfo.Sexo));
            result.Value.where.Should().NotContain(DBAdvogadosDicInfo.Sexo);
        }

        [Fact]
        public void WFiltro_SexoHasValidValue_ShouldAddParameterAndWhereClause()
        {
            // Arrange
            var SexoValue = 1;
            var filtro = new FilterAdvogados
            {
                Sexo = SexoValue,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // Check parameter
            var SexoParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Sexo}");
            SexoParameter.Should().NotBeNull();
            SexoParameter.Value.Should().Be(SexoValue);
            // Check where clause
            result.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Sexo}] = @{DBAdvogadosDicInfo.Sexo}");
        }

        [Fact]
        public void WFiltro_SexoWithDifferentValues_ShouldAddCorrectParameterValue()
        {
            // Arrange & Act & Assert for Sexo = 0 (typically female)
            var filtroFemale = new FilterAdvogados
            {
                Sexo = 0
            };
            var resultFemale = _service.WFiltro(filtroFemale);
            resultFemale.Should().NotBeNull();
            var femaleParam = resultFemale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Sexo}");
            femaleParam.Should().NotBeNull();
            femaleParam.Value.Should().Be(0);
            // Arrange & Act & Assert for Sexo = 1 (typically male)
            var filtroMale = new FilterAdvogados
            {
                Sexo = 1
            };
            var resultMale = _service.WFiltro(filtroMale);
            resultMale.Should().NotBeNull();
            var maleParam = resultMale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Sexo}");
            maleParam.Should().NotBeNull();
            maleParam.Value.Should().Be(1);
        }

        [Fact]
        public void WFiltro_SexoAsFirstFilter_ShouldNotIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Sexo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().StartWith($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Sexo}] = @{DBAdvogadosDicInfo.Sexo}");
            result.Value.where.Should().NotStartWith(" AND ");
        }

        [Fact]
        public void WFiltro_SexoWithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                EMailPro = "EMailPro",
                Sexo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain($" AND ");
        }

        [Fact]
        public void WFiltro_SexoWithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                EMailPro = "EMailPro",
                Sexo = 1,
                LogicalOperator = " OR "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(" OR ");
        }

#endregion
#region ParcTop Filter Tests
        [Fact]
        public void WFiltro_ParcTopEqualsIntMinValue_ShouldNotAddParameterOrWhereClause()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                ParcTop = int.MinValue
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().NotContain(p => p.ParameterName.Contains(DBAdvogadosDicInfo.ParcTop));
            result.Value.where.Should().NotContain(DBAdvogadosDicInfo.ParcTop);
        }

        [Fact]
        public void WFiltro_ParcTopHasValidValue_ShouldAddParameterAndWhereClause()
        {
            // Arrange
            var ParcTopValue = 1;
            var filtro = new FilterAdvogados
            {
                ParcTop = ParcTopValue,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // Check parameter
            var ParcTopParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAdvogadosDicInfo.ParcTop}");
            ParcTopParameter.Should().NotBeNull();
            ParcTopParameter.Value.Should().Be(ParcTopValue);
            // Check where clause
            result.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.ParcTop}] = @{DBAdvogadosDicInfo.ParcTop}");
        }

        [Fact]
        public void WFiltro_ParcTopWithDifferentValues_ShouldAddCorrectParameterValue()
        {
            // Arrange & Act & Assert for ParcTop = 0 (typically female)
            var filtroFemale = new FilterAdvogados
            {
                ParcTop = 0
            };
            var resultFemale = _service.WFiltro(filtroFemale);
            resultFemale.Should().NotBeNull();
            var femaleParam = resultFemale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAdvogadosDicInfo.ParcTop}");
            femaleParam.Should().NotBeNull();
            femaleParam.Value.Should().Be(0);
            // Arrange & Act & Assert for ParcTop = 1 (typically male)
            var filtroMale = new FilterAdvogados
            {
                ParcTop = 1
            };
            var resultMale = _service.WFiltro(filtroMale);
            resultMale.Should().NotBeNull();
            var maleParam = resultMale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAdvogadosDicInfo.ParcTop}");
            maleParam.Should().NotBeNull();
            maleParam.Value.Should().Be(1);
        }

        [Fact]
        public void WFiltro_ParcTopAsFirstFilter_ShouldNotIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                ParcTop = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().StartWith($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.ParcTop}] = @{DBAdvogadosDicInfo.ParcTop}");
            result.Value.where.Should().NotStartWith(" AND ");
        }

        [Fact]
        public void WFiltro_ParcTopWithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                EMailPro = "EMailPro",
                ParcTop = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain($" AND ");
        }

        [Fact]
        public void WFiltro_ParcTopWithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                EMailPro = "EMailPro",
                ParcTop = 1,
                LogicalOperator = " OR "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(" OR ");
        }

#endregion
#region Top Filter Tests
        [Fact]
        public void WFiltro_TopEqualsIntMinValue_ShouldNotAddParameterOrWhereClause()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Top = int.MinValue
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().NotContain(p => p.ParameterName.Contains(DBAdvogadosDicInfo.Top));
            result.Value.where.Should().NotContain(DBAdvogadosDicInfo.Top);
        }

        [Fact]
        public void WFiltro_TopHasValidValue_ShouldAddParameterAndWhereClause()
        {
            // Arrange
            var TopValue = 1;
            var filtro = new FilterAdvogados
            {
                Top = TopValue,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // Check parameter
            var TopParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Top}");
            TopParameter.Should().NotBeNull();
            TopParameter.Value.Should().Be(TopValue);
            // Check where clause
            result.Value.where.Should().Contain($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Top}] = @{DBAdvogadosDicInfo.Top}");
        }

        [Fact]
        public void WFiltro_TopWithDifferentValues_ShouldAddCorrectParameterValue()
        {
            // Arrange & Act & Assert for Top = 0 (typically female)
            var filtroFemale = new FilterAdvogados
            {
                Top = 0
            };
            var resultFemale = _service.WFiltro(filtroFemale);
            resultFemale.Should().NotBeNull();
            var femaleParam = resultFemale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Top}");
            femaleParam.Should().NotBeNull();
            femaleParam.Value.Should().Be(0);
            // Arrange & Act & Assert for Top = 1 (typically male)
            var filtroMale = new FilterAdvogados
            {
                Top = 1
            };
            var resultMale = _service.WFiltro(filtroMale);
            resultMale.Should().NotBeNull();
            var maleParam = resultMale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBAdvogadosDicInfo.Top}");
            maleParam.Should().NotBeNull();
            maleParam.Value.Should().Be(1);
        }

        [Fact]
        public void WFiltro_TopAsFirstFilter_ShouldNotIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                Top = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().StartWith($"[{DBAdvogadosDicInfo.PTabelaNome}].[{DBAdvogadosDicInfo.Top}] = @{DBAdvogadosDicInfo.Top}");
            result.Value.where.Should().NotStartWith(" AND ");
        }

        [Fact]
        public void WFiltro_TopWithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                EMailPro = "EMailPro",
                Top = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain($" AND ");
        }

        [Fact]
        public void WFiltro_TopWithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var filtro = new FilterAdvogados
            {
                EMailPro = "EMailPro",
                Top = 1,
                LogicalOperator = " OR "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(" OR ");
        }

#endregion
#endregion
        [Fact]
        public void Dispose_CalledOnce_DisposesCorrectly()
        {
            // Act
            _service.Dispose();
            // Assert - Should not throw any exception
            Assert.True(true);
        }

        [Fact]
        public void Dispose_CalledTwice_DoesNotThrow()
        {
            // Act
            _service.Dispose();
            _service.Dispose();
            // Assert - Should not throw any exception
            Assert.True(true);
        }

        public virtual void Dispose()
        {
            _service?.Dispose();
        }
    }
}