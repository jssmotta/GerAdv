// 100% auto-generated by Source Genesys WebApi Front & Back Creator
// copyright © 2000-2025 Menphis - Sistemas Inteligentes
// This file is part of the Source Genesys project                     
namespace MenphisSI.GerAdv.WFiltro.Tests
{
    public class ContratosServiceWFiltroTests : IDisposable
    {
        private readonly Mock<IOptions<AppSettings>> _mockAppSettings;
        private readonly Mock<IFContratosFactory> _mockContratosFactory;
        private readonly Mock<IContratosReader> _mockReader;
        private readonly Mock<IContratosValidation> _mockValidation;
        private readonly Mock<IContratosWriter> _mockWriter;
        private readonly Mock<IClientesReader> _mockClientesReader;
        private readonly Mock<IAdvogadosReader> _mockAdvogadosReader;
        private readonly Mock<IHttpContextAccessor> _mockHttpContextAccessor;
        private readonly Mock<HybridCache> _mockCache;
        private readonly Mock<IMemoryCache> _mockMemoryCache;
        private readonly ContratosService _service;
        public ContratosServiceWFiltroTests()
        {
            _mockAppSettings = new Mock<IOptions<AppSettings>>();
            _mockContratosFactory = new Mock<IFContratosFactory>();
            _mockReader = new Mock<IContratosReader>();
            _mockValidation = new Mock<IContratosValidation>();
            _mockWriter = new Mock<IContratosWriter>();
            _mockClientesReader = new Mock<IClientesReader>();
            _mockAdvogadosReader = new Mock<IAdvogadosReader>();
            _mockHttpContextAccessor = new Mock<IHttpContextAccessor>();
            _mockCache = new Mock<HybridCache>();
            _mockMemoryCache = new Mock<IMemoryCache>();
            var appSettings = new AppSettings();
            _mockAppSettings.Setup(x => x.Value).Returns(appSettings);
            _service = new ContratosService(_mockAppSettings.Object, _mockContratosFactory.Object, _mockReader.Object, _mockValidation.Object, _mockWriter.Object, _mockClientesReader.Object, _mockAdvogadosReader.Object, _mockHttpContextAccessor.Object, _mockCache.Object, _mockMemoryCache.Object);
        }

        [Fact]
        public void WFiltro_QuandoFiltroEhNull_DeveRetornarResultadoVazio()
        {
            // Arrange
            FilterContratos? filtro = null;
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().BeNull();
        }

        [Fact]
        public void WFiltro_QuandoTodosCamposSaoValoresPadrao_DeveRetornarResultadoVazio()
        {
            // Arrange
            var filtro = new FilterContratos(); // Todos os valores padrão
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_ComTodosOsCamposPreenchidos_DeveProcessarRapidamente()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Processo = 1,
                Cliente = 1,
                Advogado = 1,
                Dia = 1,
                Valor = 0m,
                DataInicio = "24/04/1975",
                DataTermino = "24/04/1975",
                OcultarRelatorio = 2,
                PercEscritorio = 0m,
                ValorConsultoria = 0m,
                TipoCobranca = 1,
                Protestar = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
                Juros = "AAA",
                ValorRealizavel = 0m,
                DOCUMENTO = "AAAAAAAAAAAAA",
                EMail1 = "test@email.com",
                EMail2 = "test@email.com",
                EMail3 = "test@email.com",
                Pessoa1 = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
                Pessoa2 = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
                Pessoa3 = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
                OBS = "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM",
                ClienteContrato = 1,
                IdExtrangeiro = 1,
                ChaveContrato = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
                Avulso = 1,
                Suspenso = 2,
                Multa = "AAAAAAAA",
                GUID = Guid.NewGuid().ToString(),
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var stopwatch = System.Diagnostics.Stopwatch.StartNew();
            var resultado = _service.WFiltro(filtro);
            stopwatch.Stop();
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().NotBeEmpty();
            resultado.Value.where.Should().NotBeEmpty();
            stopwatch.ElapsedMilliseconds.Should().BeLessThan(100); // Deve processar em menos de 100ms
        }

#region String Tests
        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_Protestar_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string protestarComWhitespace)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Protestar = protestarComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_Protestar_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var protestarGigante = new string ('A', 1000);
            var filtro = new FilterContratos
            {
                Protestar = protestarGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{protestarGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_Protestar_ComCaracteresEspeciais_DeveProcessarCorretamente(string protestarComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Protestar = protestarComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(protestarComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_ProtestarContratos_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Protestar = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_ProtestarContratos_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Protestar = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_ProtestarContratos_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeContratos = "João Silva";
            var filtro = new FilterContratos
            {
                Protestar = nomeContratos,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_ProtestarContratos_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Protestar = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_ProtestarContratos_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Protestar = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_ProtestarContratos_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeContratos)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Protestar = nomeContratos,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_ProtestarContratos_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Protestar = "João",
                Cliente = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@cttProtestar");
            resultado.Value.where.Should().Contain("@cttCliente");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @cttProtestar");
            resultado.Value.where.Should().Contain("= @cttCliente");
        }

        [Fact]
        public void WFiltro_ProtestarContratos_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeContratos = "João Silva";
            var filtro = new FilterContratos
            {
                Protestar = nomeContratos,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Protestar}]");
            resultado.Value.where.Should().Contain("like @cttProtestar");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@cttProtestar");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Fact]
        public void WFiltro_JurosContratos_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Juros = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_JurosContratos_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Juros = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_JurosContratos_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeContratos = "João Silva";
            var filtro = new FilterContratos
            {
                Juros = nomeContratos,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_JurosContratos_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Juros = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_JurosContratos_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Juros = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_JurosContratos_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeContratos)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Juros = nomeContratos,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_JurosContratos_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Juros = "João",
                Cliente = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@cttJuros");
            resultado.Value.where.Should().Contain("@cttCliente");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @cttJuros");
            resultado.Value.where.Should().Contain("= @cttCliente");
        }

        [Fact]
        public void WFiltro_JurosContratos_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeContratos = "João Silva";
            var filtro = new FilterContratos
            {
                Juros = nomeContratos,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Juros}]");
            resultado.Value.where.Should().Contain("like @cttJuros");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@cttJuros");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Fact]
        public void WFiltro_DOCUMENTOContratos_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                DOCUMENTO = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_DOCUMENTOContratos_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                DOCUMENTO = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_DOCUMENTOContratos_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeContratos = "João Silva";
            var filtro = new FilterContratos
            {
                DOCUMENTO = nomeContratos,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_DOCUMENTOContratos_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                DOCUMENTO = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_DOCUMENTOContratos_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                DOCUMENTO = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_DOCUMENTOContratos_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeContratos)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                DOCUMENTO = nomeContratos,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DOCUMENTOContratos_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                DOCUMENTO = "João",
                Cliente = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@cttDOCUMENTO");
            resultado.Value.where.Should().Contain("@cttCliente");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @cttDOCUMENTO");
            resultado.Value.where.Should().Contain("= @cttCliente");
        }

        [Fact]
        public void WFiltro_DOCUMENTOContratos_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeContratos = "João Silva";
            var filtro = new FilterContratos
            {
                DOCUMENTO = nomeContratos,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.DOCUMENTO}]");
            resultado.Value.where.Should().Contain("like @cttDOCUMENTO");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@cttDOCUMENTO");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_EMail1_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string email1ComWhitespace)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                EMail1 = email1ComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_EMail1_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var email1Gigante = new string ('A', 1000);
            var filtro = new FilterContratos
            {
                EMail1 = email1Gigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{email1Gigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_EMail1_ComCaracteresEspeciais_DeveProcessarCorretamente(string email1ComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                EMail1 = email1ComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(email1ComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_EMail1Contratos_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                EMail1 = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_EMail1Contratos_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                EMail1 = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_EMail1Contratos_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeContratos = "João Silva";
            var filtro = new FilterContratos
            {
                EMail1 = nomeContratos,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_EMail1Contratos_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                EMail1 = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_EMail1Contratos_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                EMail1 = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_EMail1Contratos_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeContratos)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                EMail1 = nomeContratos,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_EMail1Contratos_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                EMail1 = "João",
                Cliente = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@cttEMail1");
            resultado.Value.where.Should().Contain("@cttCliente");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @cttEMail1");
            resultado.Value.where.Should().Contain("= @cttCliente");
        }

        [Fact]
        public void WFiltro_EMail1Contratos_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeContratos = "João Silva";
            var filtro = new FilterContratos
            {
                EMail1 = nomeContratos,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.EMail1}]");
            resultado.Value.where.Should().Contain("like @cttEMail1");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@cttEMail1");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_EMail2_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string email2ComWhitespace)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                EMail2 = email2ComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_EMail2_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var email2Gigante = new string ('A', 1000);
            var filtro = new FilterContratos
            {
                EMail2 = email2Gigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{email2Gigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_EMail2_ComCaracteresEspeciais_DeveProcessarCorretamente(string email2ComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                EMail2 = email2ComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(email2ComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_EMail2Contratos_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                EMail2 = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_EMail2Contratos_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                EMail2 = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_EMail2Contratos_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeContratos = "João Silva";
            var filtro = new FilterContratos
            {
                EMail2 = nomeContratos,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_EMail2Contratos_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                EMail2 = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_EMail2Contratos_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                EMail2 = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_EMail2Contratos_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeContratos)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                EMail2 = nomeContratos,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_EMail2Contratos_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                EMail2 = "João",
                Cliente = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@cttEMail2");
            resultado.Value.where.Should().Contain("@cttCliente");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @cttEMail2");
            resultado.Value.where.Should().Contain("= @cttCliente");
        }

        [Fact]
        public void WFiltro_EMail2Contratos_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeContratos = "João Silva";
            var filtro = new FilterContratos
            {
                EMail2 = nomeContratos,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.EMail2}]");
            resultado.Value.where.Should().Contain("like @cttEMail2");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@cttEMail2");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_EMail3_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string email3ComWhitespace)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                EMail3 = email3ComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_EMail3_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var email3Gigante = new string ('A', 1000);
            var filtro = new FilterContratos
            {
                EMail3 = email3Gigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{email3Gigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_EMail3_ComCaracteresEspeciais_DeveProcessarCorretamente(string email3ComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                EMail3 = email3ComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(email3ComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_EMail3Contratos_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                EMail3 = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_EMail3Contratos_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                EMail3 = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_EMail3Contratos_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeContratos = "João Silva";
            var filtro = new FilterContratos
            {
                EMail3 = nomeContratos,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_EMail3Contratos_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                EMail3 = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_EMail3Contratos_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                EMail3 = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_EMail3Contratos_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeContratos)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                EMail3 = nomeContratos,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_EMail3Contratos_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                EMail3 = "João",
                Cliente = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@cttEMail3");
            resultado.Value.where.Should().Contain("@cttCliente");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @cttEMail3");
            resultado.Value.where.Should().Contain("= @cttCliente");
        }

        [Fact]
        public void WFiltro_EMail3Contratos_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeContratos = "João Silva";
            var filtro = new FilterContratos
            {
                EMail3 = nomeContratos,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.EMail3}]");
            resultado.Value.where.Should().Contain("like @cttEMail3");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@cttEMail3");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_Pessoa1_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string pessoa1ComWhitespace)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Pessoa1 = pessoa1ComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_Pessoa1_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var pessoa1Gigante = new string ('A', 1000);
            var filtro = new FilterContratos
            {
                Pessoa1 = pessoa1Gigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{pessoa1Gigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_Pessoa1_ComCaracteresEspeciais_DeveProcessarCorretamente(string pessoa1ComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Pessoa1 = pessoa1ComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(pessoa1ComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_Pessoa1Contratos_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Pessoa1 = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Pessoa1Contratos_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Pessoa1 = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Pessoa1Contratos_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeContratos = "João Silva";
            var filtro = new FilterContratos
            {
                Pessoa1 = nomeContratos,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_Pessoa1Contratos_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Pessoa1 = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_Pessoa1Contratos_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Pessoa1 = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_Pessoa1Contratos_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeContratos)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Pessoa1 = nomeContratos,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_Pessoa1Contratos_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Pessoa1 = "João",
                Cliente = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@cttPessoa1");
            resultado.Value.where.Should().Contain("@cttCliente");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @cttPessoa1");
            resultado.Value.where.Should().Contain("= @cttCliente");
        }

        [Fact]
        public void WFiltro_Pessoa1Contratos_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeContratos = "João Silva";
            var filtro = new FilterContratos
            {
                Pessoa1 = nomeContratos,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Pessoa1}]");
            resultado.Value.where.Should().Contain("like @cttPessoa1");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@cttPessoa1");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_Pessoa2_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string pessoa2ComWhitespace)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Pessoa2 = pessoa2ComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_Pessoa2_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var pessoa2Gigante = new string ('A', 1000);
            var filtro = new FilterContratos
            {
                Pessoa2 = pessoa2Gigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{pessoa2Gigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_Pessoa2_ComCaracteresEspeciais_DeveProcessarCorretamente(string pessoa2ComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Pessoa2 = pessoa2ComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(pessoa2ComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_Pessoa2Contratos_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Pessoa2 = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Pessoa2Contratos_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Pessoa2 = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Pessoa2Contratos_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeContratos = "João Silva";
            var filtro = new FilterContratos
            {
                Pessoa2 = nomeContratos,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_Pessoa2Contratos_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Pessoa2 = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_Pessoa2Contratos_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Pessoa2 = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_Pessoa2Contratos_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeContratos)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Pessoa2 = nomeContratos,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_Pessoa2Contratos_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Pessoa2 = "João",
                Cliente = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@cttPessoa2");
            resultado.Value.where.Should().Contain("@cttCliente");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @cttPessoa2");
            resultado.Value.where.Should().Contain("= @cttCliente");
        }

        [Fact]
        public void WFiltro_Pessoa2Contratos_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeContratos = "João Silva";
            var filtro = new FilterContratos
            {
                Pessoa2 = nomeContratos,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Pessoa2}]");
            resultado.Value.where.Should().Contain("like @cttPessoa2");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@cttPessoa2");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_Pessoa3_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string pessoa3ComWhitespace)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Pessoa3 = pessoa3ComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_Pessoa3_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var pessoa3Gigante = new string ('A', 1000);
            var filtro = new FilterContratos
            {
                Pessoa3 = pessoa3Gigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{pessoa3Gigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_Pessoa3_ComCaracteresEspeciais_DeveProcessarCorretamente(string pessoa3ComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Pessoa3 = pessoa3ComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(pessoa3ComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_Pessoa3Contratos_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Pessoa3 = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Pessoa3Contratos_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Pessoa3 = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Pessoa3Contratos_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeContratos = "João Silva";
            var filtro = new FilterContratos
            {
                Pessoa3 = nomeContratos,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_Pessoa3Contratos_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Pessoa3 = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_Pessoa3Contratos_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Pessoa3 = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_Pessoa3Contratos_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeContratos)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Pessoa3 = nomeContratos,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_Pessoa3Contratos_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Pessoa3 = "João",
                Cliente = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@cttPessoa3");
            resultado.Value.where.Should().Contain("@cttCliente");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @cttPessoa3");
            resultado.Value.where.Should().Contain("= @cttCliente");
        }

        [Fact]
        public void WFiltro_Pessoa3Contratos_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeContratos = "João Silva";
            var filtro = new FilterContratos
            {
                Pessoa3 = nomeContratos,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Pessoa3}]");
            resultado.Value.where.Should().Contain("like @cttPessoa3");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@cttPessoa3");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_OBS_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string obsComWhitespace)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                OBS = obsComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_OBS_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var obsGigante = new string ('A', 1000);
            var filtro = new FilterContratos
            {
                OBS = obsGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{obsGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_OBS_ComCaracteresEspeciais_DeveProcessarCorretamente(string obsComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                OBS = obsComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(obsComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_OBSContratos_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                OBS = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_OBSContratos_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                OBS = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_OBSContratos_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeContratos = "João Silva";
            var filtro = new FilterContratos
            {
                OBS = nomeContratos,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_OBSContratos_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                OBS = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_OBSContratos_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                OBS = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_OBSContratos_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeContratos)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                OBS = nomeContratos,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_OBSContratos_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                OBS = "João",
                Cliente = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@cttOBS");
            resultado.Value.where.Should().Contain("@cttCliente");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @cttOBS");
            resultado.Value.where.Should().Contain("= @cttCliente");
        }

        [Fact]
        public void WFiltro_OBSContratos_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeContratos = "João Silva";
            var filtro = new FilterContratos
            {
                OBS = nomeContratos,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.OBS}]");
            resultado.Value.where.Should().Contain("like @cttOBS");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@cttOBS");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_ChaveContrato_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string chavecontratoComWhitespace)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ChaveContrato = chavecontratoComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_ChaveContrato_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var chavecontratoGigante = new string ('A', 1000);
            var filtro = new FilterContratos
            {
                ChaveContrato = chavecontratoGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{chavecontratoGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_ChaveContrato_ComCaracteresEspeciais_DeveProcessarCorretamente(string chavecontratoComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ChaveContrato = chavecontratoComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(chavecontratoComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_ChaveContratoContratos_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ChaveContrato = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_ChaveContratoContratos_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ChaveContrato = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_ChaveContratoContratos_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeContratos = "João Silva";
            var filtro = new FilterContratos
            {
                ChaveContrato = nomeContratos,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_ChaveContratoContratos_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ChaveContrato = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_ChaveContratoContratos_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ChaveContrato = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_ChaveContratoContratos_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeContratos)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ChaveContrato = nomeContratos,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_ChaveContratoContratos_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ChaveContrato = "João",
                Cliente = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@cttChaveContrato");
            resultado.Value.where.Should().Contain("@cttCliente");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @cttChaveContrato");
            resultado.Value.where.Should().Contain("= @cttCliente");
        }

        [Fact]
        public void WFiltro_ChaveContratoContratos_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeContratos = "João Silva";
            var filtro = new FilterContratos
            {
                ChaveContrato = nomeContratos,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.ChaveContrato}]");
            resultado.Value.where.Should().Contain("like @cttChaveContrato");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@cttChaveContrato");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Fact]
        public void WFiltro_MultaContratos_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Multa = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_MultaContratos_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Multa = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_MultaContratos_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeContratos = "João Silva";
            var filtro = new FilterContratos
            {
                Multa = nomeContratos,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_MultaContratos_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Multa = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_MultaContratos_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Multa = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_MultaContratos_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeContratos)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Multa = nomeContratos,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_MultaContratos_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Multa = "João",
                Cliente = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@cttMulta");
            resultado.Value.where.Should().Contain("@cttCliente");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @cttMulta");
            resultado.Value.where.Should().Contain("= @cttCliente");
        }

        [Fact]
        public void WFiltro_MultaContratos_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeContratos = "João Silva";
            var filtro = new FilterContratos
            {
                Multa = nomeContratos,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Multa}]");
            resultado.Value.where.Should().Contain("like @cttMulta");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@cttMulta");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_GUID_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string guidComWhitespace)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                GUID = guidComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_GUID_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var guidGigante = new string ('A', 1000);
            var filtro = new FilterContratos
            {
                GUID = guidGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{guidGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_GUID_ComCaracteresEspeciais_DeveProcessarCorretamente(string guidComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                GUID = guidComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(guidComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_GUIDContratos_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                GUID = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_GUIDContratos_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                GUID = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_GUIDContratos_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeContratos = "João Silva";
            var filtro = new FilterContratos
            {
                GUID = nomeContratos,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_GUIDContratos_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                GUID = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_GUIDContratos_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                GUID = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_GUIDContratos_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeContratos)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                GUID = nomeContratos,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_GUIDContratos_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                GUID = "João",
                Cliente = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@cttGUID");
            resultado.Value.where.Should().Contain("@cttCliente");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @cttGUID");
            resultado.Value.where.Should().Contain("= @cttCliente");
        }

        [Fact]
        public void WFiltro_GUIDContratos_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeContratos = "João Silva";
            var filtro = new FilterContratos
            {
                GUID = nomeContratos,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.GUID}]");
            resultado.Value.where.Should().Contain("like @cttGUID");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@cttGUID");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

#endregion
#region Integer Tests
#region filtro.Processo_end Tests
        [Fact]
        public void WFiltro_Processo_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Processo_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Processo_end_QuandoTemValorPositivo_SemProcessoInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorProcessoEnd = 5000;
            var filtro = new FilterContratos
            {
                Processo = int.MinValue, // Não define salário inicial
                Processo_end = valorProcessoEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Processo inicial válido, não deve incluir condição WHERE, mas o parâmetro Processo_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Processo_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Processo_end_QuandoSomenteValorInicial_SemProcessoEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorProcesso = 2500;
            var filtro = new FilterContratos
            {
                Processo = valorProcesso,
                Processo_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Processo}] = @{DBContratosDicInfo.Processo}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContratosDicInfo.Processo}");
            parametro.Value.Should().Be(valorProcesso);
        }

        [Fact]
        public void WFiltro_Processo_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorProcessoInicial = 1000;
            var valorProcessoFinal = 5000;
            var filtro = new FilterContratos
            {
                Processo = valorProcessoInicial,
                Processo_end = valorProcessoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.Processo} BETWEEN @{DBContratosDicInfo.Processo} AND @{DBContratosDicInfo.Processo}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.Processo}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.Processo}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorProcessoInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorProcessoFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Processo_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Processo = valorInicial,
                Processo_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.Processo}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.Processo}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Processo_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Processo = 1000,
                Processo_end = 5000,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Processo}");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Processo_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Processo = 1000,
                Processo_end = 5000,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Processo_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Processo = 1000,
                Processo_end = 5000,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Processo_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Processo = 1000,
                Processo_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.Processo} BETWEEN");
        }

        [Fact]
        public void WFiltro_Processo_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Processo = 1000,
                Processo_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Processo_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Processo = 1000,
                Processo_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Processo_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorProcessoInicial = 2500;
            var valorProcessoFinal = 4750;
            var filtro = new FilterContratos
            {
                Processo = valorProcessoInicial,
                Processo_end = valorProcessoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.Processo}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.Processo}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorProcessoInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorProcessoFinal);
        }

        [Fact]
        public void WFiltro_Processo_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Processo = 0,
                Processo_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Processo_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Processo = 0,
                Processo_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Processo_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Processo = 1500,
                Processo_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Processo == int.MinValue) && !(filtro.Processo_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.Processo} BETWEEN @{DBContratosDicInfo.Processo} AND @{DBContratosDicInfo.Processo}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Processo_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Processo = 2000,
                Processo_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Processo == int.MinValue) && filtro.Processo_end == int.MinValue
            // Deve resultar em igualdade quando apenas Processo tem valor válido
            resultado.Value.where.Should().Be($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Processo}] = @{DBContratosDicInfo.Processo}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Processo_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Processo = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Processo Isolated Tests
        [Fact]
        public void WFiltro_Processo_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Processo = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Processo_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorProcesso = 5;
            var filtro = new FilterContratos
            {
                Processo = valorProcesso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Processo}] = @{DBContratosDicInfo.Processo}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContratosDicInfo.Processo}");
            parametro.Value.Should().Be(valorProcesso);
        }

        [Fact]
        public void WFiltro_Processo_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorProcesso = 0;
            var filtro = new FilterContratos
            {
                Processo = valorProcesso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBContratosDicInfo.Processo}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorProcesso);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Processo_DiferentesValoresValidos_DeveProcessarCorretamente(int valorProcesso)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Processo = valorProcesso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorProcesso);
            resultado.Value.where.Should().Contain($"= @{DBContratosDicInfo.Processo}");
        }

        [Fact]
        public void WFiltro_Processo_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Processo = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Processo}");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Processo_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Processo = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Processo_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Processo = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Processo_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Processo = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Processo_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Processo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Processo}]");
        }

        [Fact]
        public void WFiltro_Processo_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Processo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Processo_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Processo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Processo_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Processo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Processo_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorProcesso = 42;
            var filtro = new FilterContratos
            {
                Processo = valorProcesso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorProcesso);
        }

#endregion
        [Fact]
        public void WFiltro_Processo_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Processo = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Processo_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorProcesso = 1;
            var filtro = new FilterContratos
            {
                Processo = valorProcesso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Processo
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Processo}] = @cttProcesso");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@cttProcesso");
            parametro.Value.Should().Be(valorProcesso);
        }

        [Fact]
        public void WFiltro_Processo_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Processo = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@cttProcesso");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Processo_DiferentesValores_DeveFuncionar(int valorProcesso)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Processo = valorProcesso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorProcesso);
        }

#region filtro.Cliente_end Tests
        [Fact]
        public void WFiltro_Cliente_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Cliente_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Cliente_end_QuandoTemValorPositivo_SemClienteInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorClienteEnd = 5000;
            var filtro = new FilterContratos
            {
                Cliente = int.MinValue, // Não define salário inicial
                Cliente_end = valorClienteEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Cliente inicial válido, não deve incluir condição WHERE, mas o parâmetro Cliente_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Cliente_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Cliente_end_QuandoSomenteValorInicial_SemClienteEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorCliente = 2500;
            var filtro = new FilterContratos
            {
                Cliente = valorCliente,
                Cliente_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Cliente}] = @{DBContratosDicInfo.Cliente}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContratosDicInfo.Cliente}");
            parametro.Value.Should().Be(valorCliente);
        }

        [Fact]
        public void WFiltro_Cliente_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorClienteInicial = 1000;
            var valorClienteFinal = 5000;
            var filtro = new FilterContratos
            {
                Cliente = valorClienteInicial,
                Cliente_end = valorClienteFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.Cliente} BETWEEN @{DBContratosDicInfo.Cliente} AND @{DBContratosDicInfo.Cliente}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.Cliente}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.Cliente}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorClienteInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorClienteFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Cliente_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Cliente = valorInicial,
                Cliente_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.Cliente}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.Cliente}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Cliente_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Cliente = 1000,
                Cliente_end = 5000,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Cliente}");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Cliente_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Cliente = 1000,
                Cliente_end = 5000,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Cliente_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Cliente = 1000,
                Cliente_end = 5000,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Cliente_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Cliente = 1000,
                Cliente_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.Cliente} BETWEEN");
        }

        [Fact]
        public void WFiltro_Cliente_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Cliente = 1000,
                Cliente_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Cliente_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Cliente = 1000,
                Cliente_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Cliente_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorClienteInicial = 2500;
            var valorClienteFinal = 4750;
            var filtro = new FilterContratos
            {
                Cliente = valorClienteInicial,
                Cliente_end = valorClienteFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.Cliente}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.Cliente}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorClienteInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorClienteFinal);
        }

        [Fact]
        public void WFiltro_Cliente_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Cliente = 0,
                Cliente_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Cliente_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Cliente = 0,
                Cliente_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Cliente_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Cliente = 1500,
                Cliente_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Cliente == int.MinValue) && !(filtro.Cliente_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.Cliente} BETWEEN @{DBContratosDicInfo.Cliente} AND @{DBContratosDicInfo.Cliente}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Cliente_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Cliente = 2000,
                Cliente_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Cliente == int.MinValue) && filtro.Cliente_end == int.MinValue
            // Deve resultar em igualdade quando apenas Cliente tem valor válido
            resultado.Value.where.Should().Be($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Cliente}] = @{DBContratosDicInfo.Cliente}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Cliente_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Cliente = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Cliente Isolated Tests
        [Fact]
        public void WFiltro_Cliente_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Cliente = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Cliente_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorCliente = 5;
            var filtro = new FilterContratos
            {
                Cliente = valorCliente,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Cliente}] = @{DBContratosDicInfo.Cliente}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContratosDicInfo.Cliente}");
            parametro.Value.Should().Be(valorCliente);
        }

        [Fact]
        public void WFiltro_Cliente_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorCliente = 0;
            var filtro = new FilterContratos
            {
                Cliente = valorCliente,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBContratosDicInfo.Cliente}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCliente);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Cliente_DiferentesValoresValidos_DeveProcessarCorretamente(int valorCliente)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Cliente = valorCliente,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCliente);
            resultado.Value.where.Should().Contain($"= @{DBContratosDicInfo.Cliente}");
        }

        [Fact]
        public void WFiltro_Cliente_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Cliente = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Cliente}");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Cliente_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Cliente = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Cliente_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Cliente = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Cliente_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Cliente = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Cliente_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Cliente = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Cliente}]");
        }

        [Fact]
        public void WFiltro_Cliente_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Cliente = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Cliente_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Cliente = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Cliente_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Cliente = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Cliente_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorCliente = 42;
            var filtro = new FilterContratos
            {
                Cliente = valorCliente,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorCliente);
        }

#endregion
        [Fact]
        public void WFiltro_Cliente_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Cliente = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Cliente_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorCliente = 1;
            var filtro = new FilterContratos
            {
                Cliente = valorCliente,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Cliente
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Cliente}] = @cttCliente");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@cttCliente");
            parametro.Value.Should().Be(valorCliente);
        }

        [Fact]
        public void WFiltro_Cliente_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Cliente = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@cttCliente");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Cliente_DiferentesValores_DeveFuncionar(int valorCliente)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Cliente = valorCliente,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCliente);
        }

#region filtro.Advogado_end Tests
        [Fact]
        public void WFiltro_Advogado_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Advogado_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Advogado_end_QuandoTemValorPositivo_SemAdvogadoInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorAdvogadoEnd = 5000;
            var filtro = new FilterContratos
            {
                Advogado = int.MinValue, // Não define salário inicial
                Advogado_end = valorAdvogadoEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Advogado inicial válido, não deve incluir condição WHERE, mas o parâmetro Advogado_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Advogado_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Advogado_end_QuandoSomenteValorInicial_SemAdvogadoEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorAdvogado = 2500;
            var filtro = new FilterContratos
            {
                Advogado = valorAdvogado,
                Advogado_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Advogado}] = @{DBContratosDicInfo.Advogado}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContratosDicInfo.Advogado}");
            parametro.Value.Should().Be(valorAdvogado);
        }

        [Fact]
        public void WFiltro_Advogado_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorAdvogadoInicial = 1000;
            var valorAdvogadoFinal = 5000;
            var filtro = new FilterContratos
            {
                Advogado = valorAdvogadoInicial,
                Advogado_end = valorAdvogadoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.Advogado} BETWEEN @{DBContratosDicInfo.Advogado} AND @{DBContratosDicInfo.Advogado}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.Advogado}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.Advogado}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorAdvogadoInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorAdvogadoFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Advogado_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Advogado = valorInicial,
                Advogado_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.Advogado}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.Advogado}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Advogado_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Advogado = 1000,
                Advogado_end = 5000,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Advogado}");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Advogado_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Advogado = 1000,
                Advogado_end = 5000,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Advogado_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Advogado = 1000,
                Advogado_end = 5000,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Advogado_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Advogado = 1000,
                Advogado_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.Advogado} BETWEEN");
        }

        [Fact]
        public void WFiltro_Advogado_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Advogado = 1000,
                Advogado_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Advogado_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Advogado = 1000,
                Advogado_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Advogado_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorAdvogadoInicial = 2500;
            var valorAdvogadoFinal = 4750;
            var filtro = new FilterContratos
            {
                Advogado = valorAdvogadoInicial,
                Advogado_end = valorAdvogadoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.Advogado}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.Advogado}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorAdvogadoInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorAdvogadoFinal);
        }

        [Fact]
        public void WFiltro_Advogado_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Advogado = 0,
                Advogado_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Advogado_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Advogado = 0,
                Advogado_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Advogado_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Advogado = 1500,
                Advogado_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Advogado == int.MinValue) && !(filtro.Advogado_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.Advogado} BETWEEN @{DBContratosDicInfo.Advogado} AND @{DBContratosDicInfo.Advogado}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Advogado_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Advogado = 2000,
                Advogado_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Advogado == int.MinValue) && filtro.Advogado_end == int.MinValue
            // Deve resultar em igualdade quando apenas Advogado tem valor válido
            resultado.Value.where.Should().Be($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Advogado}] = @{DBContratosDicInfo.Advogado}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Advogado_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Advogado = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Advogado Isolated Tests
        [Fact]
        public void WFiltro_Advogado_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Advogado = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Advogado_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorAdvogado = 5;
            var filtro = new FilterContratos
            {
                Advogado = valorAdvogado,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Advogado}] = @{DBContratosDicInfo.Advogado}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContratosDicInfo.Advogado}");
            parametro.Value.Should().Be(valorAdvogado);
        }

        [Fact]
        public void WFiltro_Advogado_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorAdvogado = 0;
            var filtro = new FilterContratos
            {
                Advogado = valorAdvogado,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBContratosDicInfo.Advogado}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorAdvogado);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Advogado_DiferentesValoresValidos_DeveProcessarCorretamente(int valorAdvogado)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Advogado = valorAdvogado,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorAdvogado);
            resultado.Value.where.Should().Contain($"= @{DBContratosDicInfo.Advogado}");
        }

        [Fact]
        public void WFiltro_Advogado_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Advogado = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Advogado}");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Advogado_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Advogado = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Advogado_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Advogado = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Advogado_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Advogado = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Advogado_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Advogado = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Advogado}]");
        }

        [Fact]
        public void WFiltro_Advogado_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Advogado = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Advogado_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Advogado = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Advogado_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Advogado = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Advogado_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorAdvogado = 42;
            var filtro = new FilterContratos
            {
                Advogado = valorAdvogado,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorAdvogado);
        }

#endregion
        [Fact]
        public void WFiltro_Advogado_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Advogado = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Advogado_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorAdvogado = 1;
            var filtro = new FilterContratos
            {
                Advogado = valorAdvogado,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Advogado
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Advogado}] = @cttAdvogado");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@cttAdvogado");
            parametro.Value.Should().Be(valorAdvogado);
        }

        [Fact]
        public void WFiltro_Advogado_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Advogado = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@cttAdvogado");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Advogado_DiferentesValores_DeveFuncionar(int valorAdvogado)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Advogado = valorAdvogado,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorAdvogado);
        }

#region filtro.Dia_end Tests
        [Fact]
        public void WFiltro_Dia_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Dia_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Dia_end_QuandoTemValorPositivo_SemDiaInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorDiaEnd = 5000;
            var filtro = new FilterContratos
            {
                Dia = int.MinValue, // Não define salário inicial
                Dia_end = valorDiaEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Dia inicial válido, não deve incluir condição WHERE, mas o parâmetro Dia_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Dia_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Dia_end_QuandoSomenteValorInicial_SemDiaEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorDia = 2500;
            var filtro = new FilterContratos
            {
                Dia = valorDia,
                Dia_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Dia}] = @{DBContratosDicInfo.Dia}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContratosDicInfo.Dia}");
            parametro.Value.Should().Be(valorDia);
        }

        [Fact]
        public void WFiltro_Dia_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorDiaInicial = 1000;
            var valorDiaFinal = 5000;
            var filtro = new FilterContratos
            {
                Dia = valorDiaInicial,
                Dia_end = valorDiaFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.Dia} BETWEEN @{DBContratosDicInfo.Dia} AND @{DBContratosDicInfo.Dia}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.Dia}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.Dia}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorDiaInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorDiaFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Dia_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Dia = valorInicial,
                Dia_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.Dia}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.Dia}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Dia_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Dia = 1000,
                Dia_end = 5000,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Dia}");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Dia_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Dia = 1000,
                Dia_end = 5000,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Dia_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Dia = 1000,
                Dia_end = 5000,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Dia_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Dia = 1000,
                Dia_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.Dia} BETWEEN");
        }

        [Fact]
        public void WFiltro_Dia_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Dia = 1000,
                Dia_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Dia_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Dia = 1000,
                Dia_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Dia_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorDiaInicial = 2500;
            var valorDiaFinal = 4750;
            var filtro = new FilterContratos
            {
                Dia = valorDiaInicial,
                Dia_end = valorDiaFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.Dia}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.Dia}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorDiaInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorDiaFinal);
        }

        [Fact]
        public void WFiltro_Dia_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Dia = 0,
                Dia_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Dia_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Dia = 0,
                Dia_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Dia_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Dia = 1500,
                Dia_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Dia == int.MinValue) && !(filtro.Dia_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.Dia} BETWEEN @{DBContratosDicInfo.Dia} AND @{DBContratosDicInfo.Dia}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Dia_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Dia = 2000,
                Dia_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Dia == int.MinValue) && filtro.Dia_end == int.MinValue
            // Deve resultar em igualdade quando apenas Dia tem valor válido
            resultado.Value.where.Should().Be($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Dia}] = @{DBContratosDicInfo.Dia}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Dia_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Dia = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Dia Isolated Tests
        [Fact]
        public void WFiltro_Dia_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Dia = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Dia_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorDia = 5;
            var filtro = new FilterContratos
            {
                Dia = valorDia,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Dia}] = @{DBContratosDicInfo.Dia}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContratosDicInfo.Dia}");
            parametro.Value.Should().Be(valorDia);
        }

        [Fact]
        public void WFiltro_Dia_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorDia = 0;
            var filtro = new FilterContratos
            {
                Dia = valorDia,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBContratosDicInfo.Dia}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorDia);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Dia_DiferentesValoresValidos_DeveProcessarCorretamente(int valorDia)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Dia = valorDia,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorDia);
            resultado.Value.where.Should().Contain($"= @{DBContratosDicInfo.Dia}");
        }

        [Fact]
        public void WFiltro_Dia_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Dia = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Dia}");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Dia_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Dia = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Dia_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Dia = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Dia_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Dia = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Dia_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Dia = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Dia}]");
        }

        [Fact]
        public void WFiltro_Dia_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Dia = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Dia_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Dia = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Dia_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Dia = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Dia_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorDia = 42;
            var filtro = new FilterContratos
            {
                Dia = valorDia,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorDia);
        }

#endregion
        [Fact]
        public void WFiltro_Dia_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Dia = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Dia_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorDia = 1;
            var filtro = new FilterContratos
            {
                Dia = valorDia,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Dia
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Dia}] = @cttDia");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@cttDia");
            parametro.Value.Should().Be(valorDia);
        }

        [Fact]
        public void WFiltro_Dia_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Dia = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@cttDia");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Dia_DiferentesValores_DeveFuncionar(int valorDia)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Dia = valorDia,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorDia);
        }

#region filtro.TipoCobranca_end Tests
        [Fact]
        public void WFiltro_TipoCobranca_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                TipoCobranca_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_TipoCobranca_end_QuandoTemValorPositivo_SemTipoCobrancaInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorTipoCobrancaEnd = 5000;
            var filtro = new FilterContratos
            {
                TipoCobranca = int.MinValue, // Não define salário inicial
                TipoCobranca_end = valorTipoCobrancaEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há TipoCobranca inicial válido, não deve incluir condição WHERE, mas o parâmetro TipoCobranca_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // TipoCobranca_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_TipoCobranca_end_QuandoSomenteValorInicial_SemTipoCobrancaEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorTipoCobranca = 2500;
            var filtro = new FilterContratos
            {
                TipoCobranca = valorTipoCobranca,
                TipoCobranca_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.TipoCobranca}] = @{DBContratosDicInfo.TipoCobranca}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContratosDicInfo.TipoCobranca}");
            parametro.Value.Should().Be(valorTipoCobranca);
        }

        [Fact]
        public void WFiltro_TipoCobranca_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorTipoCobrancaInicial = 1000;
            var valorTipoCobrancaFinal = 5000;
            var filtro = new FilterContratos
            {
                TipoCobranca = valorTipoCobrancaInicial,
                TipoCobranca_end = valorTipoCobrancaFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.TipoCobranca} BETWEEN @{DBContratosDicInfo.TipoCobranca} AND @{DBContratosDicInfo.TipoCobranca}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.TipoCobranca}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.TipoCobranca}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorTipoCobrancaInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorTipoCobrancaFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_TipoCobranca_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                TipoCobranca = valorInicial,
                TipoCobranca_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.TipoCobranca}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.TipoCobranca}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_TipoCobranca_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                TipoCobranca = 1000,
                TipoCobranca_end = 5000,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.TipoCobranca}");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_TipoCobranca_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                TipoCobranca = 1000,
                TipoCobranca_end = 5000,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_TipoCobranca_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                TipoCobranca = 1000,
                TipoCobranca_end = 5000,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_TipoCobranca_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                TipoCobranca = 1000,
                TipoCobranca_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.TipoCobranca} BETWEEN");
        }

        [Fact]
        public void WFiltro_TipoCobranca_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                TipoCobranca = 1000,
                TipoCobranca_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_TipoCobranca_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                TipoCobranca = 1000,
                TipoCobranca_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_TipoCobranca_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorTipoCobrancaInicial = 2500;
            var valorTipoCobrancaFinal = 4750;
            var filtro = new FilterContratos
            {
                TipoCobranca = valorTipoCobrancaInicial,
                TipoCobranca_end = valorTipoCobrancaFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.TipoCobranca}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.TipoCobranca}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorTipoCobrancaInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorTipoCobrancaFinal);
        }

        [Fact]
        public void WFiltro_TipoCobranca_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                TipoCobranca = 0,
                TipoCobranca_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_TipoCobranca_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                TipoCobranca = 0,
                TipoCobranca_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_TipoCobranca_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                TipoCobranca = 1500,
                TipoCobranca_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.TipoCobranca == int.MinValue) && !(filtro.TipoCobranca_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.TipoCobranca} BETWEEN @{DBContratosDicInfo.TipoCobranca} AND @{DBContratosDicInfo.TipoCobranca}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_TipoCobranca_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                TipoCobranca = 2000,
                TipoCobranca_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.TipoCobranca == int.MinValue) && filtro.TipoCobranca_end == int.MinValue
            // Deve resultar em igualdade quando apenas TipoCobranca tem valor válido
            resultado.Value.where.Should().Be($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.TipoCobranca}] = @{DBContratosDicInfo.TipoCobranca}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_TipoCobranca_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                TipoCobranca = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.TipoCobranca Isolated Tests
        [Fact]
        public void WFiltro_TipoCobranca_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                TipoCobranca = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_TipoCobranca_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorTipoCobranca = 5;
            var filtro = new FilterContratos
            {
                TipoCobranca = valorTipoCobranca,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.TipoCobranca}] = @{DBContratosDicInfo.TipoCobranca}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContratosDicInfo.TipoCobranca}");
            parametro.Value.Should().Be(valorTipoCobranca);
        }

        [Fact]
        public void WFiltro_TipoCobranca_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorTipoCobranca = 0;
            var filtro = new FilterContratos
            {
                TipoCobranca = valorTipoCobranca,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBContratosDicInfo.TipoCobranca}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorTipoCobranca);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_TipoCobranca_DiferentesValoresValidos_DeveProcessarCorretamente(int valorTipoCobranca)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                TipoCobranca = valorTipoCobranca,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorTipoCobranca);
            resultado.Value.where.Should().Contain($"= @{DBContratosDicInfo.TipoCobranca}");
        }

        [Fact]
        public void WFiltro_TipoCobranca_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                TipoCobranca = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.TipoCobranca}");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_TipoCobranca_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                TipoCobranca = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_TipoCobranca_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                TipoCobranca = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_TipoCobranca_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                TipoCobranca = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_TipoCobranca_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                TipoCobranca = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.TipoCobranca}]");
        }

        [Fact]
        public void WFiltro_TipoCobranca_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                TipoCobranca = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_TipoCobranca_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                TipoCobranca = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_TipoCobranca_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                TipoCobranca = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_TipoCobranca_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorTipoCobranca = 42;
            var filtro = new FilterContratos
            {
                TipoCobranca = valorTipoCobranca,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorTipoCobranca);
        }

#endregion
        [Fact]
        public void WFiltro_TipoCobranca_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                TipoCobranca = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_TipoCobranca_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorTipoCobranca = 1;
            var filtro = new FilterContratos
            {
                TipoCobranca = valorTipoCobranca,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do TipoCobranca
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.TipoCobranca}] = @cttTipoCobranca");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@cttTipoCobranca");
            parametro.Value.Should().Be(valorTipoCobranca);
        }

        [Fact]
        public void WFiltro_TipoCobranca_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                TipoCobranca = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@cttTipoCobranca");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_TipoCobranca_DiferentesValores_DeveFuncionar(int valorTipoCobranca)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                TipoCobranca = valorTipoCobranca,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorTipoCobranca);
        }

#region filtro.ClienteContrato_end Tests
        [Fact]
        public void WFiltro_ClienteContrato_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ClienteContrato_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_ClienteContrato_end_QuandoTemValorPositivo_SemClienteContratoInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorClienteContratoEnd = 5000;
            var filtro = new FilterContratos
            {
                ClienteContrato = int.MinValue, // Não define salário inicial
                ClienteContrato_end = valorClienteContratoEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há ClienteContrato inicial válido, não deve incluir condição WHERE, mas o parâmetro ClienteContrato_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // ClienteContrato_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_ClienteContrato_end_QuandoSomenteValorInicial_SemClienteContratoEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorClienteContrato = 2500;
            var filtro = new FilterContratos
            {
                ClienteContrato = valorClienteContrato,
                ClienteContrato_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.ClienteContrato}] = @{DBContratosDicInfo.ClienteContrato}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContratosDicInfo.ClienteContrato}");
            parametro.Value.Should().Be(valorClienteContrato);
        }

        [Fact]
        public void WFiltro_ClienteContrato_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorClienteContratoInicial = 1000;
            var valorClienteContratoFinal = 5000;
            var filtro = new FilterContratos
            {
                ClienteContrato = valorClienteContratoInicial,
                ClienteContrato_end = valorClienteContratoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.ClienteContrato} BETWEEN @{DBContratosDicInfo.ClienteContrato} AND @{DBContratosDicInfo.ClienteContrato}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.ClienteContrato}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.ClienteContrato}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorClienteContratoInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorClienteContratoFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_ClienteContrato_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ClienteContrato = valorInicial,
                ClienteContrato_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.ClienteContrato}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.ClienteContrato}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_ClienteContrato_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ClienteContrato = 1000,
                ClienteContrato_end = 5000,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.ClienteContrato}");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_ClienteContrato_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ClienteContrato = 1000,
                ClienteContrato_end = 5000,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_ClienteContrato_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ClienteContrato = 1000,
                ClienteContrato_end = 5000,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_ClienteContrato_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ClienteContrato = 1000,
                ClienteContrato_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.ClienteContrato} BETWEEN");
        }

        [Fact]
        public void WFiltro_ClienteContrato_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ClienteContrato = 1000,
                ClienteContrato_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_ClienteContrato_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ClienteContrato = 1000,
                ClienteContrato_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_ClienteContrato_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorClienteContratoInicial = 2500;
            var valorClienteContratoFinal = 4750;
            var filtro = new FilterContratos
            {
                ClienteContrato = valorClienteContratoInicial,
                ClienteContrato_end = valorClienteContratoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.ClienteContrato}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.ClienteContrato}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorClienteContratoInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorClienteContratoFinal);
        }

        [Fact]
        public void WFiltro_ClienteContrato_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ClienteContrato = 0,
                ClienteContrato_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_ClienteContrato_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ClienteContrato = 0,
                ClienteContrato_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_ClienteContrato_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ClienteContrato = 1500,
                ClienteContrato_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.ClienteContrato == int.MinValue) && !(filtro.ClienteContrato_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.ClienteContrato} BETWEEN @{DBContratosDicInfo.ClienteContrato} AND @{DBContratosDicInfo.ClienteContrato}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_ClienteContrato_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ClienteContrato = 2000,
                ClienteContrato_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.ClienteContrato == int.MinValue) && filtro.ClienteContrato_end == int.MinValue
            // Deve resultar em igualdade quando apenas ClienteContrato tem valor válido
            resultado.Value.where.Should().Be($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.ClienteContrato}] = @{DBContratosDicInfo.ClienteContrato}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_ClienteContrato_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ClienteContrato = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.ClienteContrato Isolated Tests
        [Fact]
        public void WFiltro_ClienteContrato_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ClienteContrato = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_ClienteContrato_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorClienteContrato = 5;
            var filtro = new FilterContratos
            {
                ClienteContrato = valorClienteContrato,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.ClienteContrato}] = @{DBContratosDicInfo.ClienteContrato}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContratosDicInfo.ClienteContrato}");
            parametro.Value.Should().Be(valorClienteContrato);
        }

        [Fact]
        public void WFiltro_ClienteContrato_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorClienteContrato = 0;
            var filtro = new FilterContratos
            {
                ClienteContrato = valorClienteContrato,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBContratosDicInfo.ClienteContrato}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorClienteContrato);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_ClienteContrato_DiferentesValoresValidos_DeveProcessarCorretamente(int valorClienteContrato)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ClienteContrato = valorClienteContrato,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorClienteContrato);
            resultado.Value.where.Should().Contain($"= @{DBContratosDicInfo.ClienteContrato}");
        }

        [Fact]
        public void WFiltro_ClienteContrato_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ClienteContrato = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.ClienteContrato}");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_ClienteContrato_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ClienteContrato = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_ClienteContrato_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ClienteContrato = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_ClienteContrato_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ClienteContrato = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_ClienteContrato_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ClienteContrato = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.ClienteContrato}]");
        }

        [Fact]
        public void WFiltro_ClienteContrato_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ClienteContrato = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_ClienteContrato_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ClienteContrato = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_ClienteContrato_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ClienteContrato = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_ClienteContrato_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorClienteContrato = 42;
            var filtro = new FilterContratos
            {
                ClienteContrato = valorClienteContrato,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorClienteContrato);
        }

#endregion
        [Fact]
        public void WFiltro_ClienteContrato_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ClienteContrato = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_ClienteContrato_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorClienteContrato = 1;
            var filtro = new FilterContratos
            {
                ClienteContrato = valorClienteContrato,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do ClienteContrato
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.ClienteContrato}] = @cttClienteContrato");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@cttClienteContrato");
            parametro.Value.Should().Be(valorClienteContrato);
        }

        [Fact]
        public void WFiltro_ClienteContrato_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ClienteContrato = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@cttClienteContrato");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_ClienteContrato_DiferentesValores_DeveFuncionar(int valorClienteContrato)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ClienteContrato = valorClienteContrato,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorClienteContrato);
        }

#region filtro.IdExtrangeiro_end Tests
        [Fact]
        public void WFiltro_IdExtrangeiro_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                IdExtrangeiro_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_IdExtrangeiro_end_QuandoTemValorPositivo_SemIdExtrangeiroInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorIdExtrangeiroEnd = 5000;
            var filtro = new FilterContratos
            {
                IdExtrangeiro = int.MinValue, // Não define salário inicial
                IdExtrangeiro_end = valorIdExtrangeiroEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há IdExtrangeiro inicial válido, não deve incluir condição WHERE, mas o parâmetro IdExtrangeiro_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // IdExtrangeiro_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_IdExtrangeiro_end_QuandoSomenteValorInicial_SemIdExtrangeiroEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorIdExtrangeiro = 2500;
            var filtro = new FilterContratos
            {
                IdExtrangeiro = valorIdExtrangeiro,
                IdExtrangeiro_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.IdExtrangeiro}] = @{DBContratosDicInfo.IdExtrangeiro}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContratosDicInfo.IdExtrangeiro}");
            parametro.Value.Should().Be(valorIdExtrangeiro);
        }

        [Fact]
        public void WFiltro_IdExtrangeiro_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorIdExtrangeiroInicial = 1000;
            var valorIdExtrangeiroFinal = 5000;
            var filtro = new FilterContratos
            {
                IdExtrangeiro = valorIdExtrangeiroInicial,
                IdExtrangeiro_end = valorIdExtrangeiroFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.IdExtrangeiro} BETWEEN @{DBContratosDicInfo.IdExtrangeiro} AND @{DBContratosDicInfo.IdExtrangeiro}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.IdExtrangeiro}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.IdExtrangeiro}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorIdExtrangeiroInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorIdExtrangeiroFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_IdExtrangeiro_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                IdExtrangeiro = valorInicial,
                IdExtrangeiro_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.IdExtrangeiro}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.IdExtrangeiro}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_IdExtrangeiro_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                IdExtrangeiro = 1000,
                IdExtrangeiro_end = 5000,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.IdExtrangeiro}");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_IdExtrangeiro_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                IdExtrangeiro = 1000,
                IdExtrangeiro_end = 5000,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_IdExtrangeiro_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                IdExtrangeiro = 1000,
                IdExtrangeiro_end = 5000,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_IdExtrangeiro_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                IdExtrangeiro = 1000,
                IdExtrangeiro_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.IdExtrangeiro} BETWEEN");
        }

        [Fact]
        public void WFiltro_IdExtrangeiro_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                IdExtrangeiro = 1000,
                IdExtrangeiro_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_IdExtrangeiro_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                IdExtrangeiro = 1000,
                IdExtrangeiro_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_IdExtrangeiro_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorIdExtrangeiroInicial = 2500;
            var valorIdExtrangeiroFinal = 4750;
            var filtro = new FilterContratos
            {
                IdExtrangeiro = valorIdExtrangeiroInicial,
                IdExtrangeiro_end = valorIdExtrangeiroFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.IdExtrangeiro}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.IdExtrangeiro}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorIdExtrangeiroInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorIdExtrangeiroFinal);
        }

        [Fact]
        public void WFiltro_IdExtrangeiro_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                IdExtrangeiro = 0,
                IdExtrangeiro_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_IdExtrangeiro_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                IdExtrangeiro = 0,
                IdExtrangeiro_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_IdExtrangeiro_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                IdExtrangeiro = 1500,
                IdExtrangeiro_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.IdExtrangeiro == int.MinValue) && !(filtro.IdExtrangeiro_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.IdExtrangeiro} BETWEEN @{DBContratosDicInfo.IdExtrangeiro} AND @{DBContratosDicInfo.IdExtrangeiro}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_IdExtrangeiro_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                IdExtrangeiro = 2000,
                IdExtrangeiro_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.IdExtrangeiro == int.MinValue) && filtro.IdExtrangeiro_end == int.MinValue
            // Deve resultar em igualdade quando apenas IdExtrangeiro tem valor válido
            resultado.Value.where.Should().Be($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.IdExtrangeiro}] = @{DBContratosDicInfo.IdExtrangeiro}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_IdExtrangeiro_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                IdExtrangeiro = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.IdExtrangeiro Isolated Tests
        [Fact]
        public void WFiltro_IdExtrangeiro_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                IdExtrangeiro = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_IdExtrangeiro_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorIdExtrangeiro = 5;
            var filtro = new FilterContratos
            {
                IdExtrangeiro = valorIdExtrangeiro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.IdExtrangeiro}] = @{DBContratosDicInfo.IdExtrangeiro}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContratosDicInfo.IdExtrangeiro}");
            parametro.Value.Should().Be(valorIdExtrangeiro);
        }

        [Fact]
        public void WFiltro_IdExtrangeiro_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorIdExtrangeiro = 0;
            var filtro = new FilterContratos
            {
                IdExtrangeiro = valorIdExtrangeiro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBContratosDicInfo.IdExtrangeiro}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorIdExtrangeiro);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_IdExtrangeiro_DiferentesValoresValidos_DeveProcessarCorretamente(int valorIdExtrangeiro)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                IdExtrangeiro = valorIdExtrangeiro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorIdExtrangeiro);
            resultado.Value.where.Should().Contain($"= @{DBContratosDicInfo.IdExtrangeiro}");
        }

        [Fact]
        public void WFiltro_IdExtrangeiro_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                IdExtrangeiro = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.IdExtrangeiro}");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_IdExtrangeiro_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                IdExtrangeiro = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_IdExtrangeiro_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                IdExtrangeiro = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_IdExtrangeiro_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                IdExtrangeiro = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_IdExtrangeiro_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                IdExtrangeiro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.IdExtrangeiro}]");
        }

        [Fact]
        public void WFiltro_IdExtrangeiro_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                IdExtrangeiro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_IdExtrangeiro_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                IdExtrangeiro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_IdExtrangeiro_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                IdExtrangeiro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_IdExtrangeiro_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorIdExtrangeiro = 42;
            var filtro = new FilterContratos
            {
                IdExtrangeiro = valorIdExtrangeiro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorIdExtrangeiro);
        }

#endregion
        [Fact]
        public void WFiltro_IdExtrangeiro_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                IdExtrangeiro = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_IdExtrangeiro_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorIdExtrangeiro = 1;
            var filtro = new FilterContratos
            {
                IdExtrangeiro = valorIdExtrangeiro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do IdExtrangeiro
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.IdExtrangeiro}] = @cttIdExtrangeiro");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@cttIdExtrangeiro");
            parametro.Value.Should().Be(valorIdExtrangeiro);
        }

        [Fact]
        public void WFiltro_IdExtrangeiro_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                IdExtrangeiro = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@cttIdExtrangeiro");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_IdExtrangeiro_DiferentesValores_DeveFuncionar(int valorIdExtrangeiro)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                IdExtrangeiro = valorIdExtrangeiro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorIdExtrangeiro);
        }

#region filtro.Codigo_filtro_end Tests
        [Fact]
        public void WFiltro_Codigo_filtro_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Codigo_filtro_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Codigo_filtro_end_QuandoTemValorPositivo_SemCodigo_filtroInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorCodigo_filtroEnd = 5000;
            var filtro = new FilterContratos
            {
                Codigo_filtro = int.MinValue, // Não define salário inicial
                Codigo_filtro_end = valorCodigo_filtroEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Codigo_filtro inicial válido, não deve incluir condição WHERE, mas o parâmetro Codigo_filtro_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Codigo_filtro_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Codigo_filtro_end_QuandoSomenteValorInicial_SemCodigo_filtroEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorCodigo_filtro = 2500;
            var filtro = new FilterContratos
            {
                Codigo_filtro = valorCodigo_filtro,
                Codigo_filtro_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.CampoCodigo}] = @{DBContratosDicInfo.CampoCodigo}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContratosDicInfo.CampoCodigo}");
            parametro.Value.Should().Be(valorCodigo_filtro);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorCodigo_filtroInicial = 1000;
            var valorCodigo_filtroFinal = 5000;
            var filtro = new FilterContratos
            {
                Codigo_filtro = valorCodigo_filtroInicial,
                Codigo_filtro_end = valorCodigo_filtroFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.CampoCodigo} BETWEEN @{DBContratosDicInfo.CampoCodigo} AND @{DBContratosDicInfo.CampoCodigo}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.CampoCodigo}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.CampoCodigo}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorCodigo_filtroInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorCodigo_filtroFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Codigo_filtro_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Codigo_filtro = valorInicial,
                Codigo_filtro_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.CampoCodigo}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.CampoCodigo}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.CampoCodigo}");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.CampoCodigo} BETWEEN");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorCodigo_filtroInicial = 2500;
            var valorCodigo_filtroFinal = 4750;
            var filtro = new FilterContratos
            {
                Codigo_filtro = valorCodigo_filtroInicial,
                Codigo_filtro_end = valorCodigo_filtroFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.CampoCodigo}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.CampoCodigo}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorCodigo_filtroInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorCodigo_filtroFinal);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Codigo_filtro = 0,
                Codigo_filtro_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Codigo_filtro = 0,
                Codigo_filtro_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Codigo_filtro = 1500,
                Codigo_filtro_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Codigo_filtro == int.MinValue) && !(filtro.Codigo_filtro_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.CampoCodigo} BETWEEN @{DBContratosDicInfo.CampoCodigo} AND @{DBContratosDicInfo.CampoCodigo}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Codigo_filtro = 2000,
                Codigo_filtro_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Codigo_filtro == int.MinValue) && filtro.Codigo_filtro_end == int.MinValue
            // Deve resultar em igualdade quando apenas Codigo_filtro tem valor válido
            resultado.Value.where.Should().Be($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.CampoCodigo}] = @{DBContratosDicInfo.CampoCodigo}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Codigo_filtro_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Codigo_filtro = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Codigo_filtro Isolated Tests
        [Fact]
        public void WFiltro_Codigo_filtro_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Codigo_filtro = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorCodigo_filtro = 5;
            var filtro = new FilterContratos
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.CampoCodigo}] = @{DBContratosDicInfo.CampoCodigo}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContratosDicInfo.CampoCodigo}");
            parametro.Value.Should().Be(valorCodigo_filtro);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorCodigo_filtro = 0;
            var filtro = new FilterContratos
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBContratosDicInfo.CampoCodigo}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCodigo_filtro);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Codigo_filtro_DiferentesValoresValidos_DeveProcessarCorretamente(int valorCodigo_filtro)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCodigo_filtro);
            resultado.Value.where.Should().Contain($"= @{DBContratosDicInfo.CampoCodigo}");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Codigo_filtro = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.CampoCodigo}");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Codigo_filtro = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Codigo_filtro = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Codigo_filtro = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Codigo_filtro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.CampoCodigo}]");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Codigo_filtro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Codigo_filtro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Codigo_filtro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorCodigo_filtro = 42;
            var filtro = new FilterContratos
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorCodigo_filtro);
        }

#endregion
        [Fact]
        public void WFiltro_Codigo_filtro_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Codigo_filtro = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorCodigo_filtro = 1;
            var filtro = new FilterContratos
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Codigo_filtro
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.CampoCodigo}] = @{DBContratosDicInfo.CampoCodigo}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContratosDicInfo.CampoCodigo}");
            parametro.Value.Should().Be(valorCodigo_filtro);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Codigo_filtro = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.CampoCodigo}");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Codigo_filtro_DiferentesValores_DeveFuncionar(int valorCodigo_filtro)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCodigo_filtro);
        }

#endregion
#region Decimal Tests
#region filtro.Valor_end Tests
        [Fact]
        public void WFiltro_Valor_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Valor_end = decimal.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Valor_end_QuandoTemValorPositivo_SemValorInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorValorEnd = 5000m;
            var filtro = new FilterContratos
            {
                Valor = decimal.MinValue, // Não define salário inicial
                Valor_end = valorValorEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Valor inicial válido, não deve incluir condição WHERE, mas o parâmetro Valor_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Valor_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Valor_end_QuandoSomenteValorInicial_SemValorEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorValor = 2500m;
            var filtro = new FilterContratos
            {
                Valor = valorValor,
                Valor_end = decimal.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Valor}] = @{DBContratosDicInfo.Valor}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContratosDicInfo.Valor}");
            parametro.Value.Should().Be(valorValor);
        }

        [Fact]
        public void WFiltro_Valor_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorValorInicial = 1000m;
            var valorValorFinal = 5000m;
            var filtro = new FilterContratos
            {
                Valor = valorValorInicial,
                Valor_end = valorValorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.Valor} BETWEEN @{DBContratosDicInfo.Valor} AND @{DBContratosDicInfo.Valor}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.Valor}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.Valor}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorValorInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorValorFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500.50, 7500.75)]
        [InlineData(10000, 50000)]
        public void WFiltro_Valor_RangeDiferentesValores_DeveProcessarCorretamente(decimal valorInicial, decimal valorFinal)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Valor = valorInicial,
                Valor_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.Valor}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.Valor}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Valor_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Valor = 1000m,
                Valor_end = 5000m,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Valor}");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Valor_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Valor = 1000m,
                Valor_end = 5000m,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Valor_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Valor = 1000m,
                Valor_end = 5000m,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Valor_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Valor = 1000m,
                Valor_end = 5000m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.Valor} BETWEEN");
        }

        [Fact]
        public void WFiltro_Valor_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Valor = 1000m,
                Valor_end = 5000m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Valor_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Valor = 1000m,
                Valor_end = 5000m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Valor_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorValorInicial = 1500.50m;
            var valorValorFinal = 3750.75m;
            var filtro = new FilterContratos
            {
                Valor = valorValorInicial,
                Valor_end = valorValorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.Valor}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.Valor}_end");
            parametroInicial.Value.Should().BeOfType<decimal>();
            parametroInicial.Value.Should().Be(valorValorInicial);
            parametroFinal.Value.Should().BeOfType<decimal>();
            parametroFinal.Value.Should().Be(valorValorFinal);
        }

        [Fact]
        public void WFiltro_Valor_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Valor = 0m,
                Valor_end = 0m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Valor_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Valor = 0m,
                Valor_end = decimal.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Valor_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Valor = 1500m,
                Valor_end = 4500m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Valor == decimal.MinValue) && !(filtro.Valor_end == decimal.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.Valor} BETWEEN @{DBContratosDicInfo.Valor} AND @{DBContratosDicInfo.Valor}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Valor_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Valor = 2000m,
                Valor_end = decimal.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Valor == decimal.MinValue) && filtro.Valor_end == decimal.MinValue
            // Deve resultar em igualdade quando apenas Valor tem valor válido
            resultado.Value.where.Should().Be($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Valor}] = @{DBContratosDicInfo.Valor}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData("79228162514264337593543950335")]
        [InlineData("-79228162514264337593543950335")] // MinValue é usado como "não filtrar"
        [InlineData("0.01")]
        [InlineData("-999999.99")]
        public void WFiltro_Valor_ComValoresExtremos_DeveProcessarCorretamente(string valorExtremoStr)
        {
            // Arrange
            var valorExtremo = decimal.Parse(valorExtremoStr, System.Globalization.CultureInfo.InvariantCulture);
            var filtro = new FilterContratos
            {
                Valor = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(valorExtremo == decimal.MinValue ? 0 : 1);
            if (valorExtremo != decimal.MinValue)
            {
                resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
            }
        }

#region filtro.Valor Isolated Tests
        [Fact]
        public void WFiltro_Valor_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Valor = decimal.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Valor_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorValor = 5;
            var filtro = new FilterContratos
            {
                Valor = valorValor,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Valor}] = @{DBContratosDicInfo.Valor}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContratosDicInfo.Valor}");
            parametro.Value.Should().Be(valorValor);
        }

        [Fact]
        public void WFiltro_Valor_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorValor = 0;
            var filtro = new FilterContratos
            {
                Valor = valorValor,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBContratosDicInfo.Valor}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorValor);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Valor_DiferentesValoresValidos_DeveProcessarCorretamente(decimal valorValor)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Valor = valorValor,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorValor);
            resultado.Value.where.Should().Contain($"= @{DBContratosDicInfo.Valor}");
        }

        [Fact]
        public void WFiltro_Valor_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Valor = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Valor}");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Valor_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Valor = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Valor_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Valor = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Valor_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Valor = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Valor_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Valor = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Valor}]");
        }

        [Fact]
        public void WFiltro_Valor_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Valor = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Valor_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Valor = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Valor_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Valor = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Valor_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            var valorValor = (decimal)42.12;
            var filtro = new FilterContratos
            {
                Valor = valorValor,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<decimal>();
            parametro.Value.Should().Be(valorValor);
        }

#endregion
        [Fact]
        public void WFiltro_Valor_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Valor = decimal.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Valor_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            decimal valorValor = 1;
            var filtro = new FilterContratos
            {
                Valor = valorValor,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Valor
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Valor}] = @cttValor");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@cttValor");
            parametro.Value.Should().Be(valorValor);
        }

        [Fact]
        public void WFiltro_Valor_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Valor = (decimal)1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@cttValor");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1.2)]
        [InlineData(999.40)]
        public void WFiltro_Valor_DiferentesValores_DeveFuncionar(decimal valorValor)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Valor = valorValor,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorValor);
        }

#region filtro.PercEscritorio_end Tests
        [Fact]
        public void WFiltro_PercEscritorio_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                PercEscritorio_end = decimal.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_PercEscritorio_end_QuandoTemValorPositivo_SemPercEscritorioInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorPercEscritorioEnd = 5000m;
            var filtro = new FilterContratos
            {
                PercEscritorio = decimal.MinValue, // Não define salário inicial
                PercEscritorio_end = valorPercEscritorioEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há PercEscritorio inicial válido, não deve incluir condição WHERE, mas o parâmetro PercEscritorio_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // PercEscritorio_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_PercEscritorio_end_QuandoSomenteValorInicial_SemPercEscritorioEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorPercEscritorio = 2500m;
            var filtro = new FilterContratos
            {
                PercEscritorio = valorPercEscritorio,
                PercEscritorio_end = decimal.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.PercEscritorio}] = @{DBContratosDicInfo.PercEscritorio}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContratosDicInfo.PercEscritorio}");
            parametro.Value.Should().Be(valorPercEscritorio);
        }

        [Fact]
        public void WFiltro_PercEscritorio_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorPercEscritorioInicial = 1000m;
            var valorPercEscritorioFinal = 5000m;
            var filtro = new FilterContratos
            {
                PercEscritorio = valorPercEscritorioInicial,
                PercEscritorio_end = valorPercEscritorioFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.PercEscritorio} BETWEEN @{DBContratosDicInfo.PercEscritorio} AND @{DBContratosDicInfo.PercEscritorio}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.PercEscritorio}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.PercEscritorio}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorPercEscritorioInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorPercEscritorioFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500.50, 7500.75)]
        [InlineData(10000, 50000)]
        public void WFiltro_PercEscritorio_RangeDiferentesValores_DeveProcessarCorretamente(decimal valorInicial, decimal valorFinal)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                PercEscritorio = valorInicial,
                PercEscritorio_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.PercEscritorio}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.PercEscritorio}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_PercEscritorio_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                PercEscritorio = 1000m,
                PercEscritorio_end = 5000m,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.PercEscritorio}");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_PercEscritorio_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                PercEscritorio = 1000m,
                PercEscritorio_end = 5000m,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_PercEscritorio_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                PercEscritorio = 1000m,
                PercEscritorio_end = 5000m,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_PercEscritorio_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                PercEscritorio = 1000m,
                PercEscritorio_end = 5000m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.PercEscritorio} BETWEEN");
        }

        [Fact]
        public void WFiltro_PercEscritorio_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                PercEscritorio = 1000m,
                PercEscritorio_end = 5000m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_PercEscritorio_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                PercEscritorio = 1000m,
                PercEscritorio_end = 5000m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_PercEscritorio_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorPercEscritorioInicial = 1500.50m;
            var valorPercEscritorioFinal = 3750.75m;
            var filtro = new FilterContratos
            {
                PercEscritorio = valorPercEscritorioInicial,
                PercEscritorio_end = valorPercEscritorioFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.PercEscritorio}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.PercEscritorio}_end");
            parametroInicial.Value.Should().BeOfType<decimal>();
            parametroInicial.Value.Should().Be(valorPercEscritorioInicial);
            parametroFinal.Value.Should().BeOfType<decimal>();
            parametroFinal.Value.Should().Be(valorPercEscritorioFinal);
        }

        [Fact]
        public void WFiltro_PercEscritorio_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                PercEscritorio = 0m,
                PercEscritorio_end = 0m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_PercEscritorio_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                PercEscritorio = 0m,
                PercEscritorio_end = decimal.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_PercEscritorio_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                PercEscritorio = 1500m,
                PercEscritorio_end = 4500m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.PercEscritorio == decimal.MinValue) && !(filtro.PercEscritorio_end == decimal.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.PercEscritorio} BETWEEN @{DBContratosDicInfo.PercEscritorio} AND @{DBContratosDicInfo.PercEscritorio}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_PercEscritorio_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                PercEscritorio = 2000m,
                PercEscritorio_end = decimal.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.PercEscritorio == decimal.MinValue) && filtro.PercEscritorio_end == decimal.MinValue
            // Deve resultar em igualdade quando apenas PercEscritorio tem valor válido
            resultado.Value.where.Should().Be($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.PercEscritorio}] = @{DBContratosDicInfo.PercEscritorio}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData("79228162514264337593543950335")]
        [InlineData("-79228162514264337593543950335")] // MinValue é usado como "não filtrar"
        [InlineData("0.01")]
        [InlineData("-999999.99")]
        public void WFiltro_PercEscritorio_ComValoresExtremos_DeveProcessarCorretamente(string valorExtremoStr)
        {
            // Arrange
            var valorExtremo = decimal.Parse(valorExtremoStr, System.Globalization.CultureInfo.InvariantCulture);
            var filtro = new FilterContratos
            {
                PercEscritorio = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(valorExtremo == decimal.MinValue ? 0 : 1);
            if (valorExtremo != decimal.MinValue)
            {
                resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
            }
        }

#region filtro.PercEscritorio Isolated Tests
        [Fact]
        public void WFiltro_PercEscritorio_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                PercEscritorio = decimal.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_PercEscritorio_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorPercEscritorio = 5;
            var filtro = new FilterContratos
            {
                PercEscritorio = valorPercEscritorio,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.PercEscritorio}] = @{DBContratosDicInfo.PercEscritorio}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContratosDicInfo.PercEscritorio}");
            parametro.Value.Should().Be(valorPercEscritorio);
        }

        [Fact]
        public void WFiltro_PercEscritorio_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorPercEscritorio = 0;
            var filtro = new FilterContratos
            {
                PercEscritorio = valorPercEscritorio,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBContratosDicInfo.PercEscritorio}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorPercEscritorio);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_PercEscritorio_DiferentesValoresValidos_DeveProcessarCorretamente(decimal valorPercEscritorio)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                PercEscritorio = valorPercEscritorio,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorPercEscritorio);
            resultado.Value.where.Should().Contain($"= @{DBContratosDicInfo.PercEscritorio}");
        }

        [Fact]
        public void WFiltro_PercEscritorio_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                PercEscritorio = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.PercEscritorio}");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_PercEscritorio_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                PercEscritorio = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_PercEscritorio_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                PercEscritorio = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_PercEscritorio_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                PercEscritorio = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_PercEscritorio_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                PercEscritorio = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.PercEscritorio}]");
        }

        [Fact]
        public void WFiltro_PercEscritorio_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                PercEscritorio = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_PercEscritorio_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                PercEscritorio = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_PercEscritorio_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                PercEscritorio = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_PercEscritorio_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            var valorPercEscritorio = (decimal)42.12;
            var filtro = new FilterContratos
            {
                PercEscritorio = valorPercEscritorio,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<decimal>();
            parametro.Value.Should().Be(valorPercEscritorio);
        }

#endregion
        [Fact]
        public void WFiltro_PercEscritorio_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                PercEscritorio = decimal.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_PercEscritorio_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            decimal valorPercEscritorio = 1;
            var filtro = new FilterContratos
            {
                PercEscritorio = valorPercEscritorio,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do PercEscritorio
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.PercEscritorio}] = @cttPercEscritorio");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@cttPercEscritorio");
            parametro.Value.Should().Be(valorPercEscritorio);
        }

        [Fact]
        public void WFiltro_PercEscritorio_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                PercEscritorio = (decimal)1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@cttPercEscritorio");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1.2)]
        [InlineData(999.40)]
        public void WFiltro_PercEscritorio_DiferentesValores_DeveFuncionar(decimal valorPercEscritorio)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                PercEscritorio = valorPercEscritorio,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorPercEscritorio);
        }

#region filtro.ValorConsultoria_end Tests
        [Fact]
        public void WFiltro_ValorConsultoria_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorConsultoria_end = decimal.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_ValorConsultoria_end_QuandoTemValorPositivo_SemValorConsultoriaInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorValorConsultoriaEnd = 5000m;
            var filtro = new FilterContratos
            {
                ValorConsultoria = decimal.MinValue, // Não define salário inicial
                ValorConsultoria_end = valorValorConsultoriaEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há ValorConsultoria inicial válido, não deve incluir condição WHERE, mas o parâmetro ValorConsultoria_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // ValorConsultoria_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_ValorConsultoria_end_QuandoSomenteValorInicial_SemValorConsultoriaEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorValorConsultoria = 2500m;
            var filtro = new FilterContratos
            {
                ValorConsultoria = valorValorConsultoria,
                ValorConsultoria_end = decimal.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.ValorConsultoria}] = @{DBContratosDicInfo.ValorConsultoria}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContratosDicInfo.ValorConsultoria}");
            parametro.Value.Should().Be(valorValorConsultoria);
        }

        [Fact]
        public void WFiltro_ValorConsultoria_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorValorConsultoriaInicial = 1000m;
            var valorValorConsultoriaFinal = 5000m;
            var filtro = new FilterContratos
            {
                ValorConsultoria = valorValorConsultoriaInicial,
                ValorConsultoria_end = valorValorConsultoriaFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.ValorConsultoria} BETWEEN @{DBContratosDicInfo.ValorConsultoria} AND @{DBContratosDicInfo.ValorConsultoria}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.ValorConsultoria}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.ValorConsultoria}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorValorConsultoriaInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorValorConsultoriaFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500.50, 7500.75)]
        [InlineData(10000, 50000)]
        public void WFiltro_ValorConsultoria_RangeDiferentesValores_DeveProcessarCorretamente(decimal valorInicial, decimal valorFinal)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorConsultoria = valorInicial,
                ValorConsultoria_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.ValorConsultoria}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.ValorConsultoria}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_ValorConsultoria_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorConsultoria = 1000m,
                ValorConsultoria_end = 5000m,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.ValorConsultoria}");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_ValorConsultoria_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorConsultoria = 1000m,
                ValorConsultoria_end = 5000m,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_ValorConsultoria_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorConsultoria = 1000m,
                ValorConsultoria_end = 5000m,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_ValorConsultoria_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorConsultoria = 1000m,
                ValorConsultoria_end = 5000m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.ValorConsultoria} BETWEEN");
        }

        [Fact]
        public void WFiltro_ValorConsultoria_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorConsultoria = 1000m,
                ValorConsultoria_end = 5000m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_ValorConsultoria_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorConsultoria = 1000m,
                ValorConsultoria_end = 5000m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_ValorConsultoria_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorValorConsultoriaInicial = 1500.50m;
            var valorValorConsultoriaFinal = 3750.75m;
            var filtro = new FilterContratos
            {
                ValorConsultoria = valorValorConsultoriaInicial,
                ValorConsultoria_end = valorValorConsultoriaFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.ValorConsultoria}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.ValorConsultoria}_end");
            parametroInicial.Value.Should().BeOfType<decimal>();
            parametroInicial.Value.Should().Be(valorValorConsultoriaInicial);
            parametroFinal.Value.Should().BeOfType<decimal>();
            parametroFinal.Value.Should().Be(valorValorConsultoriaFinal);
        }

        [Fact]
        public void WFiltro_ValorConsultoria_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorConsultoria = 0m,
                ValorConsultoria_end = 0m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_ValorConsultoria_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorConsultoria = 0m,
                ValorConsultoria_end = decimal.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_ValorConsultoria_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorConsultoria = 1500m,
                ValorConsultoria_end = 4500m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.ValorConsultoria == decimal.MinValue) && !(filtro.ValorConsultoria_end == decimal.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.ValorConsultoria} BETWEEN @{DBContratosDicInfo.ValorConsultoria} AND @{DBContratosDicInfo.ValorConsultoria}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_ValorConsultoria_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorConsultoria = 2000m,
                ValorConsultoria_end = decimal.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.ValorConsultoria == decimal.MinValue) && filtro.ValorConsultoria_end == decimal.MinValue
            // Deve resultar em igualdade quando apenas ValorConsultoria tem valor válido
            resultado.Value.where.Should().Be($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.ValorConsultoria}] = @{DBContratosDicInfo.ValorConsultoria}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData("79228162514264337593543950335")]
        [InlineData("-79228162514264337593543950335")] // MinValue é usado como "não filtrar"
        [InlineData("0.01")]
        [InlineData("-999999.99")]
        public void WFiltro_ValorConsultoria_ComValoresExtremos_DeveProcessarCorretamente(string valorExtremoStr)
        {
            // Arrange
            var valorExtremo = decimal.Parse(valorExtremoStr, System.Globalization.CultureInfo.InvariantCulture);
            var filtro = new FilterContratos
            {
                ValorConsultoria = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(valorExtremo == decimal.MinValue ? 0 : 1);
            if (valorExtremo != decimal.MinValue)
            {
                resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
            }
        }

#region filtro.ValorConsultoria Isolated Tests
        [Fact]
        public void WFiltro_ValorConsultoria_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorConsultoria = decimal.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_ValorConsultoria_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorValorConsultoria = 5;
            var filtro = new FilterContratos
            {
                ValorConsultoria = valorValorConsultoria,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.ValorConsultoria}] = @{DBContratosDicInfo.ValorConsultoria}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContratosDicInfo.ValorConsultoria}");
            parametro.Value.Should().Be(valorValorConsultoria);
        }

        [Fact]
        public void WFiltro_ValorConsultoria_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorValorConsultoria = 0;
            var filtro = new FilterContratos
            {
                ValorConsultoria = valorValorConsultoria,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBContratosDicInfo.ValorConsultoria}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorValorConsultoria);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_ValorConsultoria_DiferentesValoresValidos_DeveProcessarCorretamente(decimal valorValorConsultoria)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorConsultoria = valorValorConsultoria,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorValorConsultoria);
            resultado.Value.where.Should().Contain($"= @{DBContratosDicInfo.ValorConsultoria}");
        }

        [Fact]
        public void WFiltro_ValorConsultoria_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorConsultoria = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.ValorConsultoria}");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_ValorConsultoria_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorConsultoria = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_ValorConsultoria_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorConsultoria = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_ValorConsultoria_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorConsultoria = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_ValorConsultoria_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorConsultoria = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.ValorConsultoria}]");
        }

        [Fact]
        public void WFiltro_ValorConsultoria_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorConsultoria = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_ValorConsultoria_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorConsultoria = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_ValorConsultoria_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorConsultoria = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_ValorConsultoria_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            var valorValorConsultoria = (decimal)42.12;
            var filtro = new FilterContratos
            {
                ValorConsultoria = valorValorConsultoria,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<decimal>();
            parametro.Value.Should().Be(valorValorConsultoria);
        }

#endregion
        [Fact]
        public void WFiltro_ValorConsultoria_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorConsultoria = decimal.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_ValorConsultoria_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            decimal valorValorConsultoria = 1;
            var filtro = new FilterContratos
            {
                ValorConsultoria = valorValorConsultoria,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do ValorConsultoria
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.ValorConsultoria}] = @cttValorConsultoria");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@cttValorConsultoria");
            parametro.Value.Should().Be(valorValorConsultoria);
        }

        [Fact]
        public void WFiltro_ValorConsultoria_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorConsultoria = (decimal)1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@cttValorConsultoria");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1.2)]
        [InlineData(999.40)]
        public void WFiltro_ValorConsultoria_DiferentesValores_DeveFuncionar(decimal valorValorConsultoria)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorConsultoria = valorValorConsultoria,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorValorConsultoria);
        }

#region filtro.ValorRealizavel_end Tests
        [Fact]
        public void WFiltro_ValorRealizavel_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorRealizavel_end = decimal.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_ValorRealizavel_end_QuandoTemValorPositivo_SemValorRealizavelInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorValorRealizavelEnd = 5000m;
            var filtro = new FilterContratos
            {
                ValorRealizavel = decimal.MinValue, // Não define salário inicial
                ValorRealizavel_end = valorValorRealizavelEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há ValorRealizavel inicial válido, não deve incluir condição WHERE, mas o parâmetro ValorRealizavel_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // ValorRealizavel_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_ValorRealizavel_end_QuandoSomenteValorInicial_SemValorRealizavelEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorValorRealizavel = 2500m;
            var filtro = new FilterContratos
            {
                ValorRealizavel = valorValorRealizavel,
                ValorRealizavel_end = decimal.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.ValorRealizavel}] = @{DBContratosDicInfo.ValorRealizavel}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContratosDicInfo.ValorRealizavel}");
            parametro.Value.Should().Be(valorValorRealizavel);
        }

        [Fact]
        public void WFiltro_ValorRealizavel_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorValorRealizavelInicial = 1000m;
            var valorValorRealizavelFinal = 5000m;
            var filtro = new FilterContratos
            {
                ValorRealizavel = valorValorRealizavelInicial,
                ValorRealizavel_end = valorValorRealizavelFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.ValorRealizavel} BETWEEN @{DBContratosDicInfo.ValorRealizavel} AND @{DBContratosDicInfo.ValorRealizavel}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.ValorRealizavel}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.ValorRealizavel}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorValorRealizavelInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorValorRealizavelFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500.50, 7500.75)]
        [InlineData(10000, 50000)]
        public void WFiltro_ValorRealizavel_RangeDiferentesValores_DeveProcessarCorretamente(decimal valorInicial, decimal valorFinal)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorRealizavel = valorInicial,
                ValorRealizavel_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.ValorRealizavel}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.ValorRealizavel}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_ValorRealizavel_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorRealizavel = 1000m,
                ValorRealizavel_end = 5000m,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.ValorRealizavel}");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_ValorRealizavel_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorRealizavel = 1000m,
                ValorRealizavel_end = 5000m,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_ValorRealizavel_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorRealizavel = 1000m,
                ValorRealizavel_end = 5000m,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_ValorRealizavel_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorRealizavel = 1000m,
                ValorRealizavel_end = 5000m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.ValorRealizavel} BETWEEN");
        }

        [Fact]
        public void WFiltro_ValorRealizavel_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorRealizavel = 1000m,
                ValorRealizavel_end = 5000m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_ValorRealizavel_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorRealizavel = 1000m,
                ValorRealizavel_end = 5000m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_ValorRealizavel_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorValorRealizavelInicial = 1500.50m;
            var valorValorRealizavelFinal = 3750.75m;
            var filtro = new FilterContratos
            {
                ValorRealizavel = valorValorRealizavelInicial,
                ValorRealizavel_end = valorValorRealizavelFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.ValorRealizavel}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContratosDicInfo.ValorRealizavel}_end");
            parametroInicial.Value.Should().BeOfType<decimal>();
            parametroInicial.Value.Should().Be(valorValorRealizavelInicial);
            parametroFinal.Value.Should().BeOfType<decimal>();
            parametroFinal.Value.Should().Be(valorValorRealizavelFinal);
        }

        [Fact]
        public void WFiltro_ValorRealizavel_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorRealizavel = 0m,
                ValorRealizavel_end = 0m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_ValorRealizavel_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorRealizavel = 0m,
                ValorRealizavel_end = decimal.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_ValorRealizavel_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorRealizavel = 1500m,
                ValorRealizavel_end = 4500m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.ValorRealizavel == decimal.MinValue) && !(filtro.ValorRealizavel_end == decimal.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.ValorRealizavel} BETWEEN @{DBContratosDicInfo.ValorRealizavel} AND @{DBContratosDicInfo.ValorRealizavel}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_ValorRealizavel_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorRealizavel = 2000m,
                ValorRealizavel_end = decimal.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.ValorRealizavel == decimal.MinValue) && filtro.ValorRealizavel_end == decimal.MinValue
            // Deve resultar em igualdade quando apenas ValorRealizavel tem valor válido
            resultado.Value.where.Should().Be($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.ValorRealizavel}] = @{DBContratosDicInfo.ValorRealizavel}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData("79228162514264337593543950335")]
        [InlineData("-79228162514264337593543950335")] // MinValue é usado como "não filtrar"
        [InlineData("0.01")]
        [InlineData("-999999.99")]
        public void WFiltro_ValorRealizavel_ComValoresExtremos_DeveProcessarCorretamente(string valorExtremoStr)
        {
            // Arrange
            var valorExtremo = decimal.Parse(valorExtremoStr, System.Globalization.CultureInfo.InvariantCulture);
            var filtro = new FilterContratos
            {
                ValorRealizavel = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(valorExtremo == decimal.MinValue ? 0 : 1);
            if (valorExtremo != decimal.MinValue)
            {
                resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
            }
        }

#region filtro.ValorRealizavel Isolated Tests
        [Fact]
        public void WFiltro_ValorRealizavel_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorRealizavel = decimal.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_ValorRealizavel_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorValorRealizavel = 5;
            var filtro = new FilterContratos
            {
                ValorRealizavel = valorValorRealizavel,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.ValorRealizavel}] = @{DBContratosDicInfo.ValorRealizavel}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContratosDicInfo.ValorRealizavel}");
            parametro.Value.Should().Be(valorValorRealizavel);
        }

        [Fact]
        public void WFiltro_ValorRealizavel_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorValorRealizavel = 0;
            var filtro = new FilterContratos
            {
                ValorRealizavel = valorValorRealizavel,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBContratosDicInfo.ValorRealizavel}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorValorRealizavel);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_ValorRealizavel_DiferentesValoresValidos_DeveProcessarCorretamente(decimal valorValorRealizavel)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorRealizavel = valorValorRealizavel,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorValorRealizavel);
            resultado.Value.where.Should().Contain($"= @{DBContratosDicInfo.ValorRealizavel}");
        }

        [Fact]
        public void WFiltro_ValorRealizavel_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorRealizavel = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.ValorRealizavel}");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_ValorRealizavel_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorRealizavel = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_ValorRealizavel_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorRealizavel = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_ValorRealizavel_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorRealizavel = 1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_ValorRealizavel_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorRealizavel = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.ValorRealizavel}]");
        }

        [Fact]
        public void WFiltro_ValorRealizavel_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorRealizavel = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_ValorRealizavel_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorRealizavel = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_ValorRealizavel_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorRealizavel = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_ValorRealizavel_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            var valorValorRealizavel = (decimal)42.12;
            var filtro = new FilterContratos
            {
                ValorRealizavel = valorValorRealizavel,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<decimal>();
            parametro.Value.Should().Be(valorValorRealizavel);
        }

#endregion
        [Fact]
        public void WFiltro_ValorRealizavel_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorRealizavel = decimal.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_ValorRealizavel_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            decimal valorValorRealizavel = 1;
            var filtro = new FilterContratos
            {
                ValorRealizavel = valorValorRealizavel,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do ValorRealizavel
            resultado.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.ValorRealizavel}] = @cttValorRealizavel");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@cttValorRealizavel");
            parametro.Value.Should().Be(valorValorRealizavel);
        }

        [Fact]
        public void WFiltro_ValorRealizavel_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorRealizavel = (decimal)1,
                Protestar = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@cttValorRealizavel");
            resultado.Value.where.Should().Contain($"@{DBContratosDicInfo.Protestar}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1.2)]
        [InlineData(999.40)]
        public void WFiltro_ValorRealizavel_DiferentesValores_DeveFuncionar(decimal valorValorRealizavel)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                ValorRealizavel = valorValorRealizavel,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorValorRealizavel);
        }

#endregion
#region DateTime Tests
        [Theory]
        [InlineData("31/12/9999")] // Data máxima
        [InlineData("01/01/1900")] // Data muito antiga
        [InlineData("29/02/2024")] // Ano bissexto
        public void WFiltro_DataInicio_ComDatasExtremas_DeveProcessarCorretamente(string dataExtrema)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                DataInicio = dataExtrema,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<DateTime>();
        }

        [Theory]
        [InlineData("32/12/2023")] // Dia inválido
        [InlineData("31/13/2023")] // Mês inválido
        [InlineData("29/02/2023")] // Não é ano bissexto
        [InlineData("abc/def/ghij")] // Formato completamente inválido
        public void WFiltro_DataInicio_ComDatasInvalidas_NaoDeveAdicionarParametros(string dataInvalida)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                DataInicio = dataInvalida,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().BeEmpty();
            resultado.Value.where.Should().BeEmpty();
        }

#region DataInicio Tests
        [Fact]
        public void WFiltro_DataInicio_WhenEmptyOrNull_ShouldNotAddParameters()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                DataInicio = string.Empty,
                DataInicio_end = null,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DataInicio_WhenValidSingleDate_ShouldAddParameterAndGenerateWhereClause()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterContratos
            {
                DataInicio = testDate,
                DataInicio_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(1);
            var parameter = result.Value.parametros.First();
            parameter.ParameterName.Should().Be($"@{DBContratosDicInfo.DataInicio}");
            parameter.Value.Should().BeOfType<DateTime>();
            var expectedDate = DateTime.Parse(testDate);
            ((DateTime)parameter.Value).Should().Be(expectedDate);
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.DataInicio}], 103) = CONVERT(DATE, @{DBContratosDicInfo.DataInicio}, 103)");
        }

        [Fact]
        public void WFiltro_DataInicio_WhenValidDateRange_ShouldAddBothParametersAndGenerateBetweenClause()
        {
            // Arrange
            var startDate = "01/06/2023";
            var endDate = "30/06/2023";
            var filtro = new FilterContratos
            {
                DataInicio = startDate,
                DataInicio_end = endDate,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(2);
            var startParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.DataInicio}");
            var endParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.DataInicio}_end");
            startParameter.Should().NotBeNull();
            endParameter.Should().NotBeNull();
            startParameter!.Value.Should().BeOfType<DateTime>();
            endParameter!.Value.Should().BeOfType<DateTime>();
            ((DateTime)startParameter.Value).Should().Be(DateTime.Parse(startDate));
            ((DateTime)endParameter.Value).Should().Be(DateTime.Parse(endDate));
            result.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.DataInicio} BETWEEN @{DBContratosDicInfo.DataInicio} AND @{DBContratosDicInfo.DataInicio}_end");
        }

        [Fact]
        public void WFiltro_DataInicio_WhenInvalidDateFormat_ShouldNotAddParameter()
        {
            // Arrange
            var invalidDate = "invalid-date";
            var filtro = new FilterContratos
            {
                DataInicio = invalidDate,
                DataInicio_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DataInicio_WhenStartDateValidButEndDateInvalid_ShouldOnlyAddStartParameterAndGenerateSingleDateClause()
        {
            // Arrange
            var validStartDate = "15/06/2023";
            var invalidEndDate = "invalid-date";
            var filtro = new FilterContratos
            {
                DataInicio = validStartDate,
                DataInicio_end = invalidEndDate,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(1);
            var parameter = result.Value.parametros.First();
            parameter.ParameterName.Should().Be($"@{DBContratosDicInfo.DataInicio}");
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.DataInicio}], 103) = CONVERT(DATE, @{DBContratosDicInfo.DataInicio}, 103)");
            result.Value.where.Should().NotContain("BETWEEN");
        }

        [Fact]
        public void WFiltro_DataInicio_WhenStartDateInvalidButEndDateValid_ShouldNotAddAnyParameters()
        {
            // Arrange
            var invalidStartDate = "invalid-date";
            var validEndDate = "30/06/2023";
            var filtro = new FilterContratos
            {
                DataInicio = invalidStartDate,
                DataInicio_end = validEndDate,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DataInicio_WhenWhitespaceOnlyDates_ShouldNotAddParameters()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                DataInicio = "   ",
                DataInicio_end = "\t\n",
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DataInicio_WithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterContratos
            {
                Protestar = "A",
                DataInicio = testDate,
                DataInicio_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(2); // Nome + DataInicio
            result.Value.where.Should().Contain(TSql.And);
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.DataInicio}], 103) = CONVERT(DATE, @{DBContratosDicInfo.DataInicio}, 103)");
        }

        [Fact]
        public void WFiltro_DataInicio_WithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterContratos
            {
                Protestar = "A",
                DataInicio = testDate,
                DataInicio_end = string.Empty,
                LogicalOperator = TSql.OR
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(TSql.OR);
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.DataInicio}], 103) = CONVERT(DATE, @{DBContratosDicInfo.DataInicio}, 103)");
        }

        [Fact]
        public void WFiltro_DataInicio_WhenOnlyEndDateProvided_ShouldNotAddParameters()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                DataInicio = string.Empty,
                DataInicio_end = "30/06/2023",
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DataInicio_WhenDateTimeMinValue_ShouldNotAddParameters()
        {
            // Arrange
            var minValueDate = DateTime.MinValue.ToString("dd/MM/yyyy");
            var filtro = new FilterContratos
            {
                DataInicio = minValueDate,
                DataInicio_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // The IsEmptyDX extension method should catch DateTime.MinValue and return true
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DataInicio_AsFirstFilter_ShouldNotIncludeLogicalOperatorAtStart()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterContratos
            {
                DataInicio = testDate,
                DataInicio_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().NotStartWith(TSql.And);
            result.Value.where.Should().StartWith($"CONVERT(DATE,[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.DataInicio}], 103)");
        }

        [Theory]
        [InlineData("15/06/2023", "2023-06-15T00:00:00")]
        [InlineData("01/01/2024", "2024-01-01T00:00:00")]
        [InlineData("31/12/2022", "2022-12-31T00:00:00")]
        public void WFiltro_DataInicio_WhenVariousValidDateFormats_ShouldParseCorrectly(string inputDate, string expectedDateTimeString)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                DataInicio = inputDate,
                DataInicio_end = string.Empty,
                LogicalOperator = TSql.And
            };
            var expectedDateTime = DateTime.Parse(expectedDateTimeString);
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(1);
            var parameter = result.Value.parametros.First();
            ((DateTime)parameter.Value).Should().Be(expectedDateTime);
        }

#endregion
        [Theory]
        [InlineData("31/12/9999")] // Data máxima
        [InlineData("01/01/1900")] // Data muito antiga
        [InlineData("29/02/2024")] // Ano bissexto
        public void WFiltro_DataTermino_ComDatasExtremas_DeveProcessarCorretamente(string dataExtrema)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                DataTermino = dataExtrema,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<DateTime>();
        }

        [Theory]
        [InlineData("32/12/2023")] // Dia inválido
        [InlineData("31/13/2023")] // Mês inválido
        [InlineData("29/02/2023")] // Não é ano bissexto
        [InlineData("abc/def/ghij")] // Formato completamente inválido
        public void WFiltro_DataTermino_ComDatasInvalidas_NaoDeveAdicionarParametros(string dataInvalida)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                DataTermino = dataInvalida,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().BeEmpty();
            resultado.Value.where.Should().BeEmpty();
        }

#region DataTermino Tests
        [Fact]
        public void WFiltro_DataTermino_WhenEmptyOrNull_ShouldNotAddParameters()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                DataTermino = string.Empty,
                DataTermino_end = null,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DataTermino_WhenValidSingleDate_ShouldAddParameterAndGenerateWhereClause()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterContratos
            {
                DataTermino = testDate,
                DataTermino_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(1);
            var parameter = result.Value.parametros.First();
            parameter.ParameterName.Should().Be($"@{DBContratosDicInfo.DataTermino}");
            parameter.Value.Should().BeOfType<DateTime>();
            var expectedDate = DateTime.Parse(testDate);
            ((DateTime)parameter.Value).Should().Be(expectedDate);
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.DataTermino}], 103) = CONVERT(DATE, @{DBContratosDicInfo.DataTermino}, 103)");
        }

        [Fact]
        public void WFiltro_DataTermino_WhenValidDateRange_ShouldAddBothParametersAndGenerateBetweenClause()
        {
            // Arrange
            var startDate = "01/06/2023";
            var endDate = "30/06/2023";
            var filtro = new FilterContratos
            {
                DataTermino = startDate,
                DataTermino_end = endDate,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(2);
            var startParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.DataTermino}");
            var endParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.DataTermino}_end");
            startParameter.Should().NotBeNull();
            endParameter.Should().NotBeNull();
            startParameter!.Value.Should().BeOfType<DateTime>();
            endParameter!.Value.Should().BeOfType<DateTime>();
            ((DateTime)startParameter.Value).Should().Be(DateTime.Parse(startDate));
            ((DateTime)endParameter.Value).Should().Be(DateTime.Parse(endDate));
            result.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].{DBContratosDicInfo.DataTermino} BETWEEN @{DBContratosDicInfo.DataTermino} AND @{DBContratosDicInfo.DataTermino}_end");
        }

        [Fact]
        public void WFiltro_DataTermino_WhenInvalidDateFormat_ShouldNotAddParameter()
        {
            // Arrange
            var invalidDate = "invalid-date";
            var filtro = new FilterContratos
            {
                DataTermino = invalidDate,
                DataTermino_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DataTermino_WhenStartDateValidButEndDateInvalid_ShouldOnlyAddStartParameterAndGenerateSingleDateClause()
        {
            // Arrange
            var validStartDate = "15/06/2023";
            var invalidEndDate = "invalid-date";
            var filtro = new FilterContratos
            {
                DataTermino = validStartDate,
                DataTermino_end = invalidEndDate,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(1);
            var parameter = result.Value.parametros.First();
            parameter.ParameterName.Should().Be($"@{DBContratosDicInfo.DataTermino}");
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.DataTermino}], 103) = CONVERT(DATE, @{DBContratosDicInfo.DataTermino}, 103)");
            result.Value.where.Should().NotContain("BETWEEN");
        }

        [Fact]
        public void WFiltro_DataTermino_WhenStartDateInvalidButEndDateValid_ShouldNotAddAnyParameters()
        {
            // Arrange
            var invalidStartDate = "invalid-date";
            var validEndDate = "30/06/2023";
            var filtro = new FilterContratos
            {
                DataTermino = invalidStartDate,
                DataTermino_end = validEndDate,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DataTermino_WhenWhitespaceOnlyDates_ShouldNotAddParameters()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                DataTermino = "   ",
                DataTermino_end = "\t\n",
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DataTermino_WithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterContratos
            {
                Protestar = "A",
                DataTermino = testDate,
                DataTermino_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(2); // Nome + DataTermino
            result.Value.where.Should().Contain(TSql.And);
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.DataTermino}], 103) = CONVERT(DATE, @{DBContratosDicInfo.DataTermino}, 103)");
        }

        [Fact]
        public void WFiltro_DataTermino_WithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterContratos
            {
                Protestar = "A",
                DataTermino = testDate,
                DataTermino_end = string.Empty,
                LogicalOperator = TSql.OR
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(TSql.OR);
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.DataTermino}], 103) = CONVERT(DATE, @{DBContratosDicInfo.DataTermino}, 103)");
        }

        [Fact]
        public void WFiltro_DataTermino_WhenOnlyEndDateProvided_ShouldNotAddParameters()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                DataTermino = string.Empty,
                DataTermino_end = "30/06/2023",
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DataTermino_WhenDateTimeMinValue_ShouldNotAddParameters()
        {
            // Arrange
            var minValueDate = DateTime.MinValue.ToString("dd/MM/yyyy");
            var filtro = new FilterContratos
            {
                DataTermino = minValueDate,
                DataTermino_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // The IsEmptyDX extension method should catch DateTime.MinValue and return true
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DataTermino_AsFirstFilter_ShouldNotIncludeLogicalOperatorAtStart()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterContratos
            {
                DataTermino = testDate,
                DataTermino_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().NotStartWith(TSql.And);
            result.Value.where.Should().StartWith($"CONVERT(DATE,[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.DataTermino}], 103)");
        }

        [Theory]
        [InlineData("15/06/2023", "2023-06-15T00:00:00")]
        [InlineData("01/01/2024", "2024-01-01T00:00:00")]
        [InlineData("31/12/2022", "2022-12-31T00:00:00")]
        public void WFiltro_DataTermino_WhenVariousValidDateFormats_ShouldParseCorrectly(string inputDate, string expectedDateTimeString)
        {
            // Arrange
            var filtro = new FilterContratos
            {
                DataTermino = inputDate,
                DataTermino_end = string.Empty,
                LogicalOperator = TSql.And
            };
            var expectedDateTime = DateTime.Parse(expectedDateTimeString);
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(1);
            var parameter = result.Value.parametros.First();
            ((DateTime)parameter.Value).Should().Be(expectedDateTime);
        }

#endregion
#endregion
#region Bool Tests
#region OcultarRelatorio Filter Tests
        [Fact]
        public void WFiltro_OcultarRelatorioEqualsIntMinValue_ShouldNotAddParameterOrWhereClause()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                OcultarRelatorio = int.MinValue
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().NotContain(p => p.ParameterName.Contains(DBContratosDicInfo.OcultarRelatorio));
            result.Value.where.Should().NotContain(DBContratosDicInfo.OcultarRelatorio);
        }

        [Fact]
        public void WFiltro_OcultarRelatorioHasValidValue_ShouldAddParameterAndWhereClause()
        {
            // Arrange
            var OcultarRelatorioValue = 1;
            var filtro = new FilterContratos
            {
                OcultarRelatorio = OcultarRelatorioValue,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // Check parameter
            var OcultarRelatorioParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.OcultarRelatorio}");
            OcultarRelatorioParameter.Should().NotBeNull();
            OcultarRelatorioParameter.Value.Should().Be(OcultarRelatorioValue);
            // Check where clause
            result.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.OcultarRelatorio}] = @{DBContratosDicInfo.OcultarRelatorio}");
        }

        [Fact]
        public void WFiltro_OcultarRelatorioWithDifferentValues_ShouldAddCorrectParameterValue()
        {
            // Arrange & Act & Assert for OcultarRelatorio = 0 (typically female)
            var filtroFemale = new FilterContratos
            {
                OcultarRelatorio = 0
            };
            var resultFemale = _service.WFiltro(filtroFemale);
            resultFemale.Should().NotBeNull();
            var femaleParam = resultFemale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.OcultarRelatorio}");
            femaleParam.Should().NotBeNull();
            femaleParam.Value.Should().Be(0);
            // Arrange & Act & Assert for OcultarRelatorio = 1 (typically male)
            var filtroMale = new FilterContratos
            {
                OcultarRelatorio = 1
            };
            var resultMale = _service.WFiltro(filtroMale);
            resultMale.Should().NotBeNull();
            var maleParam = resultMale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.OcultarRelatorio}");
            maleParam.Should().NotBeNull();
            maleParam.Value.Should().Be(1);
        }

        [Fact]
        public void WFiltro_OcultarRelatorioAsFirstFilter_ShouldNotIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                OcultarRelatorio = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().StartWith($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.OcultarRelatorio}] = @{DBContratosDicInfo.OcultarRelatorio}");
            result.Value.where.Should().NotStartWith(" AND ");
        }

        [Fact]
        public void WFiltro_OcultarRelatorioWithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Protestar = "Protestar",
                OcultarRelatorio = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain($" AND ");
        }

        [Fact]
        public void WFiltro_OcultarRelatorioWithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Protestar = "Protestar",
                OcultarRelatorio = 1,
                LogicalOperator = " OR "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(" OR ");
        }

#endregion
#region Avulso Filter Tests
        [Fact]
        public void WFiltro_AvulsoEqualsIntMinValue_ShouldNotAddParameterOrWhereClause()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Avulso = int.MinValue
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().NotContain(p => p.ParameterName.Contains(DBContratosDicInfo.Avulso));
            result.Value.where.Should().NotContain(DBContratosDicInfo.Avulso);
        }

        [Fact]
        public void WFiltro_AvulsoHasValidValue_ShouldAddParameterAndWhereClause()
        {
            // Arrange
            var AvulsoValue = 1;
            var filtro = new FilterContratos
            {
                Avulso = AvulsoValue,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // Check parameter
            var AvulsoParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.Avulso}");
            AvulsoParameter.Should().NotBeNull();
            AvulsoParameter.Value.Should().Be(AvulsoValue);
            // Check where clause
            result.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Avulso}] = @{DBContratosDicInfo.Avulso}");
        }

        [Fact]
        public void WFiltro_AvulsoWithDifferentValues_ShouldAddCorrectParameterValue()
        {
            // Arrange & Act & Assert for Avulso = 0 (typically female)
            var filtroFemale = new FilterContratos
            {
                Avulso = 0
            };
            var resultFemale = _service.WFiltro(filtroFemale);
            resultFemale.Should().NotBeNull();
            var femaleParam = resultFemale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.Avulso}");
            femaleParam.Should().NotBeNull();
            femaleParam.Value.Should().Be(0);
            // Arrange & Act & Assert for Avulso = 1 (typically male)
            var filtroMale = new FilterContratos
            {
                Avulso = 1
            };
            var resultMale = _service.WFiltro(filtroMale);
            resultMale.Should().NotBeNull();
            var maleParam = resultMale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.Avulso}");
            maleParam.Should().NotBeNull();
            maleParam.Value.Should().Be(1);
        }

        [Fact]
        public void WFiltro_AvulsoAsFirstFilter_ShouldNotIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Avulso = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().StartWith($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Avulso}] = @{DBContratosDicInfo.Avulso}");
            result.Value.where.Should().NotStartWith(" AND ");
        }

        [Fact]
        public void WFiltro_AvulsoWithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Protestar = "Protestar",
                Avulso = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain($" AND ");
        }

        [Fact]
        public void WFiltro_AvulsoWithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Protestar = "Protestar",
                Avulso = 1,
                LogicalOperator = " OR "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(" OR ");
        }

#endregion
#region Suspenso Filter Tests
        [Fact]
        public void WFiltro_SuspensoEqualsIntMinValue_ShouldNotAddParameterOrWhereClause()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Suspenso = int.MinValue
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().NotContain(p => p.ParameterName.Contains(DBContratosDicInfo.Suspenso));
            result.Value.where.Should().NotContain(DBContratosDicInfo.Suspenso);
        }

        [Fact]
        public void WFiltro_SuspensoHasValidValue_ShouldAddParameterAndWhereClause()
        {
            // Arrange
            var SuspensoValue = 1;
            var filtro = new FilterContratos
            {
                Suspenso = SuspensoValue,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // Check parameter
            var SuspensoParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.Suspenso}");
            SuspensoParameter.Should().NotBeNull();
            SuspensoParameter.Value.Should().Be(SuspensoValue);
            // Check where clause
            result.Value.where.Should().Contain($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Suspenso}] = @{DBContratosDicInfo.Suspenso}");
        }

        [Fact]
        public void WFiltro_SuspensoWithDifferentValues_ShouldAddCorrectParameterValue()
        {
            // Arrange & Act & Assert for Suspenso = 0 (typically female)
            var filtroFemale = new FilterContratos
            {
                Suspenso = 0
            };
            var resultFemale = _service.WFiltro(filtroFemale);
            resultFemale.Should().NotBeNull();
            var femaleParam = resultFemale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.Suspenso}");
            femaleParam.Should().NotBeNull();
            femaleParam.Value.Should().Be(0);
            // Arrange & Act & Assert for Suspenso = 1 (typically male)
            var filtroMale = new FilterContratos
            {
                Suspenso = 1
            };
            var resultMale = _service.WFiltro(filtroMale);
            resultMale.Should().NotBeNull();
            var maleParam = resultMale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContratosDicInfo.Suspenso}");
            maleParam.Should().NotBeNull();
            maleParam.Value.Should().Be(1);
        }

        [Fact]
        public void WFiltro_SuspensoAsFirstFilter_ShouldNotIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Suspenso = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().StartWith($"[{DBContratosDicInfo.PTabelaNome}].[{DBContratosDicInfo.Suspenso}] = @{DBContratosDicInfo.Suspenso}");
            result.Value.where.Should().NotStartWith(" AND ");
        }

        [Fact]
        public void WFiltro_SuspensoWithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Protestar = "Protestar",
                Suspenso = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain($" AND ");
        }

        [Fact]
        public void WFiltro_SuspensoWithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var filtro = new FilterContratos
            {
                Protestar = "Protestar",
                Suspenso = 1,
                LogicalOperator = " OR "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(" OR ");
        }

#endregion
#endregion
        [Fact]
        public void Dispose_CalledOnce_DisposesCorrectly()
        {
            // Act
            _service.Dispose();
            // Assert - Should not throw any exception
            Assert.True(true);
        }

        [Fact]
        public void Dispose_CalledTwice_DoesNotThrow()
        {
            // Act
            _service.Dispose();
            _service.Dispose();
            // Assert - Should not throw any exception
            Assert.True(true);
        }

        public virtual void Dispose()
        {
            _service?.Dispose();
        }
    }
}