// 100% auto-generated by Source Genesys WebApi Front & Back Creator
// copyright © 2000-2025 Menphis - Sistemas Inteligentes
// This file is part of the Source Genesys project                     
namespace MenphisSI.GerAdv.WFiltro.Tests
{
    public class LigacoesServiceWFiltroTests : IDisposable
    {
        private readonly Mock<IOptions<AppSettings>> _mockAppSettings;
        private readonly Mock<IFLigacoesFactory> _mockLigacoesFactory;
        private readonly Mock<ILigacoesReader> _mockReader;
        private readonly Mock<ILigacoesValidation> _mockValidation;
        private readonly Mock<ILigacoesWriter> _mockWriter;
        private readonly Mock<IClientesReader> _mockClientesReader;
        private readonly Mock<IRamalReader> _mockRamalReader;
        private readonly Mock<IHttpContextAccessor> _mockHttpContextAccessor;
        private readonly Mock<HybridCache> _mockCache;
        private readonly Mock<IMemoryCache> _mockMemoryCache;
        private readonly LigacoesService _service;
        public LigacoesServiceWFiltroTests()
        {
            _mockAppSettings = new Mock<IOptions<AppSettings>>();
            _mockLigacoesFactory = new Mock<IFLigacoesFactory>();
            _mockReader = new Mock<ILigacoesReader>();
            _mockValidation = new Mock<ILigacoesValidation>();
            _mockWriter = new Mock<ILigacoesWriter>();
            _mockClientesReader = new Mock<IClientesReader>();
            _mockRamalReader = new Mock<IRamalReader>();
            _mockHttpContextAccessor = new Mock<IHttpContextAccessor>();
            _mockCache = new Mock<HybridCache>();
            _mockMemoryCache = new Mock<IMemoryCache>();
            var appSettings = new AppSettings();
            _mockAppSettings.Setup(x => x.Value).Returns(appSettings);
            _service = new LigacoesService(_mockAppSettings.Object, _mockLigacoesFactory.Object, _mockReader.Object, _mockValidation.Object, _mockWriter.Object, _mockClientesReader.Object, _mockRamalReader.Object, _mockHttpContextAccessor.Object, _mockCache.Object, _mockMemoryCache.Object);
        }

        [Fact]
        public void WFiltro_QuandoFiltroEhNull_DeveRetornarResultadoVazio()
        {
            // Arrange
            FilterLigacoes? filtro = null;
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().BeNull();
        }

        [Fact]
        public void WFiltro_QuandoTodosCamposSaoValoresPadrao_DeveRetornarResultadoVazio()
        {
            // Arrange
            var filtro = new FilterLigacoes(); // Todos os valores padrão
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_ComTodosOsCamposPreenchidos_DeveProcessarRapidamente()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Assunto = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
                AgeClienteAvisado = 1,
                Celular = 2,
                Cliente = 1,
                Contato = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
                DataRealizada = "24/04/1975",
                QuemID = 1,
                Telefonista = 1,
                UltimoAviso = "24/04/1975",
                HoraFinal = "27/05/2022",
                Nome = "João",
                QuemCodigo = 1,
                Solicitante = 1,
                Para = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
                Fone = "(11) 99999-9999",
                Ramal = 1,
                Particular = 1,
                Realizada = 2,
                Status = "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM",
                Data = "27/05/2022",
                Hora = "27/05/2022",
                Urgente = 1,
                LigarPara = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
                Processo = 1,
                StartScreen = 2,
                Emotion = 1,
                GUID = Guid.NewGuid().ToString(),
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var stopwatch = System.Diagnostics.Stopwatch.StartNew();
            var resultado = _service.WFiltro(filtro);
            stopwatch.Stop();
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().NotBeEmpty();
            resultado.Value.where.Should().NotBeEmpty();
            stopwatch.ElapsedMilliseconds.Should().BeLessThan(100); // Deve processar em menos de 100ms
        }

#region String Tests
        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_Assunto_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string assuntoComWhitespace)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Assunto = assuntoComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_Assunto_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var assuntoGigante = new string ('A', 1000);
            var filtro = new FilterLigacoes
            {
                Assunto = assuntoGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{assuntoGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_Assunto_ComCaracteresEspeciais_DeveProcessarCorretamente(string assuntoComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Assunto = assuntoComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(assuntoComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_AssuntoLigacoes_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Assunto = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_AssuntoLigacoes_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Assunto = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_AssuntoLigacoes_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeLigacoes = "João Silva";
            var filtro = new FilterLigacoes
            {
                Assunto = nomeLigacoes,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_AssuntoLigacoes_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Assunto = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_AssuntoLigacoes_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Assunto = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_AssuntoLigacoes_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeLigacoes)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Assunto = nomeLigacoes,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_AssuntoLigacoes_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Assunto = "João",
                AgeClienteAvisado = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@ligAssunto");
            resultado.Value.where.Should().Contain("@ligAgeClienteAvisado");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @ligAssunto");
            resultado.Value.where.Should().Contain("= @ligAgeClienteAvisado");
        }

        [Fact]
        public void WFiltro_AssuntoLigacoes_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeLigacoes = "João Silva";
            var filtro = new FilterLigacoes
            {
                Assunto = nomeLigacoes,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Assunto}]");
            resultado.Value.where.Should().Contain("like @ligAssunto");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@ligAssunto");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_Contato_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string contatoComWhitespace)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Contato = contatoComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_Contato_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var contatoGigante = new string ('A', 1000);
            var filtro = new FilterLigacoes
            {
                Contato = contatoGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{contatoGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_Contato_ComCaracteresEspeciais_DeveProcessarCorretamente(string contatoComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Contato = contatoComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(contatoComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_ContatoLigacoes_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Contato = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_ContatoLigacoes_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Contato = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_ContatoLigacoes_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeLigacoes = "João Silva";
            var filtro = new FilterLigacoes
            {
                Contato = nomeLigacoes,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_ContatoLigacoes_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Contato = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_ContatoLigacoes_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Contato = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_ContatoLigacoes_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeLigacoes)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Contato = nomeLigacoes,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_ContatoLigacoes_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Contato = "João",
                AgeClienteAvisado = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@ligContato");
            resultado.Value.where.Should().Contain("@ligAgeClienteAvisado");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @ligContato");
            resultado.Value.where.Should().Contain("= @ligAgeClienteAvisado");
        }

        [Fact]
        public void WFiltro_ContatoLigacoes_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeLigacoes = "João Silva";
            var filtro = new FilterLigacoes
            {
                Contato = nomeLigacoes,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Contato}]");
            resultado.Value.where.Should().Contain("like @ligContato");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@ligContato");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Fact]
        public void WFiltro_HoraFinalLigacoes_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                HoraFinal = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_HoraFinalLigacoes_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                HoraFinal = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_HoraFinalLigacoes_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeLigacoes = "João Silva";
            var filtro = new FilterLigacoes
            {
                HoraFinal = nomeLigacoes,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_HoraFinalLigacoes_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                HoraFinal = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_HoraFinalLigacoes_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                HoraFinal = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_HoraFinalLigacoes_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeLigacoes)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                HoraFinal = nomeLigacoes,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_HoraFinalLigacoes_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                HoraFinal = "João",
                AgeClienteAvisado = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@ligHoraFinal");
            resultado.Value.where.Should().Contain("@ligAgeClienteAvisado");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @ligHoraFinal");
            resultado.Value.where.Should().Contain("= @ligAgeClienteAvisado");
        }

        [Fact]
        public void WFiltro_HoraFinalLigacoes_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeLigacoes = "João Silva";
            var filtro = new FilterLigacoes
            {
                HoraFinal = nomeLigacoes,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.HoraFinal}]");
            resultado.Value.where.Should().Contain("like @ligHoraFinal");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@ligHoraFinal");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Fact]
        public void WFiltro_Nome_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado = 1,
                Nome = "João",
                LogicalOperator = null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltroNome_LogicalOperatorVazioOuNulo_DeveUsarAndPorPadrao(string logicalOperator)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Nome = "João",
                AgeClienteAvisado = 2,
                LogicalOperator = logicalOperator
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_Nome_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string nomeComWhitespace)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Nome = nomeComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_Nome_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var nomeGigante = new string ('A', 1000);
            var filtro = new FilterLigacoes
            {
                Nome = nomeGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{nomeGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_Nome_ComCaracteresEspeciais_DeveProcessarCorretamente(string nomeComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Nome = nomeComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(nomeComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_NomeLigacoes_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Nome = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_NomeLigacoes_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Nome = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_NomeLigacoes_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeLigacoes = "João Silva";
            var filtro = new FilterLigacoes
            {
                Nome = nomeLigacoes,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_NomeLigacoes_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Nome = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_NomeLigacoes_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Nome = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_NomeLigacoes_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeLigacoes)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Nome = nomeLigacoes,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_NomeLigacoes_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Nome = "João",
                AgeClienteAvisado = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@ligNome");
            resultado.Value.where.Should().Contain("@ligAgeClienteAvisado");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @ligNome");
            resultado.Value.where.Should().Contain("= @ligAgeClienteAvisado");
        }

        [Fact]
        public void WFiltro_NomeLigacoes_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeLigacoes = "João Silva";
            var filtro = new FilterLigacoes
            {
                Nome = nomeLigacoes,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Nome}]");
            resultado.Value.where.Should().Contain("like @ligNome");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@ligNome");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_Para_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string paraComWhitespace)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Para = paraComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_Para_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var paraGigante = new string ('A', 1000);
            var filtro = new FilterLigacoes
            {
                Para = paraGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{paraGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_Para_ComCaracteresEspeciais_DeveProcessarCorretamente(string paraComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Para = paraComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(paraComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_ParaLigacoes_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Para = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_ParaLigacoes_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Para = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_ParaLigacoes_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeLigacoes = "João Silva";
            var filtro = new FilterLigacoes
            {
                Para = nomeLigacoes,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_ParaLigacoes_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Para = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_ParaLigacoes_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Para = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_ParaLigacoes_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeLigacoes)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Para = nomeLigacoes,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_ParaLigacoes_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Para = "João",
                AgeClienteAvisado = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@ligPara");
            resultado.Value.where.Should().Contain("@ligAgeClienteAvisado");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @ligPara");
            resultado.Value.where.Should().Contain("= @ligAgeClienteAvisado");
        }

        [Fact]
        public void WFiltro_ParaLigacoes_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeLigacoes = "João Silva";
            var filtro = new FilterLigacoes
            {
                Para = nomeLigacoes,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Para}]");
            resultado.Value.where.Should().Contain("like @ligPara");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@ligPara");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_Fone_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string foneComWhitespace)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Fone = foneComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_Fone_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var foneGigante = new string ('A', 1000);
            var filtro = new FilterLigacoes
            {
                Fone = foneGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{foneGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_Fone_ComCaracteresEspeciais_DeveProcessarCorretamente(string foneComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Fone = foneComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(foneComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_FoneLigacoes_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Fone = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_FoneLigacoes_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Fone = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_FoneLigacoes_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeLigacoes = "João Silva";
            var filtro = new FilterLigacoes
            {
                Fone = nomeLigacoes,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_FoneLigacoes_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Fone = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_FoneLigacoes_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Fone = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_FoneLigacoes_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeLigacoes)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Fone = nomeLigacoes,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_FoneLigacoes_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Fone = "João",
                AgeClienteAvisado = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@ligFone");
            resultado.Value.where.Should().Contain("@ligAgeClienteAvisado");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @ligFone");
            resultado.Value.where.Should().Contain("= @ligAgeClienteAvisado");
        }

        [Fact]
        public void WFiltro_FoneLigacoes_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeLigacoes = "João Silva";
            var filtro = new FilterLigacoes
            {
                Fone = nomeLigacoes,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Fone}]");
            resultado.Value.where.Should().Contain("like @ligFone");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@ligFone");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_Status_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string statusComWhitespace)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Status = statusComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_Status_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var statusGigante = new string ('A', 1000);
            var filtro = new FilterLigacoes
            {
                Status = statusGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{statusGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_Status_ComCaracteresEspeciais_DeveProcessarCorretamente(string statusComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Status = statusComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(statusComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_StatusLigacoes_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Status = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_StatusLigacoes_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Status = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_StatusLigacoes_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeLigacoes = "João Silva";
            var filtro = new FilterLigacoes
            {
                Status = nomeLigacoes,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_StatusLigacoes_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Status = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_StatusLigacoes_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Status = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_StatusLigacoes_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeLigacoes)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Status = nomeLigacoes,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_StatusLigacoes_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Status = "João",
                AgeClienteAvisado = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@ligStatus");
            resultado.Value.where.Should().Contain("@ligAgeClienteAvisado");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @ligStatus");
            resultado.Value.where.Should().Contain("= @ligAgeClienteAvisado");
        }

        [Fact]
        public void WFiltro_StatusLigacoes_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeLigacoes = "João Silva";
            var filtro = new FilterLigacoes
            {
                Status = nomeLigacoes,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Status}]");
            resultado.Value.where.Should().Contain("like @ligStatus");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@ligStatus");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Fact]
        public void WFiltro_DataLigacoes_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Data = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_DataLigacoes_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Data = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_DataLigacoes_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeLigacoes = "João Silva";
            var filtro = new FilterLigacoes
            {
                Data = nomeLigacoes,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_DataLigacoes_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Data = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_DataLigacoes_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Data = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_DataLigacoes_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeLigacoes)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Data = nomeLigacoes,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DataLigacoes_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Data = "João",
                AgeClienteAvisado = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@ligData");
            resultado.Value.where.Should().Contain("@ligAgeClienteAvisado");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @ligData");
            resultado.Value.where.Should().Contain("= @ligAgeClienteAvisado");
        }

        [Fact]
        public void WFiltro_DataLigacoes_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeLigacoes = "João Silva";
            var filtro = new FilterLigacoes
            {
                Data = nomeLigacoes,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Data}]");
            resultado.Value.where.Should().Contain("like @ligData");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@ligData");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Fact]
        public void WFiltro_HoraLigacoes_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Hora = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_HoraLigacoes_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Hora = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_HoraLigacoes_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeLigacoes = "João Silva";
            var filtro = new FilterLigacoes
            {
                Hora = nomeLigacoes,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_HoraLigacoes_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Hora = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_HoraLigacoes_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Hora = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_HoraLigacoes_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeLigacoes)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Hora = nomeLigacoes,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_HoraLigacoes_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Hora = "João",
                AgeClienteAvisado = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@ligHora");
            resultado.Value.where.Should().Contain("@ligAgeClienteAvisado");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @ligHora");
            resultado.Value.where.Should().Contain("= @ligAgeClienteAvisado");
        }

        [Fact]
        public void WFiltro_HoraLigacoes_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeLigacoes = "João Silva";
            var filtro = new FilterLigacoes
            {
                Hora = nomeLigacoes,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Hora}]");
            resultado.Value.where.Should().Contain("like @ligHora");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@ligHora");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_LigarPara_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string ligarparaComWhitespace)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                LigarPara = ligarparaComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_LigarPara_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var ligarparaGigante = new string ('A', 1000);
            var filtro = new FilterLigacoes
            {
                LigarPara = ligarparaGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{ligarparaGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_LigarPara_ComCaracteresEspeciais_DeveProcessarCorretamente(string ligarparaComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                LigarPara = ligarparaComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(ligarparaComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_LigarParaLigacoes_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                LigarPara = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_LigarParaLigacoes_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                LigarPara = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_LigarParaLigacoes_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeLigacoes = "João Silva";
            var filtro = new FilterLigacoes
            {
                LigarPara = nomeLigacoes,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_LigarParaLigacoes_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                LigarPara = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_LigarParaLigacoes_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                LigarPara = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_LigarParaLigacoes_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeLigacoes)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                LigarPara = nomeLigacoes,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_LigarParaLigacoes_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                LigarPara = "João",
                AgeClienteAvisado = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@ligLigarPara");
            resultado.Value.where.Should().Contain("@ligAgeClienteAvisado");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @ligLigarPara");
            resultado.Value.where.Should().Contain("= @ligAgeClienteAvisado");
        }

        [Fact]
        public void WFiltro_LigarParaLigacoes_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeLigacoes = "João Silva";
            var filtro = new FilterLigacoes
            {
                LigarPara = nomeLigacoes,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.LigarPara}]");
            resultado.Value.where.Should().Contain("like @ligLigarPara");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@ligLigarPara");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_GUID_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string guidComWhitespace)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                GUID = guidComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_GUID_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var guidGigante = new string ('A', 1000);
            var filtro = new FilterLigacoes
            {
                GUID = guidGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{guidGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_GUID_ComCaracteresEspeciais_DeveProcessarCorretamente(string guidComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                GUID = guidComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(guidComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_GUIDLigacoes_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                GUID = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_GUIDLigacoes_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                GUID = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_GUIDLigacoes_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeLigacoes = "João Silva";
            var filtro = new FilterLigacoes
            {
                GUID = nomeLigacoes,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_GUIDLigacoes_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                GUID = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_GUIDLigacoes_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                GUID = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_GUIDLigacoes_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeLigacoes)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                GUID = nomeLigacoes,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_GUIDLigacoes_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                GUID = "João",
                AgeClienteAvisado = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@ligGUID");
            resultado.Value.where.Should().Contain("@ligAgeClienteAvisado");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @ligGUID");
            resultado.Value.where.Should().Contain("= @ligAgeClienteAvisado");
        }

        [Fact]
        public void WFiltro_GUIDLigacoes_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeLigacoes = "João Silva";
            var filtro = new FilterLigacoes
            {
                GUID = nomeLigacoes,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.GUID}]");
            resultado.Value.where.Should().Contain("like @ligGUID");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@ligGUID");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

#endregion
#region Integer Tests
#region filtro.AgeClienteAvisado_end Tests
        [Fact]
        public void WFiltro_AgeClienteAvisado_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_AgeClienteAvisado_end_QuandoTemValorPositivo_SemAgeClienteAvisadoInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorAgeClienteAvisadoEnd = 5000;
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado = int.MinValue, // Não define salário inicial
                AgeClienteAvisado_end = valorAgeClienteAvisadoEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há AgeClienteAvisado inicial válido, não deve incluir condição WHERE, mas o parâmetro AgeClienteAvisado_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // AgeClienteAvisado_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_AgeClienteAvisado_end_QuandoSomenteValorInicial_SemAgeClienteAvisadoEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorAgeClienteAvisado = 2500;
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado = valorAgeClienteAvisado,
                AgeClienteAvisado_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.AgeClienteAvisado}] = @{DBLigacoesDicInfo.AgeClienteAvisado}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBLigacoesDicInfo.AgeClienteAvisado}");
            parametro.Value.Should().Be(valorAgeClienteAvisado);
        }

        [Fact]
        public void WFiltro_AgeClienteAvisado_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorAgeClienteAvisadoInicial = 1000;
            var valorAgeClienteAvisadoFinal = 5000;
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado = valorAgeClienteAvisadoInicial,
                AgeClienteAvisado_end = valorAgeClienteAvisadoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].{DBLigacoesDicInfo.AgeClienteAvisado} BETWEEN @{DBLigacoesDicInfo.AgeClienteAvisado} AND @{DBLigacoesDicInfo.AgeClienteAvisado}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.AgeClienteAvisado}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.AgeClienteAvisado}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorAgeClienteAvisadoInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorAgeClienteAvisadoFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_AgeClienteAvisado_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado = valorInicial,
                AgeClienteAvisado_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.AgeClienteAvisado}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.AgeClienteAvisado}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_AgeClienteAvisado_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado = 1000,
                AgeClienteAvisado_end = 5000,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.AgeClienteAvisado}");
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Contato}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_AgeClienteAvisado_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado = 1000,
                AgeClienteAvisado_end = 5000,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_AgeClienteAvisado_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado = 1000,
                AgeClienteAvisado_end = 5000,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_AgeClienteAvisado_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado = 1000,
                AgeClienteAvisado_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].{DBLigacoesDicInfo.AgeClienteAvisado} BETWEEN");
        }

        [Fact]
        public void WFiltro_AgeClienteAvisado_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado = 1000,
                AgeClienteAvisado_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_AgeClienteAvisado_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado = 1000,
                AgeClienteAvisado_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_AgeClienteAvisado_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorAgeClienteAvisadoInicial = 2500;
            var valorAgeClienteAvisadoFinal = 4750;
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado = valorAgeClienteAvisadoInicial,
                AgeClienteAvisado_end = valorAgeClienteAvisadoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.AgeClienteAvisado}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.AgeClienteAvisado}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorAgeClienteAvisadoInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorAgeClienteAvisadoFinal);
        }

        [Fact]
        public void WFiltro_AgeClienteAvisado_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado = 0,
                AgeClienteAvisado_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_AgeClienteAvisado_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado = 0,
                AgeClienteAvisado_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_AgeClienteAvisado_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado = 1500,
                AgeClienteAvisado_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.AgeClienteAvisado == int.MinValue) && !(filtro.AgeClienteAvisado_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBLigacoesDicInfo.PTabelaNome}].{DBLigacoesDicInfo.AgeClienteAvisado} BETWEEN @{DBLigacoesDicInfo.AgeClienteAvisado} AND @{DBLigacoesDicInfo.AgeClienteAvisado}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_AgeClienteAvisado_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado = 2000,
                AgeClienteAvisado_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.AgeClienteAvisado == int.MinValue) && filtro.AgeClienteAvisado_end == int.MinValue
            // Deve resultar em igualdade quando apenas AgeClienteAvisado tem valor válido
            resultado.Value.where.Should().Be($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.AgeClienteAvisado}] = @{DBLigacoesDicInfo.AgeClienteAvisado}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_AgeClienteAvisado_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.AgeClienteAvisado Isolated Tests
        [Fact]
        public void WFiltro_AgeClienteAvisado_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_AgeClienteAvisado_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorAgeClienteAvisado = 5;
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado = valorAgeClienteAvisado,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.AgeClienteAvisado}] = @{DBLigacoesDicInfo.AgeClienteAvisado}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBLigacoesDicInfo.AgeClienteAvisado}");
            parametro.Value.Should().Be(valorAgeClienteAvisado);
        }

        [Fact]
        public void WFiltro_AgeClienteAvisado_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorAgeClienteAvisado = 0;
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado = valorAgeClienteAvisado,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBLigacoesDicInfo.AgeClienteAvisado}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorAgeClienteAvisado);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_AgeClienteAvisado_DiferentesValoresValidos_DeveProcessarCorretamente(int valorAgeClienteAvisado)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado = valorAgeClienteAvisado,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorAgeClienteAvisado);
            resultado.Value.where.Should().Contain($"= @{DBLigacoesDicInfo.AgeClienteAvisado}");
        }

        [Fact]
        public void WFiltro_AgeClienteAvisado_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.AgeClienteAvisado}");
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Contato}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_AgeClienteAvisado_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_AgeClienteAvisado_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_AgeClienteAvisado_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_AgeClienteAvisado_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.AgeClienteAvisado}]");
        }

        [Fact]
        public void WFiltro_AgeClienteAvisado_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_AgeClienteAvisado_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_AgeClienteAvisado_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_AgeClienteAvisado_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorAgeClienteAvisado = 42;
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado = valorAgeClienteAvisado,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorAgeClienteAvisado);
        }

#endregion
        [Fact]
        public void WFiltro_AgeClienteAvisado_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_AgeClienteAvisado_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorAgeClienteAvisado = 1;
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado = valorAgeClienteAvisado,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do AgeClienteAvisado
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.AgeClienteAvisado}] = @ligAgeClienteAvisado");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@ligAgeClienteAvisado");
            parametro.Value.Should().Be(valorAgeClienteAvisado);
        }

        [Fact]
        public void WFiltro_AgeClienteAvisado_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@ligAgeClienteAvisado");
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Contato}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_AgeClienteAvisado_DiferentesValores_DeveFuncionar(int valorAgeClienteAvisado)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                AgeClienteAvisado = valorAgeClienteAvisado,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorAgeClienteAvisado);
        }

#region filtro.Cliente_end Tests
        [Fact]
        public void WFiltro_Cliente_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Cliente_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Cliente_end_QuandoTemValorPositivo_SemClienteInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorClienteEnd = 5000;
            var filtro = new FilterLigacoes
            {
                Cliente = int.MinValue, // Não define salário inicial
                Cliente_end = valorClienteEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Cliente inicial válido, não deve incluir condição WHERE, mas o parâmetro Cliente_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Cliente_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Cliente_end_QuandoSomenteValorInicial_SemClienteEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorCliente = 2500;
            var filtro = new FilterLigacoes
            {
                Cliente = valorCliente,
                Cliente_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Cliente}] = @{DBLigacoesDicInfo.Cliente}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBLigacoesDicInfo.Cliente}");
            parametro.Value.Should().Be(valorCliente);
        }

        [Fact]
        public void WFiltro_Cliente_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorClienteInicial = 1000;
            var valorClienteFinal = 5000;
            var filtro = new FilterLigacoes
            {
                Cliente = valorClienteInicial,
                Cliente_end = valorClienteFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].{DBLigacoesDicInfo.Cliente} BETWEEN @{DBLigacoesDicInfo.Cliente} AND @{DBLigacoesDicInfo.Cliente}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.Cliente}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.Cliente}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorClienteInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorClienteFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Cliente_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Cliente = valorInicial,
                Cliente_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.Cliente}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.Cliente}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Cliente_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Cliente = 1000,
                Cliente_end = 5000,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Cliente}");
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Contato}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Cliente_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Cliente = 1000,
                Cliente_end = 5000,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Cliente_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Cliente = 1000,
                Cliente_end = 5000,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Cliente_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Cliente = 1000,
                Cliente_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].{DBLigacoesDicInfo.Cliente} BETWEEN");
        }

        [Fact]
        public void WFiltro_Cliente_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Cliente = 1000,
                Cliente_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Cliente_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Cliente = 1000,
                Cliente_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Cliente_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorClienteInicial = 2500;
            var valorClienteFinal = 4750;
            var filtro = new FilterLigacoes
            {
                Cliente = valorClienteInicial,
                Cliente_end = valorClienteFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.Cliente}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.Cliente}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorClienteInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorClienteFinal);
        }

        [Fact]
        public void WFiltro_Cliente_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Cliente = 0,
                Cliente_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Cliente_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Cliente = 0,
                Cliente_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Cliente_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Cliente = 1500,
                Cliente_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Cliente == int.MinValue) && !(filtro.Cliente_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBLigacoesDicInfo.PTabelaNome}].{DBLigacoesDicInfo.Cliente} BETWEEN @{DBLigacoesDicInfo.Cliente} AND @{DBLigacoesDicInfo.Cliente}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Cliente_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Cliente = 2000,
                Cliente_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Cliente == int.MinValue) && filtro.Cliente_end == int.MinValue
            // Deve resultar em igualdade quando apenas Cliente tem valor válido
            resultado.Value.where.Should().Be($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Cliente}] = @{DBLigacoesDicInfo.Cliente}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Cliente_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Cliente = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Cliente Isolated Tests
        [Fact]
        public void WFiltro_Cliente_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Cliente = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Cliente_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorCliente = 5;
            var filtro = new FilterLigacoes
            {
                Cliente = valorCliente,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Cliente}] = @{DBLigacoesDicInfo.Cliente}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBLigacoesDicInfo.Cliente}");
            parametro.Value.Should().Be(valorCliente);
        }

        [Fact]
        public void WFiltro_Cliente_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorCliente = 0;
            var filtro = new FilterLigacoes
            {
                Cliente = valorCliente,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBLigacoesDicInfo.Cliente}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCliente);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Cliente_DiferentesValoresValidos_DeveProcessarCorretamente(int valorCliente)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Cliente = valorCliente,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCliente);
            resultado.Value.where.Should().Contain($"= @{DBLigacoesDicInfo.Cliente}");
        }

        [Fact]
        public void WFiltro_Cliente_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Cliente = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Cliente}");
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Contato}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Cliente_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Cliente = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Cliente_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Cliente = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Cliente_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Cliente = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Cliente_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Cliente = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Cliente}]");
        }

        [Fact]
        public void WFiltro_Cliente_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Cliente = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Cliente_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Cliente = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Cliente_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Cliente = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Cliente_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorCliente = 42;
            var filtro = new FilterLigacoes
            {
                Cliente = valorCliente,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorCliente);
        }

#endregion
        [Fact]
        public void WFiltro_Cliente_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Cliente = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Cliente_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorCliente = 1;
            var filtro = new FilterLigacoes
            {
                Cliente = valorCliente,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Cliente
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Cliente}] = @ligCliente");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@ligCliente");
            parametro.Value.Should().Be(valorCliente);
        }

        [Fact]
        public void WFiltro_Cliente_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Cliente = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@ligCliente");
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Contato}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Cliente_DiferentesValores_DeveFuncionar(int valorCliente)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Cliente = valorCliente,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCliente);
        }

#region filtro.QuemID_end Tests
        [Fact]
        public void WFiltro_QuemID_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemID_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_QuemID_end_QuandoTemValorPositivo_SemQuemIDInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorQuemIDEnd = 5000;
            var filtro = new FilterLigacoes
            {
                QuemID = int.MinValue, // Não define salário inicial
                QuemID_end = valorQuemIDEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há QuemID inicial válido, não deve incluir condição WHERE, mas o parâmetro QuemID_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // QuemID_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_QuemID_end_QuandoSomenteValorInicial_SemQuemIDEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorQuemID = 2500;
            var filtro = new FilterLigacoes
            {
                QuemID = valorQuemID,
                QuemID_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.QuemID}] = @{DBLigacoesDicInfo.QuemID}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBLigacoesDicInfo.QuemID}");
            parametro.Value.Should().Be(valorQuemID);
        }

        [Fact]
        public void WFiltro_QuemID_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorQuemIDInicial = 1000;
            var valorQuemIDFinal = 5000;
            var filtro = new FilterLigacoes
            {
                QuemID = valorQuemIDInicial,
                QuemID_end = valorQuemIDFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].{DBLigacoesDicInfo.QuemID} BETWEEN @{DBLigacoesDicInfo.QuemID} AND @{DBLigacoesDicInfo.QuemID}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.QuemID}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.QuemID}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorQuemIDInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorQuemIDFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_QuemID_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemID = valorInicial,
                QuemID_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.QuemID}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.QuemID}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_QuemID_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemID = 1000,
                QuemID_end = 5000,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.QuemID}");
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Contato}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_QuemID_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemID = 1000,
                QuemID_end = 5000,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_QuemID_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemID = 1000,
                QuemID_end = 5000,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_QuemID_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemID = 1000,
                QuemID_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].{DBLigacoesDicInfo.QuemID} BETWEEN");
        }

        [Fact]
        public void WFiltro_QuemID_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemID = 1000,
                QuemID_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_QuemID_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemID = 1000,
                QuemID_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_QuemID_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorQuemIDInicial = 2500;
            var valorQuemIDFinal = 4750;
            var filtro = new FilterLigacoes
            {
                QuemID = valorQuemIDInicial,
                QuemID_end = valorQuemIDFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.QuemID}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.QuemID}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorQuemIDInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorQuemIDFinal);
        }

        [Fact]
        public void WFiltro_QuemID_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemID = 0,
                QuemID_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_QuemID_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemID = 0,
                QuemID_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_QuemID_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemID = 1500,
                QuemID_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.QuemID == int.MinValue) && !(filtro.QuemID_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBLigacoesDicInfo.PTabelaNome}].{DBLigacoesDicInfo.QuemID} BETWEEN @{DBLigacoesDicInfo.QuemID} AND @{DBLigacoesDicInfo.QuemID}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_QuemID_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemID = 2000,
                QuemID_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.QuemID == int.MinValue) && filtro.QuemID_end == int.MinValue
            // Deve resultar em igualdade quando apenas QuemID tem valor válido
            resultado.Value.where.Should().Be($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.QuemID}] = @{DBLigacoesDicInfo.QuemID}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_QuemID_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemID = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.QuemID Isolated Tests
        [Fact]
        public void WFiltro_QuemID_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemID = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_QuemID_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorQuemID = 5;
            var filtro = new FilterLigacoes
            {
                QuemID = valorQuemID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.QuemID}] = @{DBLigacoesDicInfo.QuemID}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBLigacoesDicInfo.QuemID}");
            parametro.Value.Should().Be(valorQuemID);
        }

        [Fact]
        public void WFiltro_QuemID_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorQuemID = 0;
            var filtro = new FilterLigacoes
            {
                QuemID = valorQuemID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBLigacoesDicInfo.QuemID}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorQuemID);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_QuemID_DiferentesValoresValidos_DeveProcessarCorretamente(int valorQuemID)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemID = valorQuemID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorQuemID);
            resultado.Value.where.Should().Contain($"= @{DBLigacoesDicInfo.QuemID}");
        }

        [Fact]
        public void WFiltro_QuemID_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemID = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.QuemID}");
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Contato}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_QuemID_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemID = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_QuemID_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemID = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_QuemID_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemID = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_QuemID_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemID = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.QuemID}]");
        }

        [Fact]
        public void WFiltro_QuemID_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemID = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_QuemID_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemID = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_QuemID_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemID = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_QuemID_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorQuemID = 42;
            var filtro = new FilterLigacoes
            {
                QuemID = valorQuemID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorQuemID);
        }

#endregion
        [Fact]
        public void WFiltro_QuemID_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemID = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_QuemID_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorQuemID = 1;
            var filtro = new FilterLigacoes
            {
                QuemID = valorQuemID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do QuemID
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.QuemID}] = @ligQuemID");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@ligQuemID");
            parametro.Value.Should().Be(valorQuemID);
        }

        [Fact]
        public void WFiltro_QuemID_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemID = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@ligQuemID");
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Contato}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_QuemID_DiferentesValores_DeveFuncionar(int valorQuemID)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemID = valorQuemID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorQuemID);
        }

#region filtro.Telefonista_end Tests
        [Fact]
        public void WFiltro_Telefonista_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Telefonista_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Telefonista_end_QuandoTemValorPositivo_SemTelefonistaInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorTelefonistaEnd = 5000;
            var filtro = new FilterLigacoes
            {
                Telefonista = int.MinValue, // Não define salário inicial
                Telefonista_end = valorTelefonistaEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Telefonista inicial válido, não deve incluir condição WHERE, mas o parâmetro Telefonista_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Telefonista_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Telefonista_end_QuandoSomenteValorInicial_SemTelefonistaEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorTelefonista = 2500;
            var filtro = new FilterLigacoes
            {
                Telefonista = valorTelefonista,
                Telefonista_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Telefonista}] = @{DBLigacoesDicInfo.Telefonista}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBLigacoesDicInfo.Telefonista}");
            parametro.Value.Should().Be(valorTelefonista);
        }

        [Fact]
        public void WFiltro_Telefonista_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorTelefonistaInicial = 1000;
            var valorTelefonistaFinal = 5000;
            var filtro = new FilterLigacoes
            {
                Telefonista = valorTelefonistaInicial,
                Telefonista_end = valorTelefonistaFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].{DBLigacoesDicInfo.Telefonista} BETWEEN @{DBLigacoesDicInfo.Telefonista} AND @{DBLigacoesDicInfo.Telefonista}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.Telefonista}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.Telefonista}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorTelefonistaInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorTelefonistaFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Telefonista_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Telefonista = valorInicial,
                Telefonista_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.Telefonista}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.Telefonista}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Telefonista_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Telefonista = 1000,
                Telefonista_end = 5000,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Telefonista}");
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Contato}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Telefonista_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Telefonista = 1000,
                Telefonista_end = 5000,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Telefonista_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Telefonista = 1000,
                Telefonista_end = 5000,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Telefonista_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Telefonista = 1000,
                Telefonista_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].{DBLigacoesDicInfo.Telefonista} BETWEEN");
        }

        [Fact]
        public void WFiltro_Telefonista_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Telefonista = 1000,
                Telefonista_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Telefonista_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Telefonista = 1000,
                Telefonista_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Telefonista_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorTelefonistaInicial = 2500;
            var valorTelefonistaFinal = 4750;
            var filtro = new FilterLigacoes
            {
                Telefonista = valorTelefonistaInicial,
                Telefonista_end = valorTelefonistaFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.Telefonista}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.Telefonista}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorTelefonistaInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorTelefonistaFinal);
        }

        [Fact]
        public void WFiltro_Telefonista_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Telefonista = 0,
                Telefonista_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Telefonista_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Telefonista = 0,
                Telefonista_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Telefonista_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Telefonista = 1500,
                Telefonista_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Telefonista == int.MinValue) && !(filtro.Telefonista_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBLigacoesDicInfo.PTabelaNome}].{DBLigacoesDicInfo.Telefonista} BETWEEN @{DBLigacoesDicInfo.Telefonista} AND @{DBLigacoesDicInfo.Telefonista}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Telefonista_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Telefonista = 2000,
                Telefonista_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Telefonista == int.MinValue) && filtro.Telefonista_end == int.MinValue
            // Deve resultar em igualdade quando apenas Telefonista tem valor válido
            resultado.Value.where.Should().Be($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Telefonista}] = @{DBLigacoesDicInfo.Telefonista}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Telefonista_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Telefonista = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Telefonista Isolated Tests
        [Fact]
        public void WFiltro_Telefonista_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Telefonista = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Telefonista_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorTelefonista = 5;
            var filtro = new FilterLigacoes
            {
                Telefonista = valorTelefonista,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Telefonista}] = @{DBLigacoesDicInfo.Telefonista}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBLigacoesDicInfo.Telefonista}");
            parametro.Value.Should().Be(valorTelefonista);
        }

        [Fact]
        public void WFiltro_Telefonista_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorTelefonista = 0;
            var filtro = new FilterLigacoes
            {
                Telefonista = valorTelefonista,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBLigacoesDicInfo.Telefonista}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorTelefonista);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Telefonista_DiferentesValoresValidos_DeveProcessarCorretamente(int valorTelefonista)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Telefonista = valorTelefonista,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorTelefonista);
            resultado.Value.where.Should().Contain($"= @{DBLigacoesDicInfo.Telefonista}");
        }

        [Fact]
        public void WFiltro_Telefonista_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Telefonista = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Telefonista}");
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Contato}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Telefonista_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Telefonista = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Telefonista_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Telefonista = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Telefonista_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Telefonista = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Telefonista_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Telefonista = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Telefonista}]");
        }

        [Fact]
        public void WFiltro_Telefonista_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Telefonista = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Telefonista_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Telefonista = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Telefonista_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Telefonista = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Telefonista_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorTelefonista = 42;
            var filtro = new FilterLigacoes
            {
                Telefonista = valorTelefonista,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorTelefonista);
        }

#endregion
        [Fact]
        public void WFiltro_Telefonista_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Telefonista = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Telefonista_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorTelefonista = 1;
            var filtro = new FilterLigacoes
            {
                Telefonista = valorTelefonista,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Telefonista
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Telefonista}] = @ligTelefonista");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@ligTelefonista");
            parametro.Value.Should().Be(valorTelefonista);
        }

        [Fact]
        public void WFiltro_Telefonista_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Telefonista = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@ligTelefonista");
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Contato}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Telefonista_DiferentesValores_DeveFuncionar(int valorTelefonista)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Telefonista = valorTelefonista,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorTelefonista);
        }

#region filtro.QuemCodigo_end Tests
        [Fact]
        public void WFiltro_QuemCodigo_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemCodigo_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_QuemCodigo_end_QuandoTemValorPositivo_SemQuemCodigoInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorQuemCodigoEnd = 5000;
            var filtro = new FilterLigacoes
            {
                QuemCodigo = int.MinValue, // Não define salário inicial
                QuemCodigo_end = valorQuemCodigoEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há QuemCodigo inicial válido, não deve incluir condição WHERE, mas o parâmetro QuemCodigo_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // QuemCodigo_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_QuemCodigo_end_QuandoSomenteValorInicial_SemQuemCodigoEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorQuemCodigo = 2500;
            var filtro = new FilterLigacoes
            {
                QuemCodigo = valorQuemCodigo,
                QuemCodigo_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.QuemCodigo}] = @{DBLigacoesDicInfo.QuemCodigo}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBLigacoesDicInfo.QuemCodigo}");
            parametro.Value.Should().Be(valorQuemCodigo);
        }

        [Fact]
        public void WFiltro_QuemCodigo_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorQuemCodigoInicial = 1000;
            var valorQuemCodigoFinal = 5000;
            var filtro = new FilterLigacoes
            {
                QuemCodigo = valorQuemCodigoInicial,
                QuemCodigo_end = valorQuemCodigoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].{DBLigacoesDicInfo.QuemCodigo} BETWEEN @{DBLigacoesDicInfo.QuemCodigo} AND @{DBLigacoesDicInfo.QuemCodigo}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.QuemCodigo}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.QuemCodigo}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorQuemCodigoInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorQuemCodigoFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_QuemCodigo_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemCodigo = valorInicial,
                QuemCodigo_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.QuemCodigo}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.QuemCodigo}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_QuemCodigo_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemCodigo = 1000,
                QuemCodigo_end = 5000,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.QuemCodigo}");
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Contato}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_QuemCodigo_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemCodigo = 1000,
                QuemCodigo_end = 5000,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_QuemCodigo_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemCodigo = 1000,
                QuemCodigo_end = 5000,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_QuemCodigo_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemCodigo = 1000,
                QuemCodigo_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].{DBLigacoesDicInfo.QuemCodigo} BETWEEN");
        }

        [Fact]
        public void WFiltro_QuemCodigo_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemCodigo = 1000,
                QuemCodigo_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_QuemCodigo_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemCodigo = 1000,
                QuemCodigo_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_QuemCodigo_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorQuemCodigoInicial = 2500;
            var valorQuemCodigoFinal = 4750;
            var filtro = new FilterLigacoes
            {
                QuemCodigo = valorQuemCodigoInicial,
                QuemCodigo_end = valorQuemCodigoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.QuemCodigo}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.QuemCodigo}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorQuemCodigoInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorQuemCodigoFinal);
        }

        [Fact]
        public void WFiltro_QuemCodigo_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemCodigo = 0,
                QuemCodigo_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_QuemCodigo_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemCodigo = 0,
                QuemCodigo_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_QuemCodigo_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemCodigo = 1500,
                QuemCodigo_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.QuemCodigo == int.MinValue) && !(filtro.QuemCodigo_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBLigacoesDicInfo.PTabelaNome}].{DBLigacoesDicInfo.QuemCodigo} BETWEEN @{DBLigacoesDicInfo.QuemCodigo} AND @{DBLigacoesDicInfo.QuemCodigo}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_QuemCodigo_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemCodigo = 2000,
                QuemCodigo_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.QuemCodigo == int.MinValue) && filtro.QuemCodigo_end == int.MinValue
            // Deve resultar em igualdade quando apenas QuemCodigo tem valor válido
            resultado.Value.where.Should().Be($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.QuemCodigo}] = @{DBLigacoesDicInfo.QuemCodigo}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_QuemCodigo_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemCodigo = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.QuemCodigo Isolated Tests
        [Fact]
        public void WFiltro_QuemCodigo_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemCodigo = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_QuemCodigo_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorQuemCodigo = 5;
            var filtro = new FilterLigacoes
            {
                QuemCodigo = valorQuemCodigo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.QuemCodigo}] = @{DBLigacoesDicInfo.QuemCodigo}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBLigacoesDicInfo.QuemCodigo}");
            parametro.Value.Should().Be(valorQuemCodigo);
        }

        [Fact]
        public void WFiltro_QuemCodigo_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorQuemCodigo = 0;
            var filtro = new FilterLigacoes
            {
                QuemCodigo = valorQuemCodigo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBLigacoesDicInfo.QuemCodigo}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorQuemCodigo);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_QuemCodigo_DiferentesValoresValidos_DeveProcessarCorretamente(int valorQuemCodigo)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemCodigo = valorQuemCodigo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorQuemCodigo);
            resultado.Value.where.Should().Contain($"= @{DBLigacoesDicInfo.QuemCodigo}");
        }

        [Fact]
        public void WFiltro_QuemCodigo_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemCodigo = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.QuemCodigo}");
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Contato}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_QuemCodigo_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemCodigo = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_QuemCodigo_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemCodigo = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_QuemCodigo_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemCodigo = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_QuemCodigo_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemCodigo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.QuemCodigo}]");
        }

        [Fact]
        public void WFiltro_QuemCodigo_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemCodigo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_QuemCodigo_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemCodigo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_QuemCodigo_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemCodigo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_QuemCodigo_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorQuemCodigo = 42;
            var filtro = new FilterLigacoes
            {
                QuemCodigo = valorQuemCodigo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorQuemCodigo);
        }

#endregion
        [Fact]
        public void WFiltro_QuemCodigo_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemCodigo = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_QuemCodigo_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorQuemCodigo = 1;
            var filtro = new FilterLigacoes
            {
                QuemCodigo = valorQuemCodigo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do QuemCodigo
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.QuemCodigo}] = @ligQuemCodigo");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@ligQuemCodigo");
            parametro.Value.Should().Be(valorQuemCodigo);
        }

        [Fact]
        public void WFiltro_QuemCodigo_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemCodigo = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@ligQuemCodigo");
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Contato}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_QuemCodigo_DiferentesValores_DeveFuncionar(int valorQuemCodigo)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                QuemCodigo = valorQuemCodigo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorQuemCodigo);
        }

#region filtro.Solicitante_end Tests
        [Fact]
        public void WFiltro_Solicitante_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Solicitante_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Solicitante_end_QuandoTemValorPositivo_SemSolicitanteInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorSolicitanteEnd = 5000;
            var filtro = new FilterLigacoes
            {
                Solicitante = int.MinValue, // Não define salário inicial
                Solicitante_end = valorSolicitanteEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Solicitante inicial válido, não deve incluir condição WHERE, mas o parâmetro Solicitante_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Solicitante_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Solicitante_end_QuandoSomenteValorInicial_SemSolicitanteEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorSolicitante = 2500;
            var filtro = new FilterLigacoes
            {
                Solicitante = valorSolicitante,
                Solicitante_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Solicitante}] = @{DBLigacoesDicInfo.Solicitante}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBLigacoesDicInfo.Solicitante}");
            parametro.Value.Should().Be(valorSolicitante);
        }

        [Fact]
        public void WFiltro_Solicitante_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorSolicitanteInicial = 1000;
            var valorSolicitanteFinal = 5000;
            var filtro = new FilterLigacoes
            {
                Solicitante = valorSolicitanteInicial,
                Solicitante_end = valorSolicitanteFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].{DBLigacoesDicInfo.Solicitante} BETWEEN @{DBLigacoesDicInfo.Solicitante} AND @{DBLigacoesDicInfo.Solicitante}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.Solicitante}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.Solicitante}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorSolicitanteInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorSolicitanteFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Solicitante_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Solicitante = valorInicial,
                Solicitante_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.Solicitante}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.Solicitante}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Solicitante_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Solicitante = 1000,
                Solicitante_end = 5000,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Solicitante}");
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Contato}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Solicitante_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Solicitante = 1000,
                Solicitante_end = 5000,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Solicitante_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Solicitante = 1000,
                Solicitante_end = 5000,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Solicitante_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Solicitante = 1000,
                Solicitante_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].{DBLigacoesDicInfo.Solicitante} BETWEEN");
        }

        [Fact]
        public void WFiltro_Solicitante_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Solicitante = 1000,
                Solicitante_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Solicitante_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Solicitante = 1000,
                Solicitante_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Solicitante_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorSolicitanteInicial = 2500;
            var valorSolicitanteFinal = 4750;
            var filtro = new FilterLigacoes
            {
                Solicitante = valorSolicitanteInicial,
                Solicitante_end = valorSolicitanteFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.Solicitante}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.Solicitante}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorSolicitanteInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorSolicitanteFinal);
        }

        [Fact]
        public void WFiltro_Solicitante_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Solicitante = 0,
                Solicitante_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Solicitante_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Solicitante = 0,
                Solicitante_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Solicitante_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Solicitante = 1500,
                Solicitante_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Solicitante == int.MinValue) && !(filtro.Solicitante_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBLigacoesDicInfo.PTabelaNome}].{DBLigacoesDicInfo.Solicitante} BETWEEN @{DBLigacoesDicInfo.Solicitante} AND @{DBLigacoesDicInfo.Solicitante}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Solicitante_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Solicitante = 2000,
                Solicitante_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Solicitante == int.MinValue) && filtro.Solicitante_end == int.MinValue
            // Deve resultar em igualdade quando apenas Solicitante tem valor válido
            resultado.Value.where.Should().Be($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Solicitante}] = @{DBLigacoesDicInfo.Solicitante}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Solicitante_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Solicitante = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Solicitante Isolated Tests
        [Fact]
        public void WFiltro_Solicitante_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Solicitante = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Solicitante_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorSolicitante = 5;
            var filtro = new FilterLigacoes
            {
                Solicitante = valorSolicitante,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Solicitante}] = @{DBLigacoesDicInfo.Solicitante}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBLigacoesDicInfo.Solicitante}");
            parametro.Value.Should().Be(valorSolicitante);
        }

        [Fact]
        public void WFiltro_Solicitante_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorSolicitante = 0;
            var filtro = new FilterLigacoes
            {
                Solicitante = valorSolicitante,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBLigacoesDicInfo.Solicitante}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorSolicitante);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Solicitante_DiferentesValoresValidos_DeveProcessarCorretamente(int valorSolicitante)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Solicitante = valorSolicitante,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorSolicitante);
            resultado.Value.where.Should().Contain($"= @{DBLigacoesDicInfo.Solicitante}");
        }

        [Fact]
        public void WFiltro_Solicitante_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Solicitante = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Solicitante}");
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Contato}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Solicitante_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Solicitante = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Solicitante_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Solicitante = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Solicitante_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Solicitante = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Solicitante_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Solicitante = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Solicitante}]");
        }

        [Fact]
        public void WFiltro_Solicitante_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Solicitante = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Solicitante_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Solicitante = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Solicitante_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Solicitante = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Solicitante_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorSolicitante = 42;
            var filtro = new FilterLigacoes
            {
                Solicitante = valorSolicitante,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorSolicitante);
        }

#endregion
        [Fact]
        public void WFiltro_Solicitante_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Solicitante = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Solicitante_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorSolicitante = 1;
            var filtro = new FilterLigacoes
            {
                Solicitante = valorSolicitante,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Solicitante
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Solicitante}] = @ligSolicitante");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@ligSolicitante");
            parametro.Value.Should().Be(valorSolicitante);
        }

        [Fact]
        public void WFiltro_Solicitante_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Solicitante = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@ligSolicitante");
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Contato}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Solicitante_DiferentesValores_DeveFuncionar(int valorSolicitante)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Solicitante = valorSolicitante,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorSolicitante);
        }

#region filtro.Ramal_end Tests
        [Fact]
        public void WFiltro_Ramal_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Ramal_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Ramal_end_QuandoTemValorPositivo_SemRamalInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorRamalEnd = 5000;
            var filtro = new FilterLigacoes
            {
                Ramal = int.MinValue, // Não define salário inicial
                Ramal_end = valorRamalEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Ramal inicial válido, não deve incluir condição WHERE, mas o parâmetro Ramal_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Ramal_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Ramal_end_QuandoSomenteValorInicial_SemRamalEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorRamal = 2500;
            var filtro = new FilterLigacoes
            {
                Ramal = valorRamal,
                Ramal_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Ramal}] = @{DBLigacoesDicInfo.Ramal}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBLigacoesDicInfo.Ramal}");
            parametro.Value.Should().Be(valorRamal);
        }

        [Fact]
        public void WFiltro_Ramal_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorRamalInicial = 1000;
            var valorRamalFinal = 5000;
            var filtro = new FilterLigacoes
            {
                Ramal = valorRamalInicial,
                Ramal_end = valorRamalFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].{DBLigacoesDicInfo.Ramal} BETWEEN @{DBLigacoesDicInfo.Ramal} AND @{DBLigacoesDicInfo.Ramal}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.Ramal}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.Ramal}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorRamalInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorRamalFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Ramal_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Ramal = valorInicial,
                Ramal_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.Ramal}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.Ramal}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Ramal_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Ramal = 1000,
                Ramal_end = 5000,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Ramal}");
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Contato}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Ramal_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Ramal = 1000,
                Ramal_end = 5000,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Ramal_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Ramal = 1000,
                Ramal_end = 5000,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Ramal_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Ramal = 1000,
                Ramal_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].{DBLigacoesDicInfo.Ramal} BETWEEN");
        }

        [Fact]
        public void WFiltro_Ramal_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Ramal = 1000,
                Ramal_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Ramal_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Ramal = 1000,
                Ramal_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Ramal_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorRamalInicial = 2500;
            var valorRamalFinal = 4750;
            var filtro = new FilterLigacoes
            {
                Ramal = valorRamalInicial,
                Ramal_end = valorRamalFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.Ramal}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.Ramal}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorRamalInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorRamalFinal);
        }

        [Fact]
        public void WFiltro_Ramal_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Ramal = 0,
                Ramal_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Ramal_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Ramal = 0,
                Ramal_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Ramal_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Ramal = 1500,
                Ramal_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Ramal == int.MinValue) && !(filtro.Ramal_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBLigacoesDicInfo.PTabelaNome}].{DBLigacoesDicInfo.Ramal} BETWEEN @{DBLigacoesDicInfo.Ramal} AND @{DBLigacoesDicInfo.Ramal}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Ramal_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Ramal = 2000,
                Ramal_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Ramal == int.MinValue) && filtro.Ramal_end == int.MinValue
            // Deve resultar em igualdade quando apenas Ramal tem valor válido
            resultado.Value.where.Should().Be($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Ramal}] = @{DBLigacoesDicInfo.Ramal}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Ramal_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Ramal = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Ramal Isolated Tests
        [Fact]
        public void WFiltro_Ramal_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Ramal = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Ramal_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorRamal = 5;
            var filtro = new FilterLigacoes
            {
                Ramal = valorRamal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Ramal}] = @{DBLigacoesDicInfo.Ramal}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBLigacoesDicInfo.Ramal}");
            parametro.Value.Should().Be(valorRamal);
        }

        [Fact]
        public void WFiltro_Ramal_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorRamal = 0;
            var filtro = new FilterLigacoes
            {
                Ramal = valorRamal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBLigacoesDicInfo.Ramal}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorRamal);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Ramal_DiferentesValoresValidos_DeveProcessarCorretamente(int valorRamal)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Ramal = valorRamal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorRamal);
            resultado.Value.where.Should().Contain($"= @{DBLigacoesDicInfo.Ramal}");
        }

        [Fact]
        public void WFiltro_Ramal_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Ramal = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Ramal}");
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Contato}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Ramal_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Ramal = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Ramal_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Ramal = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Ramal_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Ramal = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Ramal_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Ramal = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Ramal}]");
        }

        [Fact]
        public void WFiltro_Ramal_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Ramal = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Ramal_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Ramal = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Ramal_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Ramal = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Ramal_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorRamal = 42;
            var filtro = new FilterLigacoes
            {
                Ramal = valorRamal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorRamal);
        }

#endregion
        [Fact]
        public void WFiltro_Ramal_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Ramal = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Ramal_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorRamal = 1;
            var filtro = new FilterLigacoes
            {
                Ramal = valorRamal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Ramal
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Ramal}] = @ligRamal");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@ligRamal");
            parametro.Value.Should().Be(valorRamal);
        }

        [Fact]
        public void WFiltro_Ramal_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Ramal = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@ligRamal");
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Contato}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Ramal_DiferentesValores_DeveFuncionar(int valorRamal)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Ramal = valorRamal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorRamal);
        }

#region filtro.Processo_end Tests
        [Fact]
        public void WFiltro_Processo_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Processo_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Processo_end_QuandoTemValorPositivo_SemProcessoInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorProcessoEnd = 5000;
            var filtro = new FilterLigacoes
            {
                Processo = int.MinValue, // Não define salário inicial
                Processo_end = valorProcessoEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Processo inicial válido, não deve incluir condição WHERE, mas o parâmetro Processo_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Processo_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Processo_end_QuandoSomenteValorInicial_SemProcessoEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorProcesso = 2500;
            var filtro = new FilterLigacoes
            {
                Processo = valorProcesso,
                Processo_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Processo}] = @{DBLigacoesDicInfo.Processo}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBLigacoesDicInfo.Processo}");
            parametro.Value.Should().Be(valorProcesso);
        }

        [Fact]
        public void WFiltro_Processo_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorProcessoInicial = 1000;
            var valorProcessoFinal = 5000;
            var filtro = new FilterLigacoes
            {
                Processo = valorProcessoInicial,
                Processo_end = valorProcessoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].{DBLigacoesDicInfo.Processo} BETWEEN @{DBLigacoesDicInfo.Processo} AND @{DBLigacoesDicInfo.Processo}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.Processo}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.Processo}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorProcessoInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorProcessoFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Processo_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Processo = valorInicial,
                Processo_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.Processo}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.Processo}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Processo_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Processo = 1000,
                Processo_end = 5000,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Processo}");
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Contato}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Processo_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Processo = 1000,
                Processo_end = 5000,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Processo_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Processo = 1000,
                Processo_end = 5000,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Processo_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Processo = 1000,
                Processo_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].{DBLigacoesDicInfo.Processo} BETWEEN");
        }

        [Fact]
        public void WFiltro_Processo_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Processo = 1000,
                Processo_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Processo_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Processo = 1000,
                Processo_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Processo_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorProcessoInicial = 2500;
            var valorProcessoFinal = 4750;
            var filtro = new FilterLigacoes
            {
                Processo = valorProcessoInicial,
                Processo_end = valorProcessoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.Processo}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.Processo}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorProcessoInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorProcessoFinal);
        }

        [Fact]
        public void WFiltro_Processo_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Processo = 0,
                Processo_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Processo_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Processo = 0,
                Processo_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Processo_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Processo = 1500,
                Processo_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Processo == int.MinValue) && !(filtro.Processo_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBLigacoesDicInfo.PTabelaNome}].{DBLigacoesDicInfo.Processo} BETWEEN @{DBLigacoesDicInfo.Processo} AND @{DBLigacoesDicInfo.Processo}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Processo_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Processo = 2000,
                Processo_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Processo == int.MinValue) && filtro.Processo_end == int.MinValue
            // Deve resultar em igualdade quando apenas Processo tem valor válido
            resultado.Value.where.Should().Be($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Processo}] = @{DBLigacoesDicInfo.Processo}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Processo_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Processo = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Processo Isolated Tests
        [Fact]
        public void WFiltro_Processo_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Processo = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Processo_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorProcesso = 5;
            var filtro = new FilterLigacoes
            {
                Processo = valorProcesso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Processo}] = @{DBLigacoesDicInfo.Processo}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBLigacoesDicInfo.Processo}");
            parametro.Value.Should().Be(valorProcesso);
        }

        [Fact]
        public void WFiltro_Processo_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorProcesso = 0;
            var filtro = new FilterLigacoes
            {
                Processo = valorProcesso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBLigacoesDicInfo.Processo}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorProcesso);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Processo_DiferentesValoresValidos_DeveProcessarCorretamente(int valorProcesso)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Processo = valorProcesso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorProcesso);
            resultado.Value.where.Should().Contain($"= @{DBLigacoesDicInfo.Processo}");
        }

        [Fact]
        public void WFiltro_Processo_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Processo = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Processo}");
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Contato}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Processo_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Processo = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Processo_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Processo = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Processo_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Processo = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Processo_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Processo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Processo}]");
        }

        [Fact]
        public void WFiltro_Processo_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Processo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Processo_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Processo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Processo_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Processo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Processo_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorProcesso = 42;
            var filtro = new FilterLigacoes
            {
                Processo = valorProcesso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorProcesso);
        }

#endregion
        [Fact]
        public void WFiltro_Processo_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Processo = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Processo_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorProcesso = 1;
            var filtro = new FilterLigacoes
            {
                Processo = valorProcesso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Processo
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Processo}] = @ligProcesso");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@ligProcesso");
            parametro.Value.Should().Be(valorProcesso);
        }

        [Fact]
        public void WFiltro_Processo_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Processo = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@ligProcesso");
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Contato}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Processo_DiferentesValores_DeveFuncionar(int valorProcesso)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Processo = valorProcesso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorProcesso);
        }

#region filtro.Emotion_end Tests
        [Fact]
        public void WFiltro_Emotion_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Emotion_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Emotion_end_QuandoTemValorPositivo_SemEmotionInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorEmotionEnd = 5000;
            var filtro = new FilterLigacoes
            {
                Emotion = int.MinValue, // Não define salário inicial
                Emotion_end = valorEmotionEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Emotion inicial válido, não deve incluir condição WHERE, mas o parâmetro Emotion_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Emotion_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Emotion_end_QuandoSomenteValorInicial_SemEmotionEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorEmotion = 2500;
            var filtro = new FilterLigacoes
            {
                Emotion = valorEmotion,
                Emotion_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Emotion}] = @{DBLigacoesDicInfo.Emotion}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBLigacoesDicInfo.Emotion}");
            parametro.Value.Should().Be(valorEmotion);
        }

        [Fact]
        public void WFiltro_Emotion_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorEmotionInicial = 1000;
            var valorEmotionFinal = 5000;
            var filtro = new FilterLigacoes
            {
                Emotion = valorEmotionInicial,
                Emotion_end = valorEmotionFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].{DBLigacoesDicInfo.Emotion} BETWEEN @{DBLigacoesDicInfo.Emotion} AND @{DBLigacoesDicInfo.Emotion}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.Emotion}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.Emotion}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorEmotionInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorEmotionFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Emotion_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Emotion = valorInicial,
                Emotion_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.Emotion}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.Emotion}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Emotion_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Emotion = 1000,
                Emotion_end = 5000,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Emotion}");
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Contato}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Emotion_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Emotion = 1000,
                Emotion_end = 5000,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Emotion_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Emotion = 1000,
                Emotion_end = 5000,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Emotion_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Emotion = 1000,
                Emotion_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].{DBLigacoesDicInfo.Emotion} BETWEEN");
        }

        [Fact]
        public void WFiltro_Emotion_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Emotion = 1000,
                Emotion_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Emotion_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Emotion = 1000,
                Emotion_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Emotion_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorEmotionInicial = 2500;
            var valorEmotionFinal = 4750;
            var filtro = new FilterLigacoes
            {
                Emotion = valorEmotionInicial,
                Emotion_end = valorEmotionFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.Emotion}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.Emotion}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorEmotionInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorEmotionFinal);
        }

        [Fact]
        public void WFiltro_Emotion_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Emotion = 0,
                Emotion_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Emotion_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Emotion = 0,
                Emotion_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Emotion_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Emotion = 1500,
                Emotion_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Emotion == int.MinValue) && !(filtro.Emotion_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBLigacoesDicInfo.PTabelaNome}].{DBLigacoesDicInfo.Emotion} BETWEEN @{DBLigacoesDicInfo.Emotion} AND @{DBLigacoesDicInfo.Emotion}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Emotion_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Emotion = 2000,
                Emotion_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Emotion == int.MinValue) && filtro.Emotion_end == int.MinValue
            // Deve resultar em igualdade quando apenas Emotion tem valor válido
            resultado.Value.where.Should().Be($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Emotion}] = @{DBLigacoesDicInfo.Emotion}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Emotion_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Emotion = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Emotion Isolated Tests
        [Fact]
        public void WFiltro_Emotion_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Emotion = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Emotion_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorEmotion = 5;
            var filtro = new FilterLigacoes
            {
                Emotion = valorEmotion,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Emotion}] = @{DBLigacoesDicInfo.Emotion}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBLigacoesDicInfo.Emotion}");
            parametro.Value.Should().Be(valorEmotion);
        }

        [Fact]
        public void WFiltro_Emotion_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorEmotion = 0;
            var filtro = new FilterLigacoes
            {
                Emotion = valorEmotion,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBLigacoesDicInfo.Emotion}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorEmotion);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Emotion_DiferentesValoresValidos_DeveProcessarCorretamente(int valorEmotion)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Emotion = valorEmotion,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorEmotion);
            resultado.Value.where.Should().Contain($"= @{DBLigacoesDicInfo.Emotion}");
        }

        [Fact]
        public void WFiltro_Emotion_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Emotion = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Emotion}");
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Contato}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Emotion_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Emotion = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Emotion_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Emotion = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Emotion_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Emotion = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Emotion_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Emotion = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Emotion}]");
        }

        [Fact]
        public void WFiltro_Emotion_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Emotion = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Emotion_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Emotion = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Emotion_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Emotion = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Emotion_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorEmotion = 42;
            var filtro = new FilterLigacoes
            {
                Emotion = valorEmotion,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorEmotion);
        }

#endregion
        [Fact]
        public void WFiltro_Emotion_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Emotion = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Emotion_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorEmotion = 1;
            var filtro = new FilterLigacoes
            {
                Emotion = valorEmotion,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Emotion
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Emotion}] = @ligEmotion");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@ligEmotion");
            parametro.Value.Should().Be(valorEmotion);
        }

        [Fact]
        public void WFiltro_Emotion_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Emotion = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@ligEmotion");
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Contato}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Emotion_DiferentesValores_DeveFuncionar(int valorEmotion)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Emotion = valorEmotion,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorEmotion);
        }

#region filtro.Codigo_filtro_end Tests
        [Fact]
        public void WFiltro_Codigo_filtro_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Codigo_filtro_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Codigo_filtro_end_QuandoTemValorPositivo_SemCodigo_filtroInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorCodigo_filtroEnd = 5000;
            var filtro = new FilterLigacoes
            {
                Codigo_filtro = int.MinValue, // Não define salário inicial
                Codigo_filtro_end = valorCodigo_filtroEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Codigo_filtro inicial válido, não deve incluir condição WHERE, mas o parâmetro Codigo_filtro_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Codigo_filtro_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Codigo_filtro_end_QuandoSomenteValorInicial_SemCodigo_filtroEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorCodigo_filtro = 2500;
            var filtro = new FilterLigacoes
            {
                Codigo_filtro = valorCodigo_filtro,
                Codigo_filtro_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.CampoCodigo}] = @{DBLigacoesDicInfo.CampoCodigo}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBLigacoesDicInfo.CampoCodigo}");
            parametro.Value.Should().Be(valorCodigo_filtro);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorCodigo_filtroInicial = 1000;
            var valorCodigo_filtroFinal = 5000;
            var filtro = new FilterLigacoes
            {
                Codigo_filtro = valorCodigo_filtroInicial,
                Codigo_filtro_end = valorCodigo_filtroFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].{DBLigacoesDicInfo.CampoCodigo} BETWEEN @{DBLigacoesDicInfo.CampoCodigo} AND @{DBLigacoesDicInfo.CampoCodigo}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.CampoCodigo}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.CampoCodigo}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorCodigo_filtroInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorCodigo_filtroFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Codigo_filtro_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Codigo_filtro = valorInicial,
                Codigo_filtro_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.CampoCodigo}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.CampoCodigo}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.CampoCodigo}");
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Contato}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].{DBLigacoesDicInfo.CampoCodigo} BETWEEN");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorCodigo_filtroInicial = 2500;
            var valorCodigo_filtroFinal = 4750;
            var filtro = new FilterLigacoes
            {
                Codigo_filtro = valorCodigo_filtroInicial,
                Codigo_filtro_end = valorCodigo_filtroFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.CampoCodigo}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBLigacoesDicInfo.CampoCodigo}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorCodigo_filtroInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorCodigo_filtroFinal);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Codigo_filtro = 0,
                Codigo_filtro_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Codigo_filtro = 0,
                Codigo_filtro_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Codigo_filtro = 1500,
                Codigo_filtro_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Codigo_filtro == int.MinValue) && !(filtro.Codigo_filtro_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBLigacoesDicInfo.PTabelaNome}].{DBLigacoesDicInfo.CampoCodigo} BETWEEN @{DBLigacoesDicInfo.CampoCodigo} AND @{DBLigacoesDicInfo.CampoCodigo}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Codigo_filtro = 2000,
                Codigo_filtro_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Codigo_filtro == int.MinValue) && filtro.Codigo_filtro_end == int.MinValue
            // Deve resultar em igualdade quando apenas Codigo_filtro tem valor válido
            resultado.Value.where.Should().Be($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.CampoCodigo}] = @{DBLigacoesDicInfo.CampoCodigo}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Codigo_filtro_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Codigo_filtro = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Codigo_filtro Isolated Tests
        [Fact]
        public void WFiltro_Codigo_filtro_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Codigo_filtro = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorCodigo_filtro = 5;
            var filtro = new FilterLigacoes
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.CampoCodigo}] = @{DBLigacoesDicInfo.CampoCodigo}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBLigacoesDicInfo.CampoCodigo}");
            parametro.Value.Should().Be(valorCodigo_filtro);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorCodigo_filtro = 0;
            var filtro = new FilterLigacoes
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBLigacoesDicInfo.CampoCodigo}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCodigo_filtro);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Codigo_filtro_DiferentesValoresValidos_DeveProcessarCorretamente(int valorCodigo_filtro)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCodigo_filtro);
            resultado.Value.where.Should().Contain($"= @{DBLigacoesDicInfo.CampoCodigo}");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Codigo_filtro = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.CampoCodigo}");
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Contato}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Codigo_filtro = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Codigo_filtro = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Codigo_filtro = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Codigo_filtro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.CampoCodigo}]");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Codigo_filtro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Codigo_filtro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Codigo_filtro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorCodigo_filtro = 42;
            var filtro = new FilterLigacoes
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorCodigo_filtro);
        }

#endregion
        [Fact]
        public void WFiltro_Codigo_filtro_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Codigo_filtro = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorCodigo_filtro = 1;
            var filtro = new FilterLigacoes
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Codigo_filtro
            resultado.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.CampoCodigo}] = @{DBLigacoesDicInfo.CampoCodigo}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBLigacoesDicInfo.CampoCodigo}");
            parametro.Value.Should().Be(valorCodigo_filtro);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Codigo_filtro = 1,
                Contato = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.CampoCodigo}");
            resultado.Value.where.Should().Contain($"@{DBLigacoesDicInfo.Contato}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Codigo_filtro_DiferentesValores_DeveFuncionar(int valorCodigo_filtro)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCodigo_filtro);
        }

#endregion
#region Decimal Tests
#endregion
#region DateTime Tests
        [Theory]
        [InlineData("31/12/9999")] // Data máxima
        [InlineData("01/01/1900")] // Data muito antiga
        [InlineData("29/02/2024")] // Ano bissexto
        public void WFiltro_DataRealizada_ComDatasExtremas_DeveProcessarCorretamente(string dataExtrema)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                DataRealizada = dataExtrema,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<DateTime>();
        }

        [Theory]
        [InlineData("32/12/2023")] // Dia inválido
        [InlineData("31/13/2023")] // Mês inválido
        [InlineData("29/02/2023")] // Não é ano bissexto
        [InlineData("abc/def/ghij")] // Formato completamente inválido
        public void WFiltro_DataRealizada_ComDatasInvalidas_NaoDeveAdicionarParametros(string dataInvalida)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                DataRealizada = dataInvalida,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().BeEmpty();
            resultado.Value.where.Should().BeEmpty();
        }

#region DataRealizada Tests
        [Fact]
        public void WFiltro_DataRealizada_WhenEmptyOrNull_ShouldNotAddParameters()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                DataRealizada = string.Empty,
                DataRealizada_end = null,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DataRealizada_WhenValidSingleDate_ShouldAddParameterAndGenerateWhereClause()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterLigacoes
            {
                DataRealizada = testDate,
                DataRealizada_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(1);
            var parameter = result.Value.parametros.First();
            parameter.ParameterName.Should().Be($"@{DBLigacoesDicInfo.DataRealizada}");
            parameter.Value.Should().BeOfType<DateTime>();
            var expectedDate = DateTime.Parse(testDate);
            ((DateTime)parameter.Value).Should().Be(expectedDate);
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.DataRealizada}], 103) = CONVERT(DATE, @{DBLigacoesDicInfo.DataRealizada}, 103)");
        }

        [Fact]
        public void WFiltro_DataRealizada_WhenValidDateRange_ShouldAddBothParametersAndGenerateBetweenClause()
        {
            // Arrange
            var startDate = "01/06/2023";
            var endDate = "30/06/2023";
            var filtro = new FilterLigacoes
            {
                DataRealizada = startDate,
                DataRealizada_end = endDate,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(2);
            var startParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.DataRealizada}");
            var endParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.DataRealizada}_end");
            startParameter.Should().NotBeNull();
            endParameter.Should().NotBeNull();
            startParameter!.Value.Should().BeOfType<DateTime>();
            endParameter!.Value.Should().BeOfType<DateTime>();
            ((DateTime)startParameter.Value).Should().Be(DateTime.Parse(startDate));
            ((DateTime)endParameter.Value).Should().Be(DateTime.Parse(endDate));
            result.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].{DBLigacoesDicInfo.DataRealizada} BETWEEN @{DBLigacoesDicInfo.DataRealizada} AND @{DBLigacoesDicInfo.DataRealizada}_end");
        }

        [Fact]
        public void WFiltro_DataRealizada_WhenInvalidDateFormat_ShouldNotAddParameter()
        {
            // Arrange
            var invalidDate = "invalid-date";
            var filtro = new FilterLigacoes
            {
                DataRealizada = invalidDate,
                DataRealizada_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DataRealizada_WhenStartDateValidButEndDateInvalid_ShouldOnlyAddStartParameterAndGenerateSingleDateClause()
        {
            // Arrange
            var validStartDate = "15/06/2023";
            var invalidEndDate = "invalid-date";
            var filtro = new FilterLigacoes
            {
                DataRealizada = validStartDate,
                DataRealizada_end = invalidEndDate,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(1);
            var parameter = result.Value.parametros.First();
            parameter.ParameterName.Should().Be($"@{DBLigacoesDicInfo.DataRealizada}");
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.DataRealizada}], 103) = CONVERT(DATE, @{DBLigacoesDicInfo.DataRealizada}, 103)");
            result.Value.where.Should().NotContain("BETWEEN");
        }

        [Fact]
        public void WFiltro_DataRealizada_WhenStartDateInvalidButEndDateValid_ShouldNotAddAnyParameters()
        {
            // Arrange
            var invalidStartDate = "invalid-date";
            var validEndDate = "30/06/2023";
            var filtro = new FilterLigacoes
            {
                DataRealizada = invalidStartDate,
                DataRealizada_end = validEndDate,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DataRealizada_WhenWhitespaceOnlyDates_ShouldNotAddParameters()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                DataRealizada = "   ",
                DataRealizada_end = "\t\n",
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DataRealizada_WithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterLigacoes
            {
                Contato = "A",
                DataRealizada = testDate,
                DataRealizada_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(2); // Nome + DataRealizada
            result.Value.where.Should().Contain(TSql.And);
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.DataRealizada}], 103) = CONVERT(DATE, @{DBLigacoesDicInfo.DataRealizada}, 103)");
        }

        [Fact]
        public void WFiltro_DataRealizada_WithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterLigacoes
            {
                Contato = "A",
                DataRealizada = testDate,
                DataRealizada_end = string.Empty,
                LogicalOperator = TSql.OR
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(TSql.OR);
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.DataRealizada}], 103) = CONVERT(DATE, @{DBLigacoesDicInfo.DataRealizada}, 103)");
        }

        [Fact]
        public void WFiltro_DataRealizada_WhenOnlyEndDateProvided_ShouldNotAddParameters()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                DataRealizada = string.Empty,
                DataRealizada_end = "30/06/2023",
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DataRealizada_WhenDateTimeMinValue_ShouldNotAddParameters()
        {
            // Arrange
            var minValueDate = DateTime.MinValue.ToString("dd/MM/yyyy");
            var filtro = new FilterLigacoes
            {
                DataRealizada = minValueDate,
                DataRealizada_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // The IsEmptyDX extension method should catch DateTime.MinValue and return true
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DataRealizada_AsFirstFilter_ShouldNotIncludeLogicalOperatorAtStart()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterLigacoes
            {
                DataRealizada = testDate,
                DataRealizada_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().NotStartWith(TSql.And);
            result.Value.where.Should().StartWith($"CONVERT(DATE,[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.DataRealizada}], 103)");
        }

        [Theory]
        [InlineData("15/06/2023", "2023-06-15T00:00:00")]
        [InlineData("01/01/2024", "2024-01-01T00:00:00")]
        [InlineData("31/12/2022", "2022-12-31T00:00:00")]
        public void WFiltro_DataRealizada_WhenVariousValidDateFormats_ShouldParseCorrectly(string inputDate, string expectedDateTimeString)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                DataRealizada = inputDate,
                DataRealizada_end = string.Empty,
                LogicalOperator = TSql.And
            };
            var expectedDateTime = DateTime.Parse(expectedDateTimeString);
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(1);
            var parameter = result.Value.parametros.First();
            ((DateTime)parameter.Value).Should().Be(expectedDateTime);
        }

#endregion
        [Theory]
        [InlineData("31/12/9999")] // Data máxima
        [InlineData("01/01/1900")] // Data muito antiga
        [InlineData("29/02/2024")] // Ano bissexto
        public void WFiltro_UltimoAviso_ComDatasExtremas_DeveProcessarCorretamente(string dataExtrema)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                UltimoAviso = dataExtrema,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<DateTime>();
        }

        [Theory]
        [InlineData("32/12/2023")] // Dia inválido
        [InlineData("31/13/2023")] // Mês inválido
        [InlineData("29/02/2023")] // Não é ano bissexto
        [InlineData("abc/def/ghij")] // Formato completamente inválido
        public void WFiltro_UltimoAviso_ComDatasInvalidas_NaoDeveAdicionarParametros(string dataInvalida)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                UltimoAviso = dataInvalida,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().BeEmpty();
            resultado.Value.where.Should().BeEmpty();
        }

#region UltimoAviso Tests
        [Fact]
        public void WFiltro_UltimoAviso_WhenEmptyOrNull_ShouldNotAddParameters()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                UltimoAviso = string.Empty,
                UltimoAviso_end = null,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_UltimoAviso_WhenValidSingleDate_ShouldAddParameterAndGenerateWhereClause()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterLigacoes
            {
                UltimoAviso = testDate,
                UltimoAviso_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(1);
            var parameter = result.Value.parametros.First();
            parameter.ParameterName.Should().Be($"@{DBLigacoesDicInfo.UltimoAviso}");
            parameter.Value.Should().BeOfType<DateTime>();
            var expectedDate = DateTime.Parse(testDate);
            ((DateTime)parameter.Value).Should().Be(expectedDate);
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.UltimoAviso}], 103) = CONVERT(DATE, @{DBLigacoesDicInfo.UltimoAviso}, 103)");
        }

        [Fact]
        public void WFiltro_UltimoAviso_WhenValidDateRange_ShouldAddBothParametersAndGenerateBetweenClause()
        {
            // Arrange
            var startDate = "01/06/2023";
            var endDate = "30/06/2023";
            var filtro = new FilterLigacoes
            {
                UltimoAviso = startDate,
                UltimoAviso_end = endDate,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(2);
            var startParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.UltimoAviso}");
            var endParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.UltimoAviso}_end");
            startParameter.Should().NotBeNull();
            endParameter.Should().NotBeNull();
            startParameter!.Value.Should().BeOfType<DateTime>();
            endParameter!.Value.Should().BeOfType<DateTime>();
            ((DateTime)startParameter.Value).Should().Be(DateTime.Parse(startDate));
            ((DateTime)endParameter.Value).Should().Be(DateTime.Parse(endDate));
            result.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].{DBLigacoesDicInfo.UltimoAviso} BETWEEN @{DBLigacoesDicInfo.UltimoAviso} AND @{DBLigacoesDicInfo.UltimoAviso}_end");
        }

        [Fact]
        public void WFiltro_UltimoAviso_WhenInvalidDateFormat_ShouldNotAddParameter()
        {
            // Arrange
            var invalidDate = "invalid-date";
            var filtro = new FilterLigacoes
            {
                UltimoAviso = invalidDate,
                UltimoAviso_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_UltimoAviso_WhenStartDateValidButEndDateInvalid_ShouldOnlyAddStartParameterAndGenerateSingleDateClause()
        {
            // Arrange
            var validStartDate = "15/06/2023";
            var invalidEndDate = "invalid-date";
            var filtro = new FilterLigacoes
            {
                UltimoAviso = validStartDate,
                UltimoAviso_end = invalidEndDate,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(1);
            var parameter = result.Value.parametros.First();
            parameter.ParameterName.Should().Be($"@{DBLigacoesDicInfo.UltimoAviso}");
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.UltimoAviso}], 103) = CONVERT(DATE, @{DBLigacoesDicInfo.UltimoAviso}, 103)");
            result.Value.where.Should().NotContain("BETWEEN");
        }

        [Fact]
        public void WFiltro_UltimoAviso_WhenStartDateInvalidButEndDateValid_ShouldNotAddAnyParameters()
        {
            // Arrange
            var invalidStartDate = "invalid-date";
            var validEndDate = "30/06/2023";
            var filtro = new FilterLigacoes
            {
                UltimoAviso = invalidStartDate,
                UltimoAviso_end = validEndDate,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_UltimoAviso_WhenWhitespaceOnlyDates_ShouldNotAddParameters()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                UltimoAviso = "   ",
                UltimoAviso_end = "\t\n",
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_UltimoAviso_WithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterLigacoes
            {
                Contato = "A",
                UltimoAviso = testDate,
                UltimoAviso_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(2); // Nome + UltimoAviso
            result.Value.where.Should().Contain(TSql.And);
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.UltimoAviso}], 103) = CONVERT(DATE, @{DBLigacoesDicInfo.UltimoAviso}, 103)");
        }

        [Fact]
        public void WFiltro_UltimoAviso_WithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterLigacoes
            {
                Contato = "A",
                UltimoAviso = testDate,
                UltimoAviso_end = string.Empty,
                LogicalOperator = TSql.OR
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(TSql.OR);
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.UltimoAviso}], 103) = CONVERT(DATE, @{DBLigacoesDicInfo.UltimoAviso}, 103)");
        }

        [Fact]
        public void WFiltro_UltimoAviso_WhenOnlyEndDateProvided_ShouldNotAddParameters()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                UltimoAviso = string.Empty,
                UltimoAviso_end = "30/06/2023",
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_UltimoAviso_WhenDateTimeMinValue_ShouldNotAddParameters()
        {
            // Arrange
            var minValueDate = DateTime.MinValue.ToString("dd/MM/yyyy");
            var filtro = new FilterLigacoes
            {
                UltimoAviso = minValueDate,
                UltimoAviso_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // The IsEmptyDX extension method should catch DateTime.MinValue and return true
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_UltimoAviso_AsFirstFilter_ShouldNotIncludeLogicalOperatorAtStart()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterLigacoes
            {
                UltimoAviso = testDate,
                UltimoAviso_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().NotStartWith(TSql.And);
            result.Value.where.Should().StartWith($"CONVERT(DATE,[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.UltimoAviso}], 103)");
        }

        [Theory]
        [InlineData("15/06/2023", "2023-06-15T00:00:00")]
        [InlineData("01/01/2024", "2024-01-01T00:00:00")]
        [InlineData("31/12/2022", "2022-12-31T00:00:00")]
        public void WFiltro_UltimoAviso_WhenVariousValidDateFormats_ShouldParseCorrectly(string inputDate, string expectedDateTimeString)
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                UltimoAviso = inputDate,
                UltimoAviso_end = string.Empty,
                LogicalOperator = TSql.And
            };
            var expectedDateTime = DateTime.Parse(expectedDateTimeString);
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(1);
            var parameter = result.Value.parametros.First();
            ((DateTime)parameter.Value).Should().Be(expectedDateTime);
        }

#endregion
#endregion
#region Bool Tests
#region Celular Filter Tests
        [Fact]
        public void WFiltro_CelularEqualsIntMinValue_ShouldNotAddParameterOrWhereClause()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Celular = int.MinValue
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().NotContain(p => p.ParameterName.Contains(DBLigacoesDicInfo.Celular));
            result.Value.where.Should().NotContain(DBLigacoesDicInfo.Celular);
        }

        [Fact]
        public void WFiltro_CelularHasValidValue_ShouldAddParameterAndWhereClause()
        {
            // Arrange
            var CelularValue = 1;
            var filtro = new FilterLigacoes
            {
                Celular = CelularValue,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // Check parameter
            var CelularParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.Celular}");
            CelularParameter.Should().NotBeNull();
            CelularParameter.Value.Should().Be(CelularValue);
            // Check where clause
            result.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Celular}] = @{DBLigacoesDicInfo.Celular}");
        }

        [Fact]
        public void WFiltro_CelularWithDifferentValues_ShouldAddCorrectParameterValue()
        {
            // Arrange & Act & Assert for Celular = 0 (typically female)
            var filtroFemale = new FilterLigacoes
            {
                Celular = 0
            };
            var resultFemale = _service.WFiltro(filtroFemale);
            resultFemale.Should().NotBeNull();
            var femaleParam = resultFemale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.Celular}");
            femaleParam.Should().NotBeNull();
            femaleParam.Value.Should().Be(0);
            // Arrange & Act & Assert for Celular = 1 (typically male)
            var filtroMale = new FilterLigacoes
            {
                Celular = 1
            };
            var resultMale = _service.WFiltro(filtroMale);
            resultMale.Should().NotBeNull();
            var maleParam = resultMale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.Celular}");
            maleParam.Should().NotBeNull();
            maleParam.Value.Should().Be(1);
        }

        [Fact]
        public void WFiltro_CelularAsFirstFilter_ShouldNotIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Celular = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().StartWith($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Celular}] = @{DBLigacoesDicInfo.Celular}");
            result.Value.where.Should().NotStartWith(" AND ");
        }

        [Fact]
        public void WFiltro_CelularWithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Contato = "Contato",
                Celular = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain($" AND ");
        }

        [Fact]
        public void WFiltro_CelularWithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Contato = "Contato",
                Celular = 1,
                LogicalOperator = " OR "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(" OR ");
        }

#endregion
#region Particular Filter Tests
        [Fact]
        public void WFiltro_ParticularEqualsIntMinValue_ShouldNotAddParameterOrWhereClause()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Particular = int.MinValue
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().NotContain(p => p.ParameterName.Contains(DBLigacoesDicInfo.Particular));
            result.Value.where.Should().NotContain(DBLigacoesDicInfo.Particular);
        }

        [Fact]
        public void WFiltro_ParticularHasValidValue_ShouldAddParameterAndWhereClause()
        {
            // Arrange
            var ParticularValue = 1;
            var filtro = new FilterLigacoes
            {
                Particular = ParticularValue,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // Check parameter
            var ParticularParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.Particular}");
            ParticularParameter.Should().NotBeNull();
            ParticularParameter.Value.Should().Be(ParticularValue);
            // Check where clause
            result.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Particular}] = @{DBLigacoesDicInfo.Particular}");
        }

        [Fact]
        public void WFiltro_ParticularWithDifferentValues_ShouldAddCorrectParameterValue()
        {
            // Arrange & Act & Assert for Particular = 0 (typically female)
            var filtroFemale = new FilterLigacoes
            {
                Particular = 0
            };
            var resultFemale = _service.WFiltro(filtroFemale);
            resultFemale.Should().NotBeNull();
            var femaleParam = resultFemale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.Particular}");
            femaleParam.Should().NotBeNull();
            femaleParam.Value.Should().Be(0);
            // Arrange & Act & Assert for Particular = 1 (typically male)
            var filtroMale = new FilterLigacoes
            {
                Particular = 1
            };
            var resultMale = _service.WFiltro(filtroMale);
            resultMale.Should().NotBeNull();
            var maleParam = resultMale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.Particular}");
            maleParam.Should().NotBeNull();
            maleParam.Value.Should().Be(1);
        }

        [Fact]
        public void WFiltro_ParticularAsFirstFilter_ShouldNotIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Particular = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().StartWith($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Particular}] = @{DBLigacoesDicInfo.Particular}");
            result.Value.where.Should().NotStartWith(" AND ");
        }

        [Fact]
        public void WFiltro_ParticularWithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Contato = "Contato",
                Particular = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain($" AND ");
        }

        [Fact]
        public void WFiltro_ParticularWithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Contato = "Contato",
                Particular = 1,
                LogicalOperator = " OR "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(" OR ");
        }

#endregion
#region Realizada Filter Tests
        [Fact]
        public void WFiltro_RealizadaEqualsIntMinValue_ShouldNotAddParameterOrWhereClause()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Realizada = int.MinValue
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().NotContain(p => p.ParameterName.Contains(DBLigacoesDicInfo.Realizada));
            result.Value.where.Should().NotContain(DBLigacoesDicInfo.Realizada);
        }

        [Fact]
        public void WFiltro_RealizadaHasValidValue_ShouldAddParameterAndWhereClause()
        {
            // Arrange
            var RealizadaValue = 1;
            var filtro = new FilterLigacoes
            {
                Realizada = RealizadaValue,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // Check parameter
            var RealizadaParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.Realizada}");
            RealizadaParameter.Should().NotBeNull();
            RealizadaParameter.Value.Should().Be(RealizadaValue);
            // Check where clause
            result.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Realizada}] = @{DBLigacoesDicInfo.Realizada}");
        }

        [Fact]
        public void WFiltro_RealizadaWithDifferentValues_ShouldAddCorrectParameterValue()
        {
            // Arrange & Act & Assert for Realizada = 0 (typically female)
            var filtroFemale = new FilterLigacoes
            {
                Realizada = 0
            };
            var resultFemale = _service.WFiltro(filtroFemale);
            resultFemale.Should().NotBeNull();
            var femaleParam = resultFemale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.Realizada}");
            femaleParam.Should().NotBeNull();
            femaleParam.Value.Should().Be(0);
            // Arrange & Act & Assert for Realizada = 1 (typically male)
            var filtroMale = new FilterLigacoes
            {
                Realizada = 1
            };
            var resultMale = _service.WFiltro(filtroMale);
            resultMale.Should().NotBeNull();
            var maleParam = resultMale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.Realizada}");
            maleParam.Should().NotBeNull();
            maleParam.Value.Should().Be(1);
        }

        [Fact]
        public void WFiltro_RealizadaAsFirstFilter_ShouldNotIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Realizada = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().StartWith($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Realizada}] = @{DBLigacoesDicInfo.Realizada}");
            result.Value.where.Should().NotStartWith(" AND ");
        }

        [Fact]
        public void WFiltro_RealizadaWithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Contato = "Contato",
                Realizada = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain($" AND ");
        }

        [Fact]
        public void WFiltro_RealizadaWithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Contato = "Contato",
                Realizada = 1,
                LogicalOperator = " OR "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(" OR ");
        }

#endregion
#region Urgente Filter Tests
        [Fact]
        public void WFiltro_UrgenteEqualsIntMinValue_ShouldNotAddParameterOrWhereClause()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Urgente = int.MinValue
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().NotContain(p => p.ParameterName.Contains(DBLigacoesDicInfo.Urgente));
            result.Value.where.Should().NotContain(DBLigacoesDicInfo.Urgente);
        }

        [Fact]
        public void WFiltro_UrgenteHasValidValue_ShouldAddParameterAndWhereClause()
        {
            // Arrange
            var UrgenteValue = 1;
            var filtro = new FilterLigacoes
            {
                Urgente = UrgenteValue,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // Check parameter
            var UrgenteParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.Urgente}");
            UrgenteParameter.Should().NotBeNull();
            UrgenteParameter.Value.Should().Be(UrgenteValue);
            // Check where clause
            result.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Urgente}] = @{DBLigacoesDicInfo.Urgente}");
        }

        [Fact]
        public void WFiltro_UrgenteWithDifferentValues_ShouldAddCorrectParameterValue()
        {
            // Arrange & Act & Assert for Urgente = 0 (typically female)
            var filtroFemale = new FilterLigacoes
            {
                Urgente = 0
            };
            var resultFemale = _service.WFiltro(filtroFemale);
            resultFemale.Should().NotBeNull();
            var femaleParam = resultFemale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.Urgente}");
            femaleParam.Should().NotBeNull();
            femaleParam.Value.Should().Be(0);
            // Arrange & Act & Assert for Urgente = 1 (typically male)
            var filtroMale = new FilterLigacoes
            {
                Urgente = 1
            };
            var resultMale = _service.WFiltro(filtroMale);
            resultMale.Should().NotBeNull();
            var maleParam = resultMale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.Urgente}");
            maleParam.Should().NotBeNull();
            maleParam.Value.Should().Be(1);
        }

        [Fact]
        public void WFiltro_UrgenteAsFirstFilter_ShouldNotIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Urgente = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().StartWith($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.Urgente}] = @{DBLigacoesDicInfo.Urgente}");
            result.Value.where.Should().NotStartWith(" AND ");
        }

        [Fact]
        public void WFiltro_UrgenteWithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Contato = "Contato",
                Urgente = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain($" AND ");
        }

        [Fact]
        public void WFiltro_UrgenteWithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Contato = "Contato",
                Urgente = 1,
                LogicalOperator = " OR "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(" OR ");
        }

#endregion
#region StartScreen Filter Tests
        [Fact]
        public void WFiltro_StartScreenEqualsIntMinValue_ShouldNotAddParameterOrWhereClause()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                StartScreen = int.MinValue
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().NotContain(p => p.ParameterName.Contains(DBLigacoesDicInfo.StartScreen));
            result.Value.where.Should().NotContain(DBLigacoesDicInfo.StartScreen);
        }

        [Fact]
        public void WFiltro_StartScreenHasValidValue_ShouldAddParameterAndWhereClause()
        {
            // Arrange
            var StartScreenValue = 1;
            var filtro = new FilterLigacoes
            {
                StartScreen = StartScreenValue,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // Check parameter
            var StartScreenParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.StartScreen}");
            StartScreenParameter.Should().NotBeNull();
            StartScreenParameter.Value.Should().Be(StartScreenValue);
            // Check where clause
            result.Value.where.Should().Contain($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.StartScreen}] = @{DBLigacoesDicInfo.StartScreen}");
        }

        [Fact]
        public void WFiltro_StartScreenWithDifferentValues_ShouldAddCorrectParameterValue()
        {
            // Arrange & Act & Assert for StartScreen = 0 (typically female)
            var filtroFemale = new FilterLigacoes
            {
                StartScreen = 0
            };
            var resultFemale = _service.WFiltro(filtroFemale);
            resultFemale.Should().NotBeNull();
            var femaleParam = resultFemale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.StartScreen}");
            femaleParam.Should().NotBeNull();
            femaleParam.Value.Should().Be(0);
            // Arrange & Act & Assert for StartScreen = 1 (typically male)
            var filtroMale = new FilterLigacoes
            {
                StartScreen = 1
            };
            var resultMale = _service.WFiltro(filtroMale);
            resultMale.Should().NotBeNull();
            var maleParam = resultMale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBLigacoesDicInfo.StartScreen}");
            maleParam.Should().NotBeNull();
            maleParam.Value.Should().Be(1);
        }

        [Fact]
        public void WFiltro_StartScreenAsFirstFilter_ShouldNotIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                StartScreen = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().StartWith($"[{DBLigacoesDicInfo.PTabelaNome}].[{DBLigacoesDicInfo.StartScreen}] = @{DBLigacoesDicInfo.StartScreen}");
            result.Value.where.Should().NotStartWith(" AND ");
        }

        [Fact]
        public void WFiltro_StartScreenWithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Contato = "Contato",
                StartScreen = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain($" AND ");
        }

        [Fact]
        public void WFiltro_StartScreenWithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var filtro = new FilterLigacoes
            {
                Contato = "Contato",
                StartScreen = 1,
                LogicalOperator = " OR "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(" OR ");
        }

#endregion
#endregion
        [Fact]
        public void Dispose_CalledOnce_DisposesCorrectly()
        {
            // Act
            _service.Dispose();
            // Assert - Should not throw any exception
            Assert.True(true);
        }

        [Fact]
        public void Dispose_CalledTwice_DoesNotThrow()
        {
            // Act
            _service.Dispose();
            _service.Dispose();
            // Assert - Should not throw any exception
            Assert.True(true);
        }

        public virtual void Dispose()
        {
            _service?.Dispose();
        }
    }
}