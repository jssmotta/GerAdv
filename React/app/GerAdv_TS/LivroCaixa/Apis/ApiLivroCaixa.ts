// 100% auto-generated by Source Genesys WebApi Front & Back Creator
// copyright © 2000-2025 Menphis - Sistemas Inteligentes
// This file is part of the Source Genesys project                     
'use client';
import axios, { AxiosError, AxiosResponse } from 'axios';
import useSWR from 'swr';
import { FilterLivroCaixa } from '../Filters/LivroCaixa'
import { LivroCaixa } from '../../Models/LivroCaixa';
import { ILivroCaixa } from '../Interfaces/interface.LivroCaixa';
import { decodeBase64Token, fetcher } from '@/app/tools/Fetcher';
import { INotificationService, INotifySystemEntity, NotificationService, NotifySystemActions } from '@/app/tools/NotifySystem';
import { CRUD_CONSTANTS, decodeDataFromStorage, encodeDataForStorage } from '@/app/tools/crud';


export class LivroCaixaApiError extends Error {
  status: number;
  code?: string;
  originalError?: any;

  constructor(message: string, status: number, code?: string, originalError?: any) {
    super(message);
    this.name = 'LivroCaixaApiError';
    this.status = status;
    this.code = code;
    this.originalError = originalError;
  }

  toString() {
    return `${this.name}: ${this.message} (status: ${this.status})`;
  }
}

export class LivroCaixaApi {
    private authorization: string;
    private baseUrl: string;
    private notificationService: INotificationService;
    private uri: string;

    constructor(uri: string, authorization: string, version: number = parseInt(process.env.NEXT_PUBLIC_URL_VERSION_API ?? '1')) {
        this.authorization = authorization;
        this.baseUrl = `${process.env.NEXT_PUBLIC_URL_API_BASE}${version}/${uri}/LivroCaixa`;
        this.notificationService = new NotificationService();
        this.uri = uri;
    }

    private getHeaders() {
        return {
            headers: {
                Authorization: `Bearer ${decodeBase64Token(this.authorization)}`,
                'Content-Type': 'application/json',
                'Cache-Control': 'no-cache',     
            },
        };
    }

    private createNotificationEntity(
        id: number, 
        action: NotifySystemActions = NotifySystemActions.DELETE): INotifySystemEntity {
        return {
            entity: 'LivroCaixa',
            id: id,
            action: action
        };
    }

    private createNotificationOffLiveEntity(
        id: number,
        action: NotifySystemActions = NotifySystemActions.INFO,
        message?: string): INotifySystemEntity {
        return {
            entity: 'LivroCaixa',
            id: id,
            action: action,
            message: message ?? `Trabalhando off-line.`
        };
    }


    private handleApiError(error: any, context: string): never {
        if (axios.isAxiosError(error)) {
            const axiosError = error as AxiosError;
            const status = axiosError.response?.status || 500;
            const message = (axiosError.response?.data as { message?: string })?.message || axiosError.message;

            this.notificationService.notify(
                this.createNotificationOffLiveEntity(0, NotifySystemActions.ERROR, message ?? 'Erro desconhecido')
            );

            throw new LivroCaixaApiError(
                `${context}: ${message}`,
                status,
                axiosError.code,
                error
            );
        }
        else {
            this.notificationService.notify(
                this.createNotificationOffLiveEntity(0, NotifySystemActions.ERROR, 'Erro desconhecido')
            );
        }

        throw new LivroCaixaApiError(
            `${context}: Erro desconhecido`,
            500,
            'UNKNOWN_ERROR',
            error
        );
    }


   
        public async getAll(max: number = CRUD_CONSTANTS.DEFAULT_MAX_RECORDS): Promise<AxiosResponse> {
        const storageKey = btoa(`${process.env.NEXT_PUBLIC_APP_ID}-${this.uri}-LivroCaixa_last_getAll_${max}`);
        try {
            const response = await axios.get(`${this.baseUrl}/GetAll?max=${max}`, this.getHeaders());
            
                Promise.resolve().then(() => {
                    try {
                        const encoded = encodeDataForStorage(response.data);
                        localStorage.setItem(storageKey, encoded);
                    } catch (error) {   
                        if (process.env.NEXT_PUBLIC_SHOW_LOG === '1')
                            console.log('Erro ao salvar dados filtrados no localStorage');
                    }
                });
        
            return response;
        } catch (error: any) {
            const offlineData = localStorage.getItem(storageKey);
            if (offlineData) {
                const decoded = decodeDataFromStorage(offlineData);
                this.notificationService.notify(
                    this.createNotificationOffLiveEntity(0, NotifySystemActions.INFO)
                );
                return {
                    data: decoded,
                    status: 200,
                    statusText: 'OK (offline)',
                    headers: {},
                    config: {},
                } as AxiosResponse;
            }
            this.handleApiError(error, 'Erro ao buscar todos os LivroCaixa');
        }
    }
    
        public async getById(id: number): Promise<AxiosResponse> {
        const storageKey = btoa(`${process.env.NEXT_PUBLIC_APP_ID}-${this.uri}-LivroCaixa_last_getById_${id}`);
        try {
            const response = await axios.get(`${this.baseUrl}/GetById/${id}`, this.getHeaders());
            
                Promise.resolve().then(() => {
                    try {
                        const encoded = encodeDataForStorage(response.data);
                        localStorage.setItem(storageKey, encoded);
                    } catch (error) {   
                        if (process.env.NEXT_PUBLIC_SHOW_LOG === '1')
                            console.log('Erro ao salvar dados filtrados no localStorage');
                    }
                });
        
            return response;
        } catch (error: any) {
            const offlineData = localStorage.getItem(storageKey);
            if (offlineData) {
                const decoded = decodeDataFromStorage(offlineData);
                this.notificationService.notify(
                    this.createNotificationOffLiveEntity(id, NotifySystemActions.INFO)
                );
                return {
                    data: decoded,
                    status: 200,
                    statusText: 'OK (offline)',
                    headers: {},
                    config: {},
                } as AxiosResponse;
            }
            this.handleApiError(error, `Erro ao buscar Livro Caixa com ID ${id}`);
        }
    }
    
        public async getListN(max?: number, filtro?: FilterLivroCaixa): Promise<AxiosResponse> {
        if (max === undefined) max = CRUD_CONSTANTS.DEFAULT_MAX_RECORDS;
        const storageKey = btoa(`${process.env.NEXT_PUBLIC_APP_ID}-${this.uri}-LivroCaixa_last_listN_data`);

        try {
            const response = await axios.post(`${this.baseUrl}/GetListN/?max=${max}`, filtro, this.getHeaders());
            
                Promise.resolve().then(() => {
                    try {
                        const encoded = encodeDataForStorage(response.data);
                        localStorage.setItem(storageKey, encoded);
                    } catch (error) {   
                        if (process.env.NEXT_PUBLIC_SHOW_LOG === '1')
                            console.log('Erro ao salvar dados filtrados no localStorage');
                    }
                });
        
            return response;
        } catch (error: any) {
            const offlineData = localStorage.getItem(storageKey);
            if (offlineData) {
                const decoded = decodeDataFromStorage(offlineData);
                this.notificationService.notify(
                    this.createNotificationOffLiveEntity(0, NotifySystemActions.INFO)
                );
                return {
                    data: decoded,
                    status: 200,
                    statusText: 'OK (offline)',
                    headers: {},
                    config: {},
                } as AxiosResponse;
            }
            this.handleApiError(error, 'Erro ao buscar lista de LivroCaixa');
        }
    }
 public async filterPreload(max: number, filtro: FilterLivroCaixa): Promise<AxiosResponse> {
                        const storageKey = btoa(`${process.env.NEXT_PUBLIC_APP_ID}-${this.uri}-LivroCaixa-${max}_last_filter_data_${JSON.stringify(filtro)}`);
                        const offlineData = localStorage.getItem(storageKey);        
                        const decoded = offlineData ? decodeDataFromStorage(offlineData) : [];

                        return {
                            data: decoded,
                            status: 200,
                            statusText: 'OK (offline)',
                            headers: {},
                            config: {},
                        } as AxiosResponse;        
                    }


            public async filter(max: number, filtro: FilterLivroCaixa): Promise<AxiosResponse> {
                const storageKey = btoa(`${process.env.NEXT_PUBLIC_APP_ID}-${this.uri}-LivroCaixa-${max}_last_filter_data_${JSON.stringify(filtro)}`);
                try {
                    const response = await axios.post(`${this.baseUrl}/Filter?max=${max}`, filtro, this.getHeaders());
                    
                Promise.resolve().then(() => {
                    try {
                        const encoded = encodeDataForStorage(response.data);
                        localStorage.setItem(storageKey, encoded);
                    } catch (error) {   
                        if (process.env.NEXT_PUBLIC_SHOW_LOG === '1')
                            console.log('Erro ao salvar dados filtrados no localStorage');
                    }
                });
        
                    return response;
                } catch (error: any) {
                    const offlineData = localStorage.getItem(storageKey);
                    if (offlineData) {
                        const decoded = decodeDataFromStorage(offlineData);
                        this.notificationService.notify(
                            this.createNotificationOffLiveEntity(0, NotifySystemActions.INFO)
                        );
                        return {
                            data: decoded,
                            status: 200,
                            statusText: 'OK (offline)',
                            headers: {},
                            config: {},
                        } as AxiosResponse;
                    }

                    this.handleApiError(error, 'Erro ao filtrar LivroCaixa');
                }
            }


    public async validation(regLivroCaixa: ILivroCaixa): Promise<{ isValid: boolean; message: string } | null> {
        try {
            const result = await axios.post(`${this.baseUrl}/validation`, regLivroCaixa as LivroCaixa, this.getHeaders());
            // Se a resposta for bem-sucedida, retorna true
            return { isValid: true, message: 'Validação bem-sucedida' };
        } catch (error: any) {
            if (error.response && (error.response.status === 409 || error.response.status === 500)) {
                if (error.response && error.response.data) {
                    const { message } = error.response.data;
                    // Erro de validação, o registro já existe
                    const errorMessage = message || 'Verifique se o registro já existe!';
                    return { isValid: false, message: errorMessage };                    
                }
            }
            return { isValid: false, message: 'Erro desconhecido ao validar na base.' };;
        }
    }


    public async addAndUpdate(regLivroCaixa: ILivroCaixa): Promise<AxiosResponse> {
        try {
            var result = await axios.post(`${this.baseUrl}/AddAndUpdate`, regLivroCaixa as LivroCaixa, this.getHeaders());
            var register = result.data as ILivroCaixa;        
            const action = regLivroCaixa.id == 0 ? NotifySystemActions.ADD : NotifySystemActions.UPDATE;
            const notificationEntity = this.createNotificationEntity(register.id, action);        
            this.notificationService.notify(notificationEntity);
            return result; } 
        catch (error: any) {
            if (error.response && error.response.status === 409) {
                if (error.response && error.response.data) {
                    const { message } = error.response.data;
                    // Erro de validação, o registro já existe
                    const errorMessage = message || 'Verifique se o registro já existe!';
                    this.notificationService.notify({
                        entity: 'LivroCaixa',
                        id: regLivroCaixa.id,
                        action: NotifySystemActions.ERROR,
                        message: errorMessage
                    });

                }
            }

            this.handleApiError(error, 'Erro ao salvar Livro Caixa');
        }
    }

    public async delete(id: number): Promise<AxiosResponse | void> {
        try {
            const result = await axios.delete(`${this.baseUrl}/Delete?id=${id}`, this.getHeaders());
             if (result.data) {
                /* if (result.data.success === false) {
                    throw new Error(result.data.message || 'Erro ao excluir.');
                } */
                const notificationEntity = this.createNotificationEntity(id, NotifySystemActions.DELETE);
                this.notificationService.notify(notificationEntity);
            }
            return result;
        } catch (error: any) {
            if (error.response && error.response.status === 409) {
              if (error.response && error.response.data) {
                    const { message } = error.response.data;
                    // Conflito, o registro está vinculado a outros registros
                    const errorMessage = message|| 'Erro ao excluir o LivroCaixa. Verifique se ele não está vinculado a outros registros.';
                    this.notificationService.notify({
                        entity: 'LivroCaixa',
                        id: id,
                        action: NotifySystemActions.ERROR,
                        message: errorMessage
                    });
                    throw new Error(error.data.message || 'Erro ao excluir.');
                }
            }
             this.handleApiError(error, `Erro ao excluir Livro Caixa com ID ${id}`);                
        }
    }




    public useFilter(filtro: FilterLivroCaixa) {
       const url = `${this.baseUrl}/Filter`;
       const key = `${url}::${this.authorization}::${JSON.stringify(filtro)}`;
    
        return useSWR<LivroCaixa[]>(key, fetcher, {
          revalidateOnFocus: false,
          revalidateOnReconnect: false,
          onError: (error) => {            
            if (process.env.NEXT_PUBLIC_SHOW_LOG === '1')
                console.log('Erro no SWR para filtro de LivroCaixa');
            this.notificationService.notify({
              entity: 'LivroCaixa',
              id: 0,
              action: NotifySystemActions.ERROR,
              message: 'Erro ao carregar dados dos livrocaixa'
            });
          }
        });
    }

}
