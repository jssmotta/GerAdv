// 100% auto-generated by Source Genesys WebApi Front & Back Creator
// copyright © 2000-2025 Menphis - Sistemas Inteligentes
// This file is part of the Source Genesys project                     
#pragma warning disable IDE0130 // Namespace does not match folder structure

namespace MenphisSI.GerAdv.Services;
#pragma warning restore IDE0130 // Namespace does not match folder structure

public partial class ClientesService(IOptions<AppSettings> appSettings, IFClientesFactory clientesFactory, IClientesReader reader, IClientesValidation validation, IClientesWriter writer, ICidadeReader cidadeReader, IRegimeTributacaoReader regimetributacaoReader, IEnquadramentoEmpresaReader enquadramentoempresaReader, IAgendaService agendaService, IClientesSociosService clientessociosService, IColaboradoresService colaboradoresService, IContaCorrenteService contacorrenteService, IContratosService contratosService, IDiario2Service diario2Service, IGruposEmpresasService gruposempresasService, IHonorariosDadosContratoService honorariosdadoscontratoService, IHorasTrabService horastrabService, ILigacoesService ligacoesService, IOperadoresService operadoresService, IPreClientesService preclientesService, IProDespesasService prodespesasService, IReuniaoService reuniaoService, IHttpContextAccessor httpContextAccessor, HybridCache cache, IMemoryCache memory) : IClientesService, IDisposable
{
    private readonly IHttpContextAccessor _httpContextAccessor = httpContextAccessor;
    private readonly IOptions<AppSettings> _appSettings = appSettings;
    private readonly HybridCache _cache = cache;
    private readonly IMemoryCache _memoryCache = memory;
    private bool _disposed;
    private readonly IFClientesFactory clientesFactory = clientesFactory;
    private readonly IClientesReader reader = reader;
    private readonly IClientesValidation validation = validation;
    private readonly IClientesWriter writer = writer;
    private readonly ICidadeReader cidadeReader = cidadeReader;
    private readonly IRegimeTributacaoReader regimetributacaoReader = regimetributacaoReader;
    private readonly IEnquadramentoEmpresaReader enquadramentoempresaReader = enquadramentoempresaReader;
    private readonly IAgendaService agendaService = agendaService;
    private readonly IClientesSociosService clientessociosService = clientessociosService;
    private readonly IColaboradoresService colaboradoresService = colaboradoresService;
    private readonly IContaCorrenteService contacorrenteService = contacorrenteService;
    private readonly IContratosService contratosService = contratosService;
    private readonly IDiario2Service diario2Service = diario2Service;
    private readonly IGruposEmpresasService gruposempresasService = gruposempresasService;
    private readonly IHonorariosDadosContratoService honorariosdadoscontratoService = honorariosdadoscontratoService;
    private readonly IHorasTrabService horastrabService = horastrabService;
    private readonly ILigacoesService ligacoesService = ligacoesService;
    private readonly IOperadoresService operadoresService = operadoresService;
    private readonly IPreClientesService preclientesService = preclientesService;
    private readonly IProDespesasService prodespesasService = prodespesasService;
    private readonly IReuniaoService reuniaoService = reuniaoService;
    public async Task<IEnumerable<ClientesResponseAll>> GetAll(int max, [FromRoute, Required] string uri, CancellationToken token = default)
    {
        max = Math.Min(Math.Max(max, 1), BaseConsts.PMaxItens);
        ThrowIfDisposed();
        if (!Uris.ValidaUri(uri, _appSettings))
        {
            throw new Exception("Clientes: URI inválida");
        }

        var entryOptions = new HybridCacheEntryOptions
        {
            Expiration = TimeSpan.FromMinutes(BaseConsts.PMaxMinutesCache),
            LocalCacheExpiration = TimeSpan.FromMinutes(BaseConsts.PMaxMinutesCache)
        };
        using var oCnn = Configuracoes.GetConnectionByUri(uri);
        var keyCache = await reader.ReadStringAuditor(max, uri, "", [], oCnn);
        var cacheKey = $"{uri}-Clientes-Filter-{max}-{keyCache}";
        var result = await _cache.GetOrCreateAsync(cacheKey, async cancel => await GetDataAllAsync(max, string.Empty, [], uri, cancel), entryOptions, cancellationToken: token);
        return result;
    }

    public async Task<IEnumerable<ClientesResponseAll>> Filter([FromQuery] int max, [FromBody] Filters.FilterClientes filtro, [FromRoute, Required] string uri)
    {
        ThrowIfDisposed();
        using var oCnn = Configuracoes.GetConnectionByUri(uri);
        if (oCnn == null)
        {
            throw new DatabaseConnectionException();
        }

        if (max <= 0)
        {
            max = BaseConsts.PMaxItens;
        }

        var filtroResult = filtro == null ? null : WFiltro(filtro!);
        string where = filtroResult?.where ?? string.Empty;
        List<SqlParameter> parameters = filtroResult?.parametros ?? [];
        var filterHash = GetFilterHash(filtro);
        var keyCache = await reader.ReadStringAuditor(max, uri, where, parameters, oCnn);
        var cacheKey = $"{uri}-{max}Clientes-Filter-{where.GetHashCode2()}{filterHash}{keyCache}";
        var entryOptions = new HybridCacheEntryOptions
        {
            Expiration = TimeSpan.FromSeconds(BaseConsts.PMaxGetListSecondsCacheId),
            LocalCacheExpiration = TimeSpan.FromSeconds(BaseConsts.PMaxGetListSecondsCacheId)
        };
        var result = await _cache.GetOrCreateAsync(cacheKey, async cancel => await GetDataAllAsync(max, string.IsNullOrEmpty(where) ? string.Empty : TSql.Where + where, parameters, uri, cancel), entryOptions, cancellationToken: new());
        return result;
    }

    public async Task<ClientesResponse?> GetById([FromQuery] int id, [FromRoute, Required] string uri, CancellationToken token)
    {
        ThrowIfDisposed();
        if (id < 1)
        {
            return new ClientesResponse();
        }

        var entryOptions = new HybridCacheEntryOptions
        {
            Expiration = TimeSpan.FromSeconds(BaseConsts.PMaxSecondsCacheId),
            LocalCacheExpiration = TimeSpan.FromSeconds(BaseConsts.PMaxSecondsCacheId)
        };
        using var oCnn = Configuracoes.GetConnectionByUri(uri);
        try
        {
            var keyCache = await reader.ReadStringAuditor(id, uri, oCnn);
            var result = await _cache.GetOrCreateAsync($"{uri}-Clientes-GetById-{id}-{keyCache}", async cancel => await GetDataByIdAsync(id, oCnn, cancel), entryOptions, cancellationToken: token);
            return result;
        }
        catch (Exception)
        {
            throw new Exception($"Clientes - {uri}-: GetById");
        }
    }

    private async Task<ClientesResponse?> GetDataByIdAsync(int id, MsiSqlConnection? oCnn, CancellationToken token) => await reader.Read(id, oCnn);
    public async Task<ClientesResponse?> AddAndUpdate([FromBody] Models.Clientes? regClientes, [FromRoute, Required] string uri)
    {
        ThrowIfDisposed();
        if (regClientes == null)
        {
            return null;
        }

        if (!Uris.ValidaUri(uri, _appSettings))
        {
            throw new Exception("Clientes: URI inválida");
        }

        using var oCnn = Configuracoes.GetConnectionByUriRw(uri);
        if (oCnn == null)
        {
            return null;
        }

        try
        {
            var validade = await validation.ValidateReg(regClientes, this, cidadeReader, regimetributacaoReader, enquadramentoempresaReader, uri, oCnn);
            if (!validade)
            {
                throw new Exception("Erro inesperado ao validar 0x0!");
            }
        }
        catch (SGValidationException ex)
        {
            throw new Exception(ex.Message);
        }
        catch (Exception)
        {
            throw new Exception("Erro inesperado ao validar 0x1!");
        }

        int operadorId = UserTools.GetAuthenticatedUserId(_httpContextAccessor);
        using var saved = await writer.WriteAsync(regClientes, operadorId, oCnn);
        return reader.Read(saved, oCnn);
    }

    public async Task<ClientesResponse?> Validation([FromBody] Models.Clientes? regClientes, [FromRoute, Required] string uri)
    {
        ThrowIfDisposed();
        if (regClientes == null)
        {
            return null;
        }

        if (!Uris.ValidaUri(uri, _appSettings))
        {
            throw new Exception("Clientes: URI inválida");
        }

        using var oCnn = Configuracoes.GetConnectionByUriRw(uri);
        if (oCnn == null)
        {
            return null;
        }

        try
        {
            var validade = await validation.ValidateReg(regClientes, this, cidadeReader, regimetributacaoReader, enquadramentoempresaReader, uri, oCnn);
            if (!validade)
            {
                throw new Exception("Erro inesperado ao validar 0x0!");
            }
        }
        catch (SGValidationException ex)
        {
            throw new Exception(ex.Message);
        }
        catch (Exception)
        {
            throw new Exception("Erro inesperado ao validar 0x1!");
        }

        if (regClientes.Id.IsEmptyIDNumber())
        {
            return new ClientesResponse();
        }

        return await reader.Read(regClientes.Id, oCnn);
    }

    public async Task<ClientesResponse?> Delete([FromQuery] int? id, [FromRoute, Required] string uri)
    {
        if (id == null || id.IsEmptyIDNumber())
        {
            return null;
        }

        ThrowIfDisposed();
        if (!Uris.ValidaUri(uri, _appSettings))
        {
            throw new Exception("Clientes: URI inválida");
        }

        var nOperador = UserTools.GetAuthenticatedUserId(_httpContextAccessor);
        using var oCnn = Configuracoes.GetConnectionByUriRw(uri);
        if (oCnn == null)
        {
            return null;
        }

        try
        {
            var deleteValidation = await validation.CanDelete(id, this, agendaService, clientessociosService, colaboradoresService, contacorrenteService, contratosService, diario2Service, gruposempresasService, honorariosdadoscontratoService, horastrabService, ligacoesService, operadoresService, preclientesService, prodespesasService, reuniaoService, uri, oCnn);
            if (!deleteValidation)
            {
                throw new Exception("Erro inesperado ao validar 0x0!");
            }
        }
        catch (SGValidationException ex)
        {
            throw new Exception(ex.Message);
        }
        catch (Exception)
        {
            throw new Exception("Erro inesperado ao validar 0x1!");
        }

        var clientes = await reader.Read(id ?? default, oCnn);
        try
        {
            if (clientes != null)
            {
                await writer.Delete(clientes, nOperador, oCnn);
                if (_memoryCache is MemoryCache memCache)
                {
                    memCache.Compact(1.0);
                }
            }
        }
        catch (Exception ex)
        {
            throw new Exception(ex.Message);
        }

        return clientes;
    }

    public virtual void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (_disposed)
            return;
        if (disposing)
        {
        //_cache?.Dispose();
        }

        _disposed = true;
    }

    private void ThrowIfDisposed()
    {
        if (_disposed)
        {
            throw new ObjectDisposedException(GetType().Name);
        }
    }
}