// 100% auto-generated by Source Genesys WebApi Front & Back Creator
// copyright © 2000-2025 Menphis - Sistemas Inteligentes
// This file is part of the Source Genesys project                     
namespace MenphisSI.GerAdv.WFiltro.Tests
{
    public class InstanciaServiceWFiltroTests : IDisposable
    {
        private readonly Mock<IOptions<AppSettings>> _mockAppSettings;
        private readonly Mock<IFInstanciaFactory> _mockInstanciaFactory;
        private readonly Mock<IInstanciaReader> _mockReader;
        private readonly Mock<IInstanciaValidation> _mockValidation;
        private readonly Mock<IInstanciaWriter> _mockWriter;
        private readonly Mock<INENotasService> _mockNENotasService;
        private readonly Mock<IProSucumbenciaService> _mockProSucumbenciaService;
        private readonly Mock<ITribunalService> _mockTribunalService;
        private readonly Mock<IAcaoReader> _mockAcaoReader;
        private readonly Mock<IForoReader> _mockForoReader;
        private readonly Mock<ITipoRecursoReader> _mockTipoRecursoReader;
        private readonly Mock<IHttpContextAccessor> _mockHttpContextAccessor;
        private readonly Mock<HybridCache> _mockCache;
        private readonly Mock<IMemoryCache> _mockMemoryCache;
        private readonly InstanciaService _service;
        public InstanciaServiceWFiltroTests()
        {
            _mockAppSettings = new Mock<IOptions<AppSettings>>();
            _mockInstanciaFactory = new Mock<IFInstanciaFactory>();
            _mockReader = new Mock<IInstanciaReader>();
            _mockValidation = new Mock<IInstanciaValidation>();
            _mockWriter = new Mock<IInstanciaWriter>();
            _mockNENotasService = new Mock<INENotasService>();
            _mockProSucumbenciaService = new Mock<IProSucumbenciaService>();
            _mockTribunalService = new Mock<ITribunalService>();
            _mockAcaoReader = new Mock<IAcaoReader>();
            _mockForoReader = new Mock<IForoReader>();
            _mockTipoRecursoReader = new Mock<ITipoRecursoReader>();
            _mockHttpContextAccessor = new Mock<IHttpContextAccessor>();
            _mockCache = new Mock<HybridCache>();
            _mockMemoryCache = new Mock<IMemoryCache>();
            var appSettings = new AppSettings();
            _mockAppSettings.Setup(x => x.Value).Returns(appSettings);
            _service = new InstanciaService(_mockAppSettings.Object, _mockInstanciaFactory.Object, _mockReader.Object, _mockValidation.Object, _mockWriter.Object, _mockAcaoReader.Object, _mockForoReader.Object, _mockTipoRecursoReader.Object, _mockNENotasService.Object, _mockProSucumbenciaService.Object, _mockTribunalService.Object, _mockHttpContextAccessor.Object, _mockCache.Object, _mockMemoryCache.Object);
        }

        [Fact]
        public void WFiltro_QuandoFiltroEhNull_DeveRetornarResultadoVazio()
        {
            // Arrange
            FilterInstancia? filtro = null;
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().BeNull();
        }

        [Fact]
        public void WFiltro_QuandoTodosCamposSaoValoresPadrao_DeveRetornarResultadoVazio()
        {
            // Arrange
            var filtro = new FilterInstancia(); // Todos os valores padrão
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_ComTodosOsCamposPreenchidos_DeveProcessarRapidamente()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                LiminarPedida = "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM",
                Objeto = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
                StatusResultado = 1,
                LiminarPendente = 2,
                InterpusemosRecurso = 1,
                LiminarConcedida = 2,
                LiminarNegada = 1,
                Processo = 1,
                Data = "27/05/2022",
                LiminarParcial = 2,
                LiminarResultado = "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM",
                NroProcesso = "AAAAAAAAAAAAAAAAAAAAAAA",
                Divisao = 1,
                LiminarCliente = 1,
                Comarca = 1,
                SubDivisao = 1,
                Principal = 2,
                Acao = 1,
                Foro = 1,
                TipoRecurso = 1,
                ZKey = "AAAAAAAAAAAAAAAAAAAAAAA",
                ZKeyQuem = 1,
                ZKeyQuando = "24/04/1975",
                NroAntigo = "AAAAAAAAAAAAAAAAAAAAAAA",
                AccessCode = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
                Julgador = 1,
                ZKeyIA = "AAAAAAAAAAAAAAAAAAAAAAA",
                GUID = Guid.NewGuid().ToString(),
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var stopwatch = System.Diagnostics.Stopwatch.StartNew();
            var resultado = _service.WFiltro(filtro);
            stopwatch.Stop();
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().NotBeEmpty();
            resultado.Value.where.Should().NotBeEmpty();
            stopwatch.ElapsedMilliseconds.Should().BeLessThan(100); // Deve processar em menos de 100ms
        }

#region String Tests
        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_LiminarPedida_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string liminarpedidaComWhitespace)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                LiminarPedida = liminarpedidaComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_LiminarPedida_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var liminarpedidaGigante = new string ('A', 1000);
            var filtro = new FilterInstancia
            {
                LiminarPedida = liminarpedidaGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{liminarpedidaGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_LiminarPedida_ComCaracteresEspeciais_DeveProcessarCorretamente(string liminarpedidaComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                LiminarPedida = liminarpedidaComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(liminarpedidaComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_LiminarPedidaInstancia_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                LiminarPedida = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_LiminarPedidaInstancia_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                LiminarPedida = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_LiminarPedidaInstancia_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeInstancia = "João Silva";
            var filtro = new FilterInstancia
            {
                LiminarPedida = nomeInstancia,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_LiminarPedidaInstancia_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                LiminarPedida = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_LiminarPedidaInstancia_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                LiminarPedida = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_LiminarPedidaInstancia_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeInstancia)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                LiminarPedida = nomeInstancia,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_LiminarPedidaInstancia_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                LiminarPedida = "João",
                StatusResultado = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@insLiminarPedida");
            resultado.Value.where.Should().Contain("@insStatusResultado");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @insLiminarPedida");
            resultado.Value.where.Should().Contain("= @insStatusResultado");
        }

        [Fact]
        public void WFiltro_LiminarPedidaInstancia_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeInstancia = "João Silva";
            var filtro = new FilterInstancia
            {
                LiminarPedida = nomeInstancia,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.LiminarPedida}]");
            resultado.Value.where.Should().Contain("like @insLiminarPedida");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@insLiminarPedida");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_Objeto_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string objetoComWhitespace)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Objeto = objetoComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_Objeto_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var objetoGigante = new string ('A', 1000);
            var filtro = new FilterInstancia
            {
                Objeto = objetoGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{objetoGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_Objeto_ComCaracteresEspeciais_DeveProcessarCorretamente(string objetoComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Objeto = objetoComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(objetoComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_ObjetoInstancia_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Objeto = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_ObjetoInstancia_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Objeto = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_ObjetoInstancia_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeInstancia = "João Silva";
            var filtro = new FilterInstancia
            {
                Objeto = nomeInstancia,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_ObjetoInstancia_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Objeto = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_ObjetoInstancia_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Objeto = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_ObjetoInstancia_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeInstancia)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Objeto = nomeInstancia,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_ObjetoInstancia_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Objeto = "João",
                StatusResultado = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@insObjeto");
            resultado.Value.where.Should().Contain("@insStatusResultado");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @insObjeto");
            resultado.Value.where.Should().Contain("= @insStatusResultado");
        }

        [Fact]
        public void WFiltro_ObjetoInstancia_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeInstancia = "João Silva";
            var filtro = new FilterInstancia
            {
                Objeto = nomeInstancia,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.Objeto}]");
            resultado.Value.where.Should().Contain("like @insObjeto");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@insObjeto");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Fact]
        public void WFiltro_DataInstancia_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Data = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_DataInstancia_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Data = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_DataInstancia_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeInstancia = "João Silva";
            var filtro = new FilterInstancia
            {
                Data = nomeInstancia,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_DataInstancia_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Data = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_DataInstancia_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Data = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_DataInstancia_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeInstancia)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Data = nomeInstancia,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DataInstancia_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Data = "João",
                StatusResultado = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@insData");
            resultado.Value.where.Should().Contain("@insStatusResultado");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @insData");
            resultado.Value.where.Should().Contain("= @insStatusResultado");
        }

        [Fact]
        public void WFiltro_DataInstancia_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeInstancia = "João Silva";
            var filtro = new FilterInstancia
            {
                Data = nomeInstancia,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.Data}]");
            resultado.Value.where.Should().Contain("like @insData");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@insData");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_LiminarResultado_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string liminarresultadoComWhitespace)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                LiminarResultado = liminarresultadoComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_LiminarResultado_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var liminarresultadoGigante = new string ('A', 1000);
            var filtro = new FilterInstancia
            {
                LiminarResultado = liminarresultadoGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{liminarresultadoGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_LiminarResultado_ComCaracteresEspeciais_DeveProcessarCorretamente(string liminarresultadoComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                LiminarResultado = liminarresultadoComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(liminarresultadoComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_LiminarResultadoInstancia_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                LiminarResultado = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_LiminarResultadoInstancia_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                LiminarResultado = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_LiminarResultadoInstancia_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeInstancia = "João Silva";
            var filtro = new FilterInstancia
            {
                LiminarResultado = nomeInstancia,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_LiminarResultadoInstancia_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                LiminarResultado = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_LiminarResultadoInstancia_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                LiminarResultado = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_LiminarResultadoInstancia_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeInstancia)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                LiminarResultado = nomeInstancia,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_LiminarResultadoInstancia_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                LiminarResultado = "João",
                StatusResultado = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@insLiminarResultado");
            resultado.Value.where.Should().Contain("@insStatusResultado");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @insLiminarResultado");
            resultado.Value.where.Should().Contain("= @insStatusResultado");
        }

        [Fact]
        public void WFiltro_LiminarResultadoInstancia_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeInstancia = "João Silva";
            var filtro = new FilterInstancia
            {
                LiminarResultado = nomeInstancia,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.LiminarResultado}]");
            resultado.Value.where.Should().Contain("like @insLiminarResultado");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@insLiminarResultado");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_NroProcesso_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string nroprocessoComWhitespace)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                NroProcesso = nroprocessoComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_NroProcesso_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var nroprocessoGigante = new string ('A', 1000);
            var filtro = new FilterInstancia
            {
                NroProcesso = nroprocessoGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{nroprocessoGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_NroProcesso_ComCaracteresEspeciais_DeveProcessarCorretamente(string nroprocessoComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                NroProcesso = nroprocessoComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(nroprocessoComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_NroProcessoInstancia_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                NroProcesso = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_NroProcessoInstancia_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                NroProcesso = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_NroProcessoInstancia_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeInstancia = "João Silva";
            var filtro = new FilterInstancia
            {
                NroProcesso = nomeInstancia,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_NroProcessoInstancia_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                NroProcesso = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_NroProcessoInstancia_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                NroProcesso = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_NroProcessoInstancia_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeInstancia)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                NroProcesso = nomeInstancia,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_NroProcessoInstancia_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                NroProcesso = "João",
                StatusResultado = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@insNroProcesso");
            resultado.Value.where.Should().Contain("@insStatusResultado");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @insNroProcesso");
            resultado.Value.where.Should().Contain("= @insStatusResultado");
        }

        [Fact]
        public void WFiltro_NroProcessoInstancia_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeInstancia = "João Silva";
            var filtro = new FilterInstancia
            {
                NroProcesso = nomeInstancia,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.NroProcesso}]");
            resultado.Value.where.Should().Contain("like @insNroProcesso");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@insNroProcesso");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_ZKey_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string zkeyComWhitespace)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKey = zkeyComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_ZKey_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var zkeyGigante = new string ('A', 1000);
            var filtro = new FilterInstancia
            {
                ZKey = zkeyGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{zkeyGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_ZKey_ComCaracteresEspeciais_DeveProcessarCorretamente(string zkeyComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKey = zkeyComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(zkeyComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_ZKeyInstancia_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKey = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_ZKeyInstancia_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKey = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_ZKeyInstancia_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeInstancia = "João Silva";
            var filtro = new FilterInstancia
            {
                ZKey = nomeInstancia,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_ZKeyInstancia_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKey = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_ZKeyInstancia_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKey = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_ZKeyInstancia_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeInstancia)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKey = nomeInstancia,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_ZKeyInstancia_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKey = "João",
                StatusResultado = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@insZKey");
            resultado.Value.where.Should().Contain("@insStatusResultado");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @insZKey");
            resultado.Value.where.Should().Contain("= @insStatusResultado");
        }

        [Fact]
        public void WFiltro_ZKeyInstancia_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeInstancia = "João Silva";
            var filtro = new FilterInstancia
            {
                ZKey = nomeInstancia,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.ZKey}]");
            resultado.Value.where.Should().Contain("like @insZKey");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@insZKey");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_NroAntigo_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string nroantigoComWhitespace)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                NroAntigo = nroantigoComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_NroAntigo_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var nroantigoGigante = new string ('A', 1000);
            var filtro = new FilterInstancia
            {
                NroAntigo = nroantigoGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{nroantigoGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_NroAntigo_ComCaracteresEspeciais_DeveProcessarCorretamente(string nroantigoComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                NroAntigo = nroantigoComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(nroantigoComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_NroAntigoInstancia_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                NroAntigo = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_NroAntigoInstancia_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                NroAntigo = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_NroAntigoInstancia_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeInstancia = "João Silva";
            var filtro = new FilterInstancia
            {
                NroAntigo = nomeInstancia,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_NroAntigoInstancia_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                NroAntigo = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_NroAntigoInstancia_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                NroAntigo = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_NroAntigoInstancia_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeInstancia)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                NroAntigo = nomeInstancia,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_NroAntigoInstancia_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                NroAntigo = "João",
                StatusResultado = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@insNroAntigo");
            resultado.Value.where.Should().Contain("@insStatusResultado");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @insNroAntigo");
            resultado.Value.where.Should().Contain("= @insStatusResultado");
        }

        [Fact]
        public void WFiltro_NroAntigoInstancia_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeInstancia = "João Silva";
            var filtro = new FilterInstancia
            {
                NroAntigo = nomeInstancia,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.NroAntigo}]");
            resultado.Value.where.Should().Contain("like @insNroAntigo");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@insNroAntigo");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_AccessCode_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string accesscodeComWhitespace)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                AccessCode = accesscodeComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_AccessCode_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var accesscodeGigante = new string ('A', 1000);
            var filtro = new FilterInstancia
            {
                AccessCode = accesscodeGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{accesscodeGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_AccessCode_ComCaracteresEspeciais_DeveProcessarCorretamente(string accesscodeComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                AccessCode = accesscodeComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(accesscodeComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_AccessCodeInstancia_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                AccessCode = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_AccessCodeInstancia_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                AccessCode = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_AccessCodeInstancia_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeInstancia = "João Silva";
            var filtro = new FilterInstancia
            {
                AccessCode = nomeInstancia,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_AccessCodeInstancia_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                AccessCode = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_AccessCodeInstancia_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                AccessCode = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_AccessCodeInstancia_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeInstancia)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                AccessCode = nomeInstancia,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_AccessCodeInstancia_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                AccessCode = "João",
                StatusResultado = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@insAccessCode");
            resultado.Value.where.Should().Contain("@insStatusResultado");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @insAccessCode");
            resultado.Value.where.Should().Contain("= @insStatusResultado");
        }

        [Fact]
        public void WFiltro_AccessCodeInstancia_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeInstancia = "João Silva";
            var filtro = new FilterInstancia
            {
                AccessCode = nomeInstancia,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.AccessCode}]");
            resultado.Value.where.Should().Contain("like @insAccessCode");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@insAccessCode");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_ZKeyIA_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string zkeyiaComWhitespace)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyIA = zkeyiaComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_ZKeyIA_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var zkeyiaGigante = new string ('A', 1000);
            var filtro = new FilterInstancia
            {
                ZKeyIA = zkeyiaGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{zkeyiaGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_ZKeyIA_ComCaracteresEspeciais_DeveProcessarCorretamente(string zkeyiaComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyIA = zkeyiaComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(zkeyiaComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_ZKeyIAInstancia_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyIA = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_ZKeyIAInstancia_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyIA = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_ZKeyIAInstancia_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeInstancia = "João Silva";
            var filtro = new FilterInstancia
            {
                ZKeyIA = nomeInstancia,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_ZKeyIAInstancia_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyIA = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_ZKeyIAInstancia_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyIA = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_ZKeyIAInstancia_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeInstancia)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyIA = nomeInstancia,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_ZKeyIAInstancia_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyIA = "João",
                StatusResultado = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@insZKeyIA");
            resultado.Value.where.Should().Contain("@insStatusResultado");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @insZKeyIA");
            resultado.Value.where.Should().Contain("= @insStatusResultado");
        }

        [Fact]
        public void WFiltro_ZKeyIAInstancia_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeInstancia = "João Silva";
            var filtro = new FilterInstancia
            {
                ZKeyIA = nomeInstancia,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.ZKeyIA}]");
            resultado.Value.where.Should().Contain("like @insZKeyIA");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@insZKeyIA");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_GUID_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string guidComWhitespace)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                GUID = guidComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_GUID_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var guidGigante = new string ('A', 1000);
            var filtro = new FilterInstancia
            {
                GUID = guidGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{guidGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_GUID_ComCaracteresEspeciais_DeveProcessarCorretamente(string guidComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                GUID = guidComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(guidComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_GUIDInstancia_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                GUID = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_GUIDInstancia_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                GUID = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_GUIDInstancia_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeInstancia = "João Silva";
            var filtro = new FilterInstancia
            {
                GUID = nomeInstancia,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_GUIDInstancia_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                GUID = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_GUIDInstancia_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                GUID = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_GUIDInstancia_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeInstancia)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                GUID = nomeInstancia,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_GUIDInstancia_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                GUID = "João",
                StatusResultado = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@insGUID");
            resultado.Value.where.Should().Contain("@insStatusResultado");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @insGUID");
            resultado.Value.where.Should().Contain("= @insStatusResultado");
        }

        [Fact]
        public void WFiltro_GUIDInstancia_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeInstancia = "João Silva";
            var filtro = new FilterInstancia
            {
                GUID = nomeInstancia,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.GUID}]");
            resultado.Value.where.Should().Contain("like @insGUID");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@insGUID");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

#endregion
#region Integer Tests
#region filtro.StatusResultado_end Tests
        [Fact]
        public void WFiltro_StatusResultado_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                StatusResultado_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_StatusResultado_end_QuandoTemValorPositivo_SemStatusResultadoInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorStatusResultadoEnd = 5000;
            var filtro = new FilterInstancia
            {
                StatusResultado = int.MinValue, // Não define salário inicial
                StatusResultado_end = valorStatusResultadoEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há StatusResultado inicial válido, não deve incluir condição WHERE, mas o parâmetro StatusResultado_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // StatusResultado_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_StatusResultado_end_QuandoSomenteValorInicial_SemStatusResultadoEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorStatusResultado = 2500;
            var filtro = new FilterInstancia
            {
                StatusResultado = valorStatusResultado,
                StatusResultado_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.StatusResultado}] = @{DBInstanciaDicInfo.StatusResultado}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBInstanciaDicInfo.StatusResultado}");
            parametro.Value.Should().Be(valorStatusResultado);
        }

        [Fact]
        public void WFiltro_StatusResultado_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorStatusResultadoInicial = 1000;
            var valorStatusResultadoFinal = 5000;
            var filtro = new FilterInstancia
            {
                StatusResultado = valorStatusResultadoInicial,
                StatusResultado_end = valorStatusResultadoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].{DBInstanciaDicInfo.StatusResultado} BETWEEN @{DBInstanciaDicInfo.StatusResultado} AND @{DBInstanciaDicInfo.StatusResultado}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.StatusResultado}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.StatusResultado}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorStatusResultadoInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorStatusResultadoFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_StatusResultado_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                StatusResultado = valorInicial,
                StatusResultado_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.StatusResultado}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.StatusResultado}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_StatusResultado_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                StatusResultado = 1000,
                StatusResultado_end = 5000,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.StatusResultado}");
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Objeto}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_StatusResultado_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                StatusResultado = 1000,
                StatusResultado_end = 5000,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_StatusResultado_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                StatusResultado = 1000,
                StatusResultado_end = 5000,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_StatusResultado_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                StatusResultado = 1000,
                StatusResultado_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].{DBInstanciaDicInfo.StatusResultado} BETWEEN");
        }

        [Fact]
        public void WFiltro_StatusResultado_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                StatusResultado = 1000,
                StatusResultado_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_StatusResultado_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                StatusResultado = 1000,
                StatusResultado_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_StatusResultado_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorStatusResultadoInicial = 2500;
            var valorStatusResultadoFinal = 4750;
            var filtro = new FilterInstancia
            {
                StatusResultado = valorStatusResultadoInicial,
                StatusResultado_end = valorStatusResultadoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.StatusResultado}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.StatusResultado}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorStatusResultadoInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorStatusResultadoFinal);
        }

        [Fact]
        public void WFiltro_StatusResultado_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                StatusResultado = 0,
                StatusResultado_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_StatusResultado_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                StatusResultado = 0,
                StatusResultado_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_StatusResultado_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                StatusResultado = 1500,
                StatusResultado_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.StatusResultado == int.MinValue) && !(filtro.StatusResultado_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBInstanciaDicInfo.PTabelaNome}].{DBInstanciaDicInfo.StatusResultado} BETWEEN @{DBInstanciaDicInfo.StatusResultado} AND @{DBInstanciaDicInfo.StatusResultado}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_StatusResultado_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                StatusResultado = 2000,
                StatusResultado_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.StatusResultado == int.MinValue) && filtro.StatusResultado_end == int.MinValue
            // Deve resultar em igualdade quando apenas StatusResultado tem valor válido
            resultado.Value.where.Should().Be($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.StatusResultado}] = @{DBInstanciaDicInfo.StatusResultado}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_StatusResultado_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                StatusResultado = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.StatusResultado Isolated Tests
        [Fact]
        public void WFiltro_StatusResultado_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                StatusResultado = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_StatusResultado_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorStatusResultado = 5;
            var filtro = new FilterInstancia
            {
                StatusResultado = valorStatusResultado,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.StatusResultado}] = @{DBInstanciaDicInfo.StatusResultado}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBInstanciaDicInfo.StatusResultado}");
            parametro.Value.Should().Be(valorStatusResultado);
        }

        [Fact]
        public void WFiltro_StatusResultado_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorStatusResultado = 0;
            var filtro = new FilterInstancia
            {
                StatusResultado = valorStatusResultado,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBInstanciaDicInfo.StatusResultado}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorStatusResultado);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_StatusResultado_DiferentesValoresValidos_DeveProcessarCorretamente(int valorStatusResultado)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                StatusResultado = valorStatusResultado,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorStatusResultado);
            resultado.Value.where.Should().Contain($"= @{DBInstanciaDicInfo.StatusResultado}");
        }

        [Fact]
        public void WFiltro_StatusResultado_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                StatusResultado = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.StatusResultado}");
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Objeto}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_StatusResultado_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                StatusResultado = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_StatusResultado_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                StatusResultado = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_StatusResultado_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                StatusResultado = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_StatusResultado_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                StatusResultado = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.StatusResultado}]");
        }

        [Fact]
        public void WFiltro_StatusResultado_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                StatusResultado = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_StatusResultado_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                StatusResultado = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_StatusResultado_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                StatusResultado = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_StatusResultado_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorStatusResultado = 42;
            var filtro = new FilterInstancia
            {
                StatusResultado = valorStatusResultado,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorStatusResultado);
        }

#endregion
        [Fact]
        public void WFiltro_StatusResultado_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                StatusResultado = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_StatusResultado_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorStatusResultado = 1;
            var filtro = new FilterInstancia
            {
                StatusResultado = valorStatusResultado,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do StatusResultado
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.StatusResultado}] = @insStatusResultado");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@insStatusResultado");
            parametro.Value.Should().Be(valorStatusResultado);
        }

        [Fact]
        public void WFiltro_StatusResultado_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                StatusResultado = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@insStatusResultado");
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Objeto}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_StatusResultado_DiferentesValores_DeveFuncionar(int valorStatusResultado)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                StatusResultado = valorStatusResultado,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorStatusResultado);
        }

#region filtro.Processo_end Tests
        [Fact]
        public void WFiltro_Processo_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Processo_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Processo_end_QuandoTemValorPositivo_SemProcessoInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorProcessoEnd = 5000;
            var filtro = new FilterInstancia
            {
                Processo = int.MinValue, // Não define salário inicial
                Processo_end = valorProcessoEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Processo inicial válido, não deve incluir condição WHERE, mas o parâmetro Processo_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Processo_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Processo_end_QuandoSomenteValorInicial_SemProcessoEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorProcesso = 2500;
            var filtro = new FilterInstancia
            {
                Processo = valorProcesso,
                Processo_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.Processo}] = @{DBInstanciaDicInfo.Processo}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBInstanciaDicInfo.Processo}");
            parametro.Value.Should().Be(valorProcesso);
        }

        [Fact]
        public void WFiltro_Processo_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorProcessoInicial = 1000;
            var valorProcessoFinal = 5000;
            var filtro = new FilterInstancia
            {
                Processo = valorProcessoInicial,
                Processo_end = valorProcessoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].{DBInstanciaDicInfo.Processo} BETWEEN @{DBInstanciaDicInfo.Processo} AND @{DBInstanciaDicInfo.Processo}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.Processo}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.Processo}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorProcessoInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorProcessoFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Processo_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Processo = valorInicial,
                Processo_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.Processo}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.Processo}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Processo_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Processo = 1000,
                Processo_end = 5000,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Processo}");
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Objeto}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Processo_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Processo = 1000,
                Processo_end = 5000,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Processo_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Processo = 1000,
                Processo_end = 5000,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Processo_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Processo = 1000,
                Processo_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].{DBInstanciaDicInfo.Processo} BETWEEN");
        }

        [Fact]
        public void WFiltro_Processo_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Processo = 1000,
                Processo_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Processo_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Processo = 1000,
                Processo_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Processo_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorProcessoInicial = 2500;
            var valorProcessoFinal = 4750;
            var filtro = new FilterInstancia
            {
                Processo = valorProcessoInicial,
                Processo_end = valorProcessoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.Processo}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.Processo}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorProcessoInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorProcessoFinal);
        }

        [Fact]
        public void WFiltro_Processo_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Processo = 0,
                Processo_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Processo_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Processo = 0,
                Processo_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Processo_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Processo = 1500,
                Processo_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Processo == int.MinValue) && !(filtro.Processo_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBInstanciaDicInfo.PTabelaNome}].{DBInstanciaDicInfo.Processo} BETWEEN @{DBInstanciaDicInfo.Processo} AND @{DBInstanciaDicInfo.Processo}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Processo_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Processo = 2000,
                Processo_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Processo == int.MinValue) && filtro.Processo_end == int.MinValue
            // Deve resultar em igualdade quando apenas Processo tem valor válido
            resultado.Value.where.Should().Be($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.Processo}] = @{DBInstanciaDicInfo.Processo}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Processo_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Processo = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Processo Isolated Tests
        [Fact]
        public void WFiltro_Processo_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Processo = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Processo_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorProcesso = 5;
            var filtro = new FilterInstancia
            {
                Processo = valorProcesso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.Processo}] = @{DBInstanciaDicInfo.Processo}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBInstanciaDicInfo.Processo}");
            parametro.Value.Should().Be(valorProcesso);
        }

        [Fact]
        public void WFiltro_Processo_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorProcesso = 0;
            var filtro = new FilterInstancia
            {
                Processo = valorProcesso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBInstanciaDicInfo.Processo}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorProcesso);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Processo_DiferentesValoresValidos_DeveProcessarCorretamente(int valorProcesso)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Processo = valorProcesso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorProcesso);
            resultado.Value.where.Should().Contain($"= @{DBInstanciaDicInfo.Processo}");
        }

        [Fact]
        public void WFiltro_Processo_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Processo = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Processo}");
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Objeto}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Processo_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Processo = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Processo_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Processo = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Processo_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Processo = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Processo_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Processo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.Processo}]");
        }

        [Fact]
        public void WFiltro_Processo_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Processo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Processo_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Processo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Processo_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Processo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Processo_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorProcesso = 42;
            var filtro = new FilterInstancia
            {
                Processo = valorProcesso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorProcesso);
        }

#endregion
        [Fact]
        public void WFiltro_Processo_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Processo = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Processo_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorProcesso = 1;
            var filtro = new FilterInstancia
            {
                Processo = valorProcesso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Processo
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.Processo}] = @insProcesso");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@insProcesso");
            parametro.Value.Should().Be(valorProcesso);
        }

        [Fact]
        public void WFiltro_Processo_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Processo = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@insProcesso");
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Objeto}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Processo_DiferentesValores_DeveFuncionar(int valorProcesso)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Processo = valorProcesso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorProcesso);
        }

#region filtro.Divisao_end Tests
        [Fact]
        public void WFiltro_Divisao_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Divisao_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Divisao_end_QuandoTemValorPositivo_SemDivisaoInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorDivisaoEnd = 5000;
            var filtro = new FilterInstancia
            {
                Divisao = int.MinValue, // Não define salário inicial
                Divisao_end = valorDivisaoEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Divisao inicial válido, não deve incluir condição WHERE, mas o parâmetro Divisao_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Divisao_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Divisao_end_QuandoSomenteValorInicial_SemDivisaoEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorDivisao = 2500;
            var filtro = new FilterInstancia
            {
                Divisao = valorDivisao,
                Divisao_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.Divisao}] = @{DBInstanciaDicInfo.Divisao}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBInstanciaDicInfo.Divisao}");
            parametro.Value.Should().Be(valorDivisao);
        }

        [Fact]
        public void WFiltro_Divisao_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorDivisaoInicial = 1000;
            var valorDivisaoFinal = 5000;
            var filtro = new FilterInstancia
            {
                Divisao = valorDivisaoInicial,
                Divisao_end = valorDivisaoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].{DBInstanciaDicInfo.Divisao} BETWEEN @{DBInstanciaDicInfo.Divisao} AND @{DBInstanciaDicInfo.Divisao}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.Divisao}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.Divisao}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorDivisaoInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorDivisaoFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Divisao_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Divisao = valorInicial,
                Divisao_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.Divisao}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.Divisao}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Divisao_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Divisao = 1000,
                Divisao_end = 5000,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Divisao}");
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Objeto}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Divisao_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Divisao = 1000,
                Divisao_end = 5000,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Divisao_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Divisao = 1000,
                Divisao_end = 5000,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Divisao_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Divisao = 1000,
                Divisao_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].{DBInstanciaDicInfo.Divisao} BETWEEN");
        }

        [Fact]
        public void WFiltro_Divisao_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Divisao = 1000,
                Divisao_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Divisao_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Divisao = 1000,
                Divisao_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Divisao_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorDivisaoInicial = 2500;
            var valorDivisaoFinal = 4750;
            var filtro = new FilterInstancia
            {
                Divisao = valorDivisaoInicial,
                Divisao_end = valorDivisaoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.Divisao}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.Divisao}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorDivisaoInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorDivisaoFinal);
        }

        [Fact]
        public void WFiltro_Divisao_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Divisao = 0,
                Divisao_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Divisao_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Divisao = 0,
                Divisao_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Divisao_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Divisao = 1500,
                Divisao_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Divisao == int.MinValue) && !(filtro.Divisao_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBInstanciaDicInfo.PTabelaNome}].{DBInstanciaDicInfo.Divisao} BETWEEN @{DBInstanciaDicInfo.Divisao} AND @{DBInstanciaDicInfo.Divisao}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Divisao_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Divisao = 2000,
                Divisao_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Divisao == int.MinValue) && filtro.Divisao_end == int.MinValue
            // Deve resultar em igualdade quando apenas Divisao tem valor válido
            resultado.Value.where.Should().Be($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.Divisao}] = @{DBInstanciaDicInfo.Divisao}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Divisao_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Divisao = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Divisao Isolated Tests
        [Fact]
        public void WFiltro_Divisao_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Divisao = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Divisao_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorDivisao = 5;
            var filtro = new FilterInstancia
            {
                Divisao = valorDivisao,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.Divisao}] = @{DBInstanciaDicInfo.Divisao}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBInstanciaDicInfo.Divisao}");
            parametro.Value.Should().Be(valorDivisao);
        }

        [Fact]
        public void WFiltro_Divisao_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorDivisao = 0;
            var filtro = new FilterInstancia
            {
                Divisao = valorDivisao,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBInstanciaDicInfo.Divisao}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorDivisao);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Divisao_DiferentesValoresValidos_DeveProcessarCorretamente(int valorDivisao)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Divisao = valorDivisao,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorDivisao);
            resultado.Value.where.Should().Contain($"= @{DBInstanciaDicInfo.Divisao}");
        }

        [Fact]
        public void WFiltro_Divisao_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Divisao = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Divisao}");
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Objeto}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Divisao_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Divisao = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Divisao_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Divisao = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Divisao_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Divisao = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Divisao_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Divisao = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.Divisao}]");
        }

        [Fact]
        public void WFiltro_Divisao_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Divisao = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Divisao_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Divisao = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Divisao_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Divisao = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Divisao_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorDivisao = 42;
            var filtro = new FilterInstancia
            {
                Divisao = valorDivisao,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorDivisao);
        }

#endregion
        [Fact]
        public void WFiltro_Divisao_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Divisao = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Divisao_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorDivisao = 1;
            var filtro = new FilterInstancia
            {
                Divisao = valorDivisao,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Divisao
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.Divisao}] = @insDivisao");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@insDivisao");
            parametro.Value.Should().Be(valorDivisao);
        }

        [Fact]
        public void WFiltro_Divisao_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Divisao = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@insDivisao");
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Objeto}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Divisao_DiferentesValores_DeveFuncionar(int valorDivisao)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Divisao = valorDivisao,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorDivisao);
        }

#region filtro.Comarca_end Tests
        [Fact]
        public void WFiltro_Comarca_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Comarca_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Comarca_end_QuandoTemValorPositivo_SemComarcaInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorComarcaEnd = 5000;
            var filtro = new FilterInstancia
            {
                Comarca = int.MinValue, // Não define salário inicial
                Comarca_end = valorComarcaEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Comarca inicial válido, não deve incluir condição WHERE, mas o parâmetro Comarca_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Comarca_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Comarca_end_QuandoSomenteValorInicial_SemComarcaEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorComarca = 2500;
            var filtro = new FilterInstancia
            {
                Comarca = valorComarca,
                Comarca_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.Comarca}] = @{DBInstanciaDicInfo.Comarca}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBInstanciaDicInfo.Comarca}");
            parametro.Value.Should().Be(valorComarca);
        }

        [Fact]
        public void WFiltro_Comarca_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorComarcaInicial = 1000;
            var valorComarcaFinal = 5000;
            var filtro = new FilterInstancia
            {
                Comarca = valorComarcaInicial,
                Comarca_end = valorComarcaFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].{DBInstanciaDicInfo.Comarca} BETWEEN @{DBInstanciaDicInfo.Comarca} AND @{DBInstanciaDicInfo.Comarca}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.Comarca}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.Comarca}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorComarcaInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorComarcaFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Comarca_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Comarca = valorInicial,
                Comarca_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.Comarca}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.Comarca}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Comarca_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Comarca = 1000,
                Comarca_end = 5000,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Comarca}");
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Objeto}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Comarca_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Comarca = 1000,
                Comarca_end = 5000,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Comarca_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Comarca = 1000,
                Comarca_end = 5000,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Comarca_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Comarca = 1000,
                Comarca_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].{DBInstanciaDicInfo.Comarca} BETWEEN");
        }

        [Fact]
        public void WFiltro_Comarca_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Comarca = 1000,
                Comarca_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Comarca_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Comarca = 1000,
                Comarca_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Comarca_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorComarcaInicial = 2500;
            var valorComarcaFinal = 4750;
            var filtro = new FilterInstancia
            {
                Comarca = valorComarcaInicial,
                Comarca_end = valorComarcaFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.Comarca}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.Comarca}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorComarcaInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorComarcaFinal);
        }

        [Fact]
        public void WFiltro_Comarca_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Comarca = 0,
                Comarca_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Comarca_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Comarca = 0,
                Comarca_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Comarca_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Comarca = 1500,
                Comarca_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Comarca == int.MinValue) && !(filtro.Comarca_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBInstanciaDicInfo.PTabelaNome}].{DBInstanciaDicInfo.Comarca} BETWEEN @{DBInstanciaDicInfo.Comarca} AND @{DBInstanciaDicInfo.Comarca}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Comarca_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Comarca = 2000,
                Comarca_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Comarca == int.MinValue) && filtro.Comarca_end == int.MinValue
            // Deve resultar em igualdade quando apenas Comarca tem valor válido
            resultado.Value.where.Should().Be($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.Comarca}] = @{DBInstanciaDicInfo.Comarca}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Comarca_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Comarca = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Comarca Isolated Tests
        [Fact]
        public void WFiltro_Comarca_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Comarca = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Comarca_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorComarca = 5;
            var filtro = new FilterInstancia
            {
                Comarca = valorComarca,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.Comarca}] = @{DBInstanciaDicInfo.Comarca}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBInstanciaDicInfo.Comarca}");
            parametro.Value.Should().Be(valorComarca);
        }

        [Fact]
        public void WFiltro_Comarca_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorComarca = 0;
            var filtro = new FilterInstancia
            {
                Comarca = valorComarca,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBInstanciaDicInfo.Comarca}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorComarca);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Comarca_DiferentesValoresValidos_DeveProcessarCorretamente(int valorComarca)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Comarca = valorComarca,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorComarca);
            resultado.Value.where.Should().Contain($"= @{DBInstanciaDicInfo.Comarca}");
        }

        [Fact]
        public void WFiltro_Comarca_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Comarca = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Comarca}");
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Objeto}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Comarca_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Comarca = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Comarca_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Comarca = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Comarca_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Comarca = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Comarca_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Comarca = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.Comarca}]");
        }

        [Fact]
        public void WFiltro_Comarca_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Comarca = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Comarca_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Comarca = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Comarca_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Comarca = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Comarca_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorComarca = 42;
            var filtro = new FilterInstancia
            {
                Comarca = valorComarca,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorComarca);
        }

#endregion
        [Fact]
        public void WFiltro_Comarca_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Comarca = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Comarca_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorComarca = 1;
            var filtro = new FilterInstancia
            {
                Comarca = valorComarca,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Comarca
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.Comarca}] = @insComarca");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@insComarca");
            parametro.Value.Should().Be(valorComarca);
        }

        [Fact]
        public void WFiltro_Comarca_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Comarca = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@insComarca");
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Objeto}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Comarca_DiferentesValores_DeveFuncionar(int valorComarca)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Comarca = valorComarca,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorComarca);
        }

#region filtro.SubDivisao_end Tests
        [Fact]
        public void WFiltro_SubDivisao_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                SubDivisao_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_SubDivisao_end_QuandoTemValorPositivo_SemSubDivisaoInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorSubDivisaoEnd = 5000;
            var filtro = new FilterInstancia
            {
                SubDivisao = int.MinValue, // Não define salário inicial
                SubDivisao_end = valorSubDivisaoEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há SubDivisao inicial válido, não deve incluir condição WHERE, mas o parâmetro SubDivisao_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // SubDivisao_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_SubDivisao_end_QuandoSomenteValorInicial_SemSubDivisaoEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorSubDivisao = 2500;
            var filtro = new FilterInstancia
            {
                SubDivisao = valorSubDivisao,
                SubDivisao_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.SubDivisao}] = @{DBInstanciaDicInfo.SubDivisao}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBInstanciaDicInfo.SubDivisao}");
            parametro.Value.Should().Be(valorSubDivisao);
        }

        [Fact]
        public void WFiltro_SubDivisao_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorSubDivisaoInicial = 1000;
            var valorSubDivisaoFinal = 5000;
            var filtro = new FilterInstancia
            {
                SubDivisao = valorSubDivisaoInicial,
                SubDivisao_end = valorSubDivisaoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].{DBInstanciaDicInfo.SubDivisao} BETWEEN @{DBInstanciaDicInfo.SubDivisao} AND @{DBInstanciaDicInfo.SubDivisao}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.SubDivisao}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.SubDivisao}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorSubDivisaoInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorSubDivisaoFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_SubDivisao_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                SubDivisao = valorInicial,
                SubDivisao_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.SubDivisao}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.SubDivisao}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_SubDivisao_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                SubDivisao = 1000,
                SubDivisao_end = 5000,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.SubDivisao}");
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Objeto}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_SubDivisao_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                SubDivisao = 1000,
                SubDivisao_end = 5000,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_SubDivisao_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                SubDivisao = 1000,
                SubDivisao_end = 5000,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_SubDivisao_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                SubDivisao = 1000,
                SubDivisao_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].{DBInstanciaDicInfo.SubDivisao} BETWEEN");
        }

        [Fact]
        public void WFiltro_SubDivisao_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                SubDivisao = 1000,
                SubDivisao_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_SubDivisao_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                SubDivisao = 1000,
                SubDivisao_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_SubDivisao_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorSubDivisaoInicial = 2500;
            var valorSubDivisaoFinal = 4750;
            var filtro = new FilterInstancia
            {
                SubDivisao = valorSubDivisaoInicial,
                SubDivisao_end = valorSubDivisaoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.SubDivisao}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.SubDivisao}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorSubDivisaoInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorSubDivisaoFinal);
        }

        [Fact]
        public void WFiltro_SubDivisao_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                SubDivisao = 0,
                SubDivisao_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_SubDivisao_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                SubDivisao = 0,
                SubDivisao_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_SubDivisao_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                SubDivisao = 1500,
                SubDivisao_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.SubDivisao == int.MinValue) && !(filtro.SubDivisao_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBInstanciaDicInfo.PTabelaNome}].{DBInstanciaDicInfo.SubDivisao} BETWEEN @{DBInstanciaDicInfo.SubDivisao} AND @{DBInstanciaDicInfo.SubDivisao}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_SubDivisao_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                SubDivisao = 2000,
                SubDivisao_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.SubDivisao == int.MinValue) && filtro.SubDivisao_end == int.MinValue
            // Deve resultar em igualdade quando apenas SubDivisao tem valor válido
            resultado.Value.where.Should().Be($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.SubDivisao}] = @{DBInstanciaDicInfo.SubDivisao}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_SubDivisao_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                SubDivisao = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.SubDivisao Isolated Tests
        [Fact]
        public void WFiltro_SubDivisao_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                SubDivisao = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_SubDivisao_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorSubDivisao = 5;
            var filtro = new FilterInstancia
            {
                SubDivisao = valorSubDivisao,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.SubDivisao}] = @{DBInstanciaDicInfo.SubDivisao}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBInstanciaDicInfo.SubDivisao}");
            parametro.Value.Should().Be(valorSubDivisao);
        }

        [Fact]
        public void WFiltro_SubDivisao_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorSubDivisao = 0;
            var filtro = new FilterInstancia
            {
                SubDivisao = valorSubDivisao,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBInstanciaDicInfo.SubDivisao}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorSubDivisao);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_SubDivisao_DiferentesValoresValidos_DeveProcessarCorretamente(int valorSubDivisao)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                SubDivisao = valorSubDivisao,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorSubDivisao);
            resultado.Value.where.Should().Contain($"= @{DBInstanciaDicInfo.SubDivisao}");
        }

        [Fact]
        public void WFiltro_SubDivisao_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                SubDivisao = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.SubDivisao}");
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Objeto}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_SubDivisao_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                SubDivisao = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_SubDivisao_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                SubDivisao = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_SubDivisao_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                SubDivisao = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_SubDivisao_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                SubDivisao = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.SubDivisao}]");
        }

        [Fact]
        public void WFiltro_SubDivisao_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                SubDivisao = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_SubDivisao_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                SubDivisao = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_SubDivisao_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                SubDivisao = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_SubDivisao_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorSubDivisao = 42;
            var filtro = new FilterInstancia
            {
                SubDivisao = valorSubDivisao,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorSubDivisao);
        }

#endregion
        [Fact]
        public void WFiltro_SubDivisao_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                SubDivisao = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_SubDivisao_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorSubDivisao = 1;
            var filtro = new FilterInstancia
            {
                SubDivisao = valorSubDivisao,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do SubDivisao
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.SubDivisao}] = @insSubDivisao");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@insSubDivisao");
            parametro.Value.Should().Be(valorSubDivisao);
        }

        [Fact]
        public void WFiltro_SubDivisao_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                SubDivisao = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@insSubDivisao");
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Objeto}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_SubDivisao_DiferentesValores_DeveFuncionar(int valorSubDivisao)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                SubDivisao = valorSubDivisao,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorSubDivisao);
        }

#region filtro.Acao_end Tests
        [Fact]
        public void WFiltro_Acao_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Acao_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Acao_end_QuandoTemValorPositivo_SemAcaoInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorAcaoEnd = 5000;
            var filtro = new FilterInstancia
            {
                Acao = int.MinValue, // Não define salário inicial
                Acao_end = valorAcaoEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Acao inicial válido, não deve incluir condição WHERE, mas o parâmetro Acao_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Acao_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Acao_end_QuandoSomenteValorInicial_SemAcaoEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorAcao = 2500;
            var filtro = new FilterInstancia
            {
                Acao = valorAcao,
                Acao_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.Acao}] = @{DBInstanciaDicInfo.Acao}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBInstanciaDicInfo.Acao}");
            parametro.Value.Should().Be(valorAcao);
        }

        [Fact]
        public void WFiltro_Acao_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorAcaoInicial = 1000;
            var valorAcaoFinal = 5000;
            var filtro = new FilterInstancia
            {
                Acao = valorAcaoInicial,
                Acao_end = valorAcaoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].{DBInstanciaDicInfo.Acao} BETWEEN @{DBInstanciaDicInfo.Acao} AND @{DBInstanciaDicInfo.Acao}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.Acao}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.Acao}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorAcaoInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorAcaoFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Acao_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Acao = valorInicial,
                Acao_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.Acao}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.Acao}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Acao_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Acao = 1000,
                Acao_end = 5000,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Acao}");
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Objeto}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Acao_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Acao = 1000,
                Acao_end = 5000,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Acao_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Acao = 1000,
                Acao_end = 5000,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Acao_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Acao = 1000,
                Acao_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].{DBInstanciaDicInfo.Acao} BETWEEN");
        }

        [Fact]
        public void WFiltro_Acao_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Acao = 1000,
                Acao_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Acao_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Acao = 1000,
                Acao_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Acao_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorAcaoInicial = 2500;
            var valorAcaoFinal = 4750;
            var filtro = new FilterInstancia
            {
                Acao = valorAcaoInicial,
                Acao_end = valorAcaoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.Acao}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.Acao}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorAcaoInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorAcaoFinal);
        }

        [Fact]
        public void WFiltro_Acao_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Acao = 0,
                Acao_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Acao_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Acao = 0,
                Acao_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Acao_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Acao = 1500,
                Acao_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Acao == int.MinValue) && !(filtro.Acao_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBInstanciaDicInfo.PTabelaNome}].{DBInstanciaDicInfo.Acao} BETWEEN @{DBInstanciaDicInfo.Acao} AND @{DBInstanciaDicInfo.Acao}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Acao_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Acao = 2000,
                Acao_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Acao == int.MinValue) && filtro.Acao_end == int.MinValue
            // Deve resultar em igualdade quando apenas Acao tem valor válido
            resultado.Value.where.Should().Be($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.Acao}] = @{DBInstanciaDicInfo.Acao}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Acao_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Acao = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Acao Isolated Tests
        [Fact]
        public void WFiltro_Acao_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Acao = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Acao_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorAcao = 5;
            var filtro = new FilterInstancia
            {
                Acao = valorAcao,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.Acao}] = @{DBInstanciaDicInfo.Acao}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBInstanciaDicInfo.Acao}");
            parametro.Value.Should().Be(valorAcao);
        }

        [Fact]
        public void WFiltro_Acao_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorAcao = 0;
            var filtro = new FilterInstancia
            {
                Acao = valorAcao,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBInstanciaDicInfo.Acao}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorAcao);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Acao_DiferentesValoresValidos_DeveProcessarCorretamente(int valorAcao)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Acao = valorAcao,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorAcao);
            resultado.Value.where.Should().Contain($"= @{DBInstanciaDicInfo.Acao}");
        }

        [Fact]
        public void WFiltro_Acao_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Acao = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Acao}");
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Objeto}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Acao_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Acao = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Acao_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Acao = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Acao_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Acao = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Acao_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Acao = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.Acao}]");
        }

        [Fact]
        public void WFiltro_Acao_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Acao = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Acao_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Acao = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Acao_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Acao = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Acao_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorAcao = 42;
            var filtro = new FilterInstancia
            {
                Acao = valorAcao,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorAcao);
        }

#endregion
        [Fact]
        public void WFiltro_Acao_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Acao = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Acao_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorAcao = 1;
            var filtro = new FilterInstancia
            {
                Acao = valorAcao,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Acao
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.Acao}] = @insAcao");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@insAcao");
            parametro.Value.Should().Be(valorAcao);
        }

        [Fact]
        public void WFiltro_Acao_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Acao = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@insAcao");
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Objeto}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Acao_DiferentesValores_DeveFuncionar(int valorAcao)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Acao = valorAcao,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorAcao);
        }

#region filtro.Foro_end Tests
        [Fact]
        public void WFiltro_Foro_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Foro_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Foro_end_QuandoTemValorPositivo_SemForoInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorForoEnd = 5000;
            var filtro = new FilterInstancia
            {
                Foro = int.MinValue, // Não define salário inicial
                Foro_end = valorForoEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Foro inicial válido, não deve incluir condição WHERE, mas o parâmetro Foro_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Foro_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Foro_end_QuandoSomenteValorInicial_SemForoEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorForo = 2500;
            var filtro = new FilterInstancia
            {
                Foro = valorForo,
                Foro_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.Foro}] = @{DBInstanciaDicInfo.Foro}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBInstanciaDicInfo.Foro}");
            parametro.Value.Should().Be(valorForo);
        }

        [Fact]
        public void WFiltro_Foro_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorForoInicial = 1000;
            var valorForoFinal = 5000;
            var filtro = new FilterInstancia
            {
                Foro = valorForoInicial,
                Foro_end = valorForoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].{DBInstanciaDicInfo.Foro} BETWEEN @{DBInstanciaDicInfo.Foro} AND @{DBInstanciaDicInfo.Foro}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.Foro}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.Foro}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorForoInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorForoFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Foro_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Foro = valorInicial,
                Foro_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.Foro}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.Foro}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Foro_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Foro = 1000,
                Foro_end = 5000,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Foro}");
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Objeto}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Foro_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Foro = 1000,
                Foro_end = 5000,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Foro_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Foro = 1000,
                Foro_end = 5000,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Foro_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Foro = 1000,
                Foro_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].{DBInstanciaDicInfo.Foro} BETWEEN");
        }

        [Fact]
        public void WFiltro_Foro_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Foro = 1000,
                Foro_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Foro_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Foro = 1000,
                Foro_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Foro_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorForoInicial = 2500;
            var valorForoFinal = 4750;
            var filtro = new FilterInstancia
            {
                Foro = valorForoInicial,
                Foro_end = valorForoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.Foro}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.Foro}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorForoInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorForoFinal);
        }

        [Fact]
        public void WFiltro_Foro_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Foro = 0,
                Foro_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Foro_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Foro = 0,
                Foro_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Foro_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Foro = 1500,
                Foro_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Foro == int.MinValue) && !(filtro.Foro_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBInstanciaDicInfo.PTabelaNome}].{DBInstanciaDicInfo.Foro} BETWEEN @{DBInstanciaDicInfo.Foro} AND @{DBInstanciaDicInfo.Foro}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Foro_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Foro = 2000,
                Foro_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Foro == int.MinValue) && filtro.Foro_end == int.MinValue
            // Deve resultar em igualdade quando apenas Foro tem valor válido
            resultado.Value.where.Should().Be($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.Foro}] = @{DBInstanciaDicInfo.Foro}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Foro_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Foro = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Foro Isolated Tests
        [Fact]
        public void WFiltro_Foro_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Foro = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Foro_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorForo = 5;
            var filtro = new FilterInstancia
            {
                Foro = valorForo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.Foro}] = @{DBInstanciaDicInfo.Foro}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBInstanciaDicInfo.Foro}");
            parametro.Value.Should().Be(valorForo);
        }

        [Fact]
        public void WFiltro_Foro_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorForo = 0;
            var filtro = new FilterInstancia
            {
                Foro = valorForo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBInstanciaDicInfo.Foro}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorForo);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Foro_DiferentesValoresValidos_DeveProcessarCorretamente(int valorForo)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Foro = valorForo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorForo);
            resultado.Value.where.Should().Contain($"= @{DBInstanciaDicInfo.Foro}");
        }

        [Fact]
        public void WFiltro_Foro_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Foro = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Foro}");
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Objeto}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Foro_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Foro = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Foro_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Foro = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Foro_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Foro = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Foro_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Foro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.Foro}]");
        }

        [Fact]
        public void WFiltro_Foro_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Foro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Foro_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Foro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Foro_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Foro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Foro_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorForo = 42;
            var filtro = new FilterInstancia
            {
                Foro = valorForo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorForo);
        }

#endregion
        [Fact]
        public void WFiltro_Foro_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Foro = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Foro_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorForo = 1;
            var filtro = new FilterInstancia
            {
                Foro = valorForo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Foro
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.Foro}] = @insForo");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@insForo");
            parametro.Value.Should().Be(valorForo);
        }

        [Fact]
        public void WFiltro_Foro_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Foro = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@insForo");
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Objeto}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Foro_DiferentesValores_DeveFuncionar(int valorForo)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Foro = valorForo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorForo);
        }

#region filtro.TipoRecurso_end Tests
        [Fact]
        public void WFiltro_TipoRecurso_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                TipoRecurso_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_TipoRecurso_end_QuandoTemValorPositivo_SemTipoRecursoInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorTipoRecursoEnd = 5000;
            var filtro = new FilterInstancia
            {
                TipoRecurso = int.MinValue, // Não define salário inicial
                TipoRecurso_end = valorTipoRecursoEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há TipoRecurso inicial válido, não deve incluir condição WHERE, mas o parâmetro TipoRecurso_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // TipoRecurso_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_TipoRecurso_end_QuandoSomenteValorInicial_SemTipoRecursoEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorTipoRecurso = 2500;
            var filtro = new FilterInstancia
            {
                TipoRecurso = valorTipoRecurso,
                TipoRecurso_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.TipoRecurso}] = @{DBInstanciaDicInfo.TipoRecurso}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBInstanciaDicInfo.TipoRecurso}");
            parametro.Value.Should().Be(valorTipoRecurso);
        }

        [Fact]
        public void WFiltro_TipoRecurso_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorTipoRecursoInicial = 1000;
            var valorTipoRecursoFinal = 5000;
            var filtro = new FilterInstancia
            {
                TipoRecurso = valorTipoRecursoInicial,
                TipoRecurso_end = valorTipoRecursoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].{DBInstanciaDicInfo.TipoRecurso} BETWEEN @{DBInstanciaDicInfo.TipoRecurso} AND @{DBInstanciaDicInfo.TipoRecurso}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.TipoRecurso}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.TipoRecurso}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorTipoRecursoInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorTipoRecursoFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_TipoRecurso_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                TipoRecurso = valorInicial,
                TipoRecurso_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.TipoRecurso}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.TipoRecurso}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_TipoRecurso_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                TipoRecurso = 1000,
                TipoRecurso_end = 5000,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.TipoRecurso}");
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Objeto}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_TipoRecurso_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                TipoRecurso = 1000,
                TipoRecurso_end = 5000,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_TipoRecurso_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                TipoRecurso = 1000,
                TipoRecurso_end = 5000,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_TipoRecurso_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                TipoRecurso = 1000,
                TipoRecurso_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].{DBInstanciaDicInfo.TipoRecurso} BETWEEN");
        }

        [Fact]
        public void WFiltro_TipoRecurso_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                TipoRecurso = 1000,
                TipoRecurso_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_TipoRecurso_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                TipoRecurso = 1000,
                TipoRecurso_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_TipoRecurso_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorTipoRecursoInicial = 2500;
            var valorTipoRecursoFinal = 4750;
            var filtro = new FilterInstancia
            {
                TipoRecurso = valorTipoRecursoInicial,
                TipoRecurso_end = valorTipoRecursoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.TipoRecurso}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.TipoRecurso}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorTipoRecursoInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorTipoRecursoFinal);
        }

        [Fact]
        public void WFiltro_TipoRecurso_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                TipoRecurso = 0,
                TipoRecurso_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_TipoRecurso_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                TipoRecurso = 0,
                TipoRecurso_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_TipoRecurso_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                TipoRecurso = 1500,
                TipoRecurso_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.TipoRecurso == int.MinValue) && !(filtro.TipoRecurso_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBInstanciaDicInfo.PTabelaNome}].{DBInstanciaDicInfo.TipoRecurso} BETWEEN @{DBInstanciaDicInfo.TipoRecurso} AND @{DBInstanciaDicInfo.TipoRecurso}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_TipoRecurso_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                TipoRecurso = 2000,
                TipoRecurso_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.TipoRecurso == int.MinValue) && filtro.TipoRecurso_end == int.MinValue
            // Deve resultar em igualdade quando apenas TipoRecurso tem valor válido
            resultado.Value.where.Should().Be($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.TipoRecurso}] = @{DBInstanciaDicInfo.TipoRecurso}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_TipoRecurso_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                TipoRecurso = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.TipoRecurso Isolated Tests
        [Fact]
        public void WFiltro_TipoRecurso_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                TipoRecurso = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_TipoRecurso_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorTipoRecurso = 5;
            var filtro = new FilterInstancia
            {
                TipoRecurso = valorTipoRecurso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.TipoRecurso}] = @{DBInstanciaDicInfo.TipoRecurso}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBInstanciaDicInfo.TipoRecurso}");
            parametro.Value.Should().Be(valorTipoRecurso);
        }

        [Fact]
        public void WFiltro_TipoRecurso_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorTipoRecurso = 0;
            var filtro = new FilterInstancia
            {
                TipoRecurso = valorTipoRecurso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBInstanciaDicInfo.TipoRecurso}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorTipoRecurso);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_TipoRecurso_DiferentesValoresValidos_DeveProcessarCorretamente(int valorTipoRecurso)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                TipoRecurso = valorTipoRecurso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorTipoRecurso);
            resultado.Value.where.Should().Contain($"= @{DBInstanciaDicInfo.TipoRecurso}");
        }

        [Fact]
        public void WFiltro_TipoRecurso_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                TipoRecurso = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.TipoRecurso}");
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Objeto}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_TipoRecurso_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                TipoRecurso = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_TipoRecurso_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                TipoRecurso = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_TipoRecurso_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                TipoRecurso = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_TipoRecurso_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                TipoRecurso = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.TipoRecurso}]");
        }

        [Fact]
        public void WFiltro_TipoRecurso_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                TipoRecurso = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_TipoRecurso_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                TipoRecurso = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_TipoRecurso_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                TipoRecurso = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_TipoRecurso_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorTipoRecurso = 42;
            var filtro = new FilterInstancia
            {
                TipoRecurso = valorTipoRecurso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorTipoRecurso);
        }

#endregion
        [Fact]
        public void WFiltro_TipoRecurso_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                TipoRecurso = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_TipoRecurso_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorTipoRecurso = 1;
            var filtro = new FilterInstancia
            {
                TipoRecurso = valorTipoRecurso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do TipoRecurso
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.TipoRecurso}] = @insTipoRecurso");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@insTipoRecurso");
            parametro.Value.Should().Be(valorTipoRecurso);
        }

        [Fact]
        public void WFiltro_TipoRecurso_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                TipoRecurso = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@insTipoRecurso");
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Objeto}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_TipoRecurso_DiferentesValores_DeveFuncionar(int valorTipoRecurso)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                TipoRecurso = valorTipoRecurso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorTipoRecurso);
        }

#region filtro.ZKeyQuem_end Tests
        [Fact]
        public void WFiltro_ZKeyQuem_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyQuem_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_ZKeyQuem_end_QuandoTemValorPositivo_SemZKeyQuemInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorZKeyQuemEnd = 5000;
            var filtro = new FilterInstancia
            {
                ZKeyQuem = int.MinValue, // Não define salário inicial
                ZKeyQuem_end = valorZKeyQuemEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há ZKeyQuem inicial válido, não deve incluir condição WHERE, mas o parâmetro ZKeyQuem_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // ZKeyQuem_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_ZKeyQuem_end_QuandoSomenteValorInicial_SemZKeyQuemEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorZKeyQuem = 2500;
            var filtro = new FilterInstancia
            {
                ZKeyQuem = valorZKeyQuem,
                ZKeyQuem_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.ZKeyQuem}] = @{DBInstanciaDicInfo.ZKeyQuem}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBInstanciaDicInfo.ZKeyQuem}");
            parametro.Value.Should().Be(valorZKeyQuem);
        }

        [Fact]
        public void WFiltro_ZKeyQuem_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorZKeyQuemInicial = 1000;
            var valorZKeyQuemFinal = 5000;
            var filtro = new FilterInstancia
            {
                ZKeyQuem = valorZKeyQuemInicial,
                ZKeyQuem_end = valorZKeyQuemFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].{DBInstanciaDicInfo.ZKeyQuem} BETWEEN @{DBInstanciaDicInfo.ZKeyQuem} AND @{DBInstanciaDicInfo.ZKeyQuem}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.ZKeyQuem}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.ZKeyQuem}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorZKeyQuemInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorZKeyQuemFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_ZKeyQuem_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyQuem = valorInicial,
                ZKeyQuem_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.ZKeyQuem}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.ZKeyQuem}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_ZKeyQuem_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyQuem = 1000,
                ZKeyQuem_end = 5000,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.ZKeyQuem}");
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Objeto}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_ZKeyQuem_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyQuem = 1000,
                ZKeyQuem_end = 5000,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_ZKeyQuem_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyQuem = 1000,
                ZKeyQuem_end = 5000,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_ZKeyQuem_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyQuem = 1000,
                ZKeyQuem_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].{DBInstanciaDicInfo.ZKeyQuem} BETWEEN");
        }

        [Fact]
        public void WFiltro_ZKeyQuem_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyQuem = 1000,
                ZKeyQuem_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_ZKeyQuem_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyQuem = 1000,
                ZKeyQuem_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_ZKeyQuem_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorZKeyQuemInicial = 2500;
            var valorZKeyQuemFinal = 4750;
            var filtro = new FilterInstancia
            {
                ZKeyQuem = valorZKeyQuemInicial,
                ZKeyQuem_end = valorZKeyQuemFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.ZKeyQuem}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.ZKeyQuem}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorZKeyQuemInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorZKeyQuemFinal);
        }

        [Fact]
        public void WFiltro_ZKeyQuem_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyQuem = 0,
                ZKeyQuem_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_ZKeyQuem_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyQuem = 0,
                ZKeyQuem_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_ZKeyQuem_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyQuem = 1500,
                ZKeyQuem_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.ZKeyQuem == int.MinValue) && !(filtro.ZKeyQuem_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBInstanciaDicInfo.PTabelaNome}].{DBInstanciaDicInfo.ZKeyQuem} BETWEEN @{DBInstanciaDicInfo.ZKeyQuem} AND @{DBInstanciaDicInfo.ZKeyQuem}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_ZKeyQuem_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyQuem = 2000,
                ZKeyQuem_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.ZKeyQuem == int.MinValue) && filtro.ZKeyQuem_end == int.MinValue
            // Deve resultar em igualdade quando apenas ZKeyQuem tem valor válido
            resultado.Value.where.Should().Be($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.ZKeyQuem}] = @{DBInstanciaDicInfo.ZKeyQuem}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_ZKeyQuem_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyQuem = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.ZKeyQuem Isolated Tests
        [Fact]
        public void WFiltro_ZKeyQuem_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyQuem = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_ZKeyQuem_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorZKeyQuem = 5;
            var filtro = new FilterInstancia
            {
                ZKeyQuem = valorZKeyQuem,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.ZKeyQuem}] = @{DBInstanciaDicInfo.ZKeyQuem}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBInstanciaDicInfo.ZKeyQuem}");
            parametro.Value.Should().Be(valorZKeyQuem);
        }

        [Fact]
        public void WFiltro_ZKeyQuem_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorZKeyQuem = 0;
            var filtro = new FilterInstancia
            {
                ZKeyQuem = valorZKeyQuem,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBInstanciaDicInfo.ZKeyQuem}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorZKeyQuem);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_ZKeyQuem_DiferentesValoresValidos_DeveProcessarCorretamente(int valorZKeyQuem)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyQuem = valorZKeyQuem,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorZKeyQuem);
            resultado.Value.where.Should().Contain($"= @{DBInstanciaDicInfo.ZKeyQuem}");
        }

        [Fact]
        public void WFiltro_ZKeyQuem_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyQuem = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.ZKeyQuem}");
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Objeto}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_ZKeyQuem_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyQuem = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_ZKeyQuem_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyQuem = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_ZKeyQuem_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyQuem = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_ZKeyQuem_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyQuem = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.ZKeyQuem}]");
        }

        [Fact]
        public void WFiltro_ZKeyQuem_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyQuem = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_ZKeyQuem_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyQuem = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_ZKeyQuem_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyQuem = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_ZKeyQuem_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorZKeyQuem = 42;
            var filtro = new FilterInstancia
            {
                ZKeyQuem = valorZKeyQuem,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorZKeyQuem);
        }

#endregion
        [Fact]
        public void WFiltro_ZKeyQuem_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyQuem = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_ZKeyQuem_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorZKeyQuem = 1;
            var filtro = new FilterInstancia
            {
                ZKeyQuem = valorZKeyQuem,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do ZKeyQuem
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.ZKeyQuem}] = @insZKeyQuem");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@insZKeyQuem");
            parametro.Value.Should().Be(valorZKeyQuem);
        }

        [Fact]
        public void WFiltro_ZKeyQuem_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyQuem = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@insZKeyQuem");
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Objeto}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_ZKeyQuem_DiferentesValores_DeveFuncionar(int valorZKeyQuem)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyQuem = valorZKeyQuem,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorZKeyQuem);
        }

#region filtro.Julgador_end Tests
        [Fact]
        public void WFiltro_Julgador_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Julgador_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Julgador_end_QuandoTemValorPositivo_SemJulgadorInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorJulgadorEnd = 5000;
            var filtro = new FilterInstancia
            {
                Julgador = int.MinValue, // Não define salário inicial
                Julgador_end = valorJulgadorEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Julgador inicial válido, não deve incluir condição WHERE, mas o parâmetro Julgador_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Julgador_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Julgador_end_QuandoSomenteValorInicial_SemJulgadorEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorJulgador = 2500;
            var filtro = new FilterInstancia
            {
                Julgador = valorJulgador,
                Julgador_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.Julgador}] = @{DBInstanciaDicInfo.Julgador}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBInstanciaDicInfo.Julgador}");
            parametro.Value.Should().Be(valorJulgador);
        }

        [Fact]
        public void WFiltro_Julgador_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorJulgadorInicial = 1000;
            var valorJulgadorFinal = 5000;
            var filtro = new FilterInstancia
            {
                Julgador = valorJulgadorInicial,
                Julgador_end = valorJulgadorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].{DBInstanciaDicInfo.Julgador} BETWEEN @{DBInstanciaDicInfo.Julgador} AND @{DBInstanciaDicInfo.Julgador}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.Julgador}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.Julgador}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorJulgadorInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorJulgadorFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Julgador_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Julgador = valorInicial,
                Julgador_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.Julgador}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.Julgador}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Julgador_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Julgador = 1000,
                Julgador_end = 5000,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Julgador}");
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Objeto}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Julgador_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Julgador = 1000,
                Julgador_end = 5000,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Julgador_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Julgador = 1000,
                Julgador_end = 5000,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Julgador_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Julgador = 1000,
                Julgador_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].{DBInstanciaDicInfo.Julgador} BETWEEN");
        }

        [Fact]
        public void WFiltro_Julgador_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Julgador = 1000,
                Julgador_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Julgador_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Julgador = 1000,
                Julgador_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Julgador_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorJulgadorInicial = 2500;
            var valorJulgadorFinal = 4750;
            var filtro = new FilterInstancia
            {
                Julgador = valorJulgadorInicial,
                Julgador_end = valorJulgadorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.Julgador}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.Julgador}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorJulgadorInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorJulgadorFinal);
        }

        [Fact]
        public void WFiltro_Julgador_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Julgador = 0,
                Julgador_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Julgador_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Julgador = 0,
                Julgador_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Julgador_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Julgador = 1500,
                Julgador_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Julgador == int.MinValue) && !(filtro.Julgador_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBInstanciaDicInfo.PTabelaNome}].{DBInstanciaDicInfo.Julgador} BETWEEN @{DBInstanciaDicInfo.Julgador} AND @{DBInstanciaDicInfo.Julgador}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Julgador_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Julgador = 2000,
                Julgador_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Julgador == int.MinValue) && filtro.Julgador_end == int.MinValue
            // Deve resultar em igualdade quando apenas Julgador tem valor válido
            resultado.Value.where.Should().Be($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.Julgador}] = @{DBInstanciaDicInfo.Julgador}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Julgador_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Julgador = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Julgador Isolated Tests
        [Fact]
        public void WFiltro_Julgador_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Julgador = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Julgador_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorJulgador = 5;
            var filtro = new FilterInstancia
            {
                Julgador = valorJulgador,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.Julgador}] = @{DBInstanciaDicInfo.Julgador}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBInstanciaDicInfo.Julgador}");
            parametro.Value.Should().Be(valorJulgador);
        }

        [Fact]
        public void WFiltro_Julgador_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorJulgador = 0;
            var filtro = new FilterInstancia
            {
                Julgador = valorJulgador,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBInstanciaDicInfo.Julgador}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorJulgador);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Julgador_DiferentesValoresValidos_DeveProcessarCorretamente(int valorJulgador)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Julgador = valorJulgador,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorJulgador);
            resultado.Value.where.Should().Contain($"= @{DBInstanciaDicInfo.Julgador}");
        }

        [Fact]
        public void WFiltro_Julgador_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Julgador = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Julgador}");
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Objeto}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Julgador_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Julgador = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Julgador_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Julgador = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Julgador_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Julgador = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Julgador_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Julgador = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.Julgador}]");
        }

        [Fact]
        public void WFiltro_Julgador_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Julgador = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Julgador_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Julgador = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Julgador_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Julgador = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Julgador_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorJulgador = 42;
            var filtro = new FilterInstancia
            {
                Julgador = valorJulgador,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorJulgador);
        }

#endregion
        [Fact]
        public void WFiltro_Julgador_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Julgador = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Julgador_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorJulgador = 1;
            var filtro = new FilterInstancia
            {
                Julgador = valorJulgador,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Julgador
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.Julgador}] = @insJulgador");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@insJulgador");
            parametro.Value.Should().Be(valorJulgador);
        }

        [Fact]
        public void WFiltro_Julgador_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Julgador = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@insJulgador");
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Objeto}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Julgador_DiferentesValores_DeveFuncionar(int valorJulgador)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Julgador = valorJulgador,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorJulgador);
        }

#region filtro.Codigo_filtro_end Tests
        [Fact]
        public void WFiltro_Codigo_filtro_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Codigo_filtro_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Codigo_filtro_end_QuandoTemValorPositivo_SemCodigo_filtroInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorCodigo_filtroEnd = 5000;
            var filtro = new FilterInstancia
            {
                Codigo_filtro = int.MinValue, // Não define salário inicial
                Codigo_filtro_end = valorCodigo_filtroEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Codigo_filtro inicial válido, não deve incluir condição WHERE, mas o parâmetro Codigo_filtro_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Codigo_filtro_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Codigo_filtro_end_QuandoSomenteValorInicial_SemCodigo_filtroEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorCodigo_filtro = 2500;
            var filtro = new FilterInstancia
            {
                Codigo_filtro = valorCodigo_filtro,
                Codigo_filtro_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.CampoCodigo}] = @{DBInstanciaDicInfo.CampoCodigo}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBInstanciaDicInfo.CampoCodigo}");
            parametro.Value.Should().Be(valorCodigo_filtro);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorCodigo_filtroInicial = 1000;
            var valorCodigo_filtroFinal = 5000;
            var filtro = new FilterInstancia
            {
                Codigo_filtro = valorCodigo_filtroInicial,
                Codigo_filtro_end = valorCodigo_filtroFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].{DBInstanciaDicInfo.CampoCodigo} BETWEEN @{DBInstanciaDicInfo.CampoCodigo} AND @{DBInstanciaDicInfo.CampoCodigo}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.CampoCodigo}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.CampoCodigo}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorCodigo_filtroInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorCodigo_filtroFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Codigo_filtro_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Codigo_filtro = valorInicial,
                Codigo_filtro_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.CampoCodigo}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.CampoCodigo}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.CampoCodigo}");
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Objeto}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].{DBInstanciaDicInfo.CampoCodigo} BETWEEN");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorCodigo_filtroInicial = 2500;
            var valorCodigo_filtroFinal = 4750;
            var filtro = new FilterInstancia
            {
                Codigo_filtro = valorCodigo_filtroInicial,
                Codigo_filtro_end = valorCodigo_filtroFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.CampoCodigo}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBInstanciaDicInfo.CampoCodigo}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorCodigo_filtroInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorCodigo_filtroFinal);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Codigo_filtro = 0,
                Codigo_filtro_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Codigo_filtro = 0,
                Codigo_filtro_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Codigo_filtro = 1500,
                Codigo_filtro_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Codigo_filtro == int.MinValue) && !(filtro.Codigo_filtro_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBInstanciaDicInfo.PTabelaNome}].{DBInstanciaDicInfo.CampoCodigo} BETWEEN @{DBInstanciaDicInfo.CampoCodigo} AND @{DBInstanciaDicInfo.CampoCodigo}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Codigo_filtro = 2000,
                Codigo_filtro_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Codigo_filtro == int.MinValue) && filtro.Codigo_filtro_end == int.MinValue
            // Deve resultar em igualdade quando apenas Codigo_filtro tem valor válido
            resultado.Value.where.Should().Be($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.CampoCodigo}] = @{DBInstanciaDicInfo.CampoCodigo}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Codigo_filtro_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Codigo_filtro = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Codigo_filtro Isolated Tests
        [Fact]
        public void WFiltro_Codigo_filtro_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Codigo_filtro = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorCodigo_filtro = 5;
            var filtro = new FilterInstancia
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.CampoCodigo}] = @{DBInstanciaDicInfo.CampoCodigo}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBInstanciaDicInfo.CampoCodigo}");
            parametro.Value.Should().Be(valorCodigo_filtro);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorCodigo_filtro = 0;
            var filtro = new FilterInstancia
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBInstanciaDicInfo.CampoCodigo}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCodigo_filtro);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Codigo_filtro_DiferentesValoresValidos_DeveProcessarCorretamente(int valorCodigo_filtro)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCodigo_filtro);
            resultado.Value.where.Should().Contain($"= @{DBInstanciaDicInfo.CampoCodigo}");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Codigo_filtro = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.CampoCodigo}");
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Objeto}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Codigo_filtro = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Codigo_filtro = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Codigo_filtro = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Codigo_filtro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.CampoCodigo}]");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Codigo_filtro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Codigo_filtro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Codigo_filtro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorCodigo_filtro = 42;
            var filtro = new FilterInstancia
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorCodigo_filtro);
        }

#endregion
        [Fact]
        public void WFiltro_Codigo_filtro_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Codigo_filtro = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorCodigo_filtro = 1;
            var filtro = new FilterInstancia
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Codigo_filtro
            resultado.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.CampoCodigo}] = @{DBInstanciaDicInfo.CampoCodigo}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBInstanciaDicInfo.CampoCodigo}");
            parametro.Value.Should().Be(valorCodigo_filtro);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Codigo_filtro = 1,
                Objeto = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.CampoCodigo}");
            resultado.Value.where.Should().Contain($"@{DBInstanciaDicInfo.Objeto}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Codigo_filtro_DiferentesValores_DeveFuncionar(int valorCodigo_filtro)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCodigo_filtro);
        }

#endregion
#region Decimal Tests
#endregion
#region DateTime Tests
        [Theory]
        [InlineData("31/12/9999")] // Data máxima
        [InlineData("01/01/1900")] // Data muito antiga
        [InlineData("29/02/2024")] // Ano bissexto
        public void WFiltro_ZKeyQuando_ComDatasExtremas_DeveProcessarCorretamente(string dataExtrema)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyQuando = dataExtrema,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<DateTime>();
        }

        [Theory]
        [InlineData("32/12/2023")] // Dia inválido
        [InlineData("31/13/2023")] // Mês inválido
        [InlineData("29/02/2023")] // Não é ano bissexto
        [InlineData("abc/def/ghij")] // Formato completamente inválido
        public void WFiltro_ZKeyQuando_ComDatasInvalidas_NaoDeveAdicionarParametros(string dataInvalida)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyQuando = dataInvalida,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().BeEmpty();
            resultado.Value.where.Should().BeEmpty();
        }

#region ZKeyQuando Tests
        [Fact]
        public void WFiltro_ZKeyQuando_WhenEmptyOrNull_ShouldNotAddParameters()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyQuando = string.Empty,
                ZKeyQuando_end = null,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_ZKeyQuando_WhenValidSingleDate_ShouldAddParameterAndGenerateWhereClause()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterInstancia
            {
                ZKeyQuando = testDate,
                ZKeyQuando_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(1);
            var parameter = result.Value.parametros.First();
            parameter.ParameterName.Should().Be($"@{DBInstanciaDicInfo.ZKeyQuando}");
            parameter.Value.Should().BeOfType<DateTime>();
            var expectedDate = DateTime.Parse(testDate);
            ((DateTime)parameter.Value).Should().Be(expectedDate);
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.ZKeyQuando}], 103) = CONVERT(DATE, @{DBInstanciaDicInfo.ZKeyQuando}, 103)");
        }

        [Fact]
        public void WFiltro_ZKeyQuando_WhenValidDateRange_ShouldAddBothParametersAndGenerateBetweenClause()
        {
            // Arrange
            var startDate = "01/06/2023";
            var endDate = "30/06/2023";
            var filtro = new FilterInstancia
            {
                ZKeyQuando = startDate,
                ZKeyQuando_end = endDate,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(2);
            var startParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.ZKeyQuando}");
            var endParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.ZKeyQuando}_end");
            startParameter.Should().NotBeNull();
            endParameter.Should().NotBeNull();
            startParameter!.Value.Should().BeOfType<DateTime>();
            endParameter!.Value.Should().BeOfType<DateTime>();
            ((DateTime)startParameter.Value).Should().Be(DateTime.Parse(startDate));
            ((DateTime)endParameter.Value).Should().Be(DateTime.Parse(endDate));
            result.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].{DBInstanciaDicInfo.ZKeyQuando} BETWEEN @{DBInstanciaDicInfo.ZKeyQuando} AND @{DBInstanciaDicInfo.ZKeyQuando}_end");
        }

        [Fact]
        public void WFiltro_ZKeyQuando_WhenInvalidDateFormat_ShouldNotAddParameter()
        {
            // Arrange
            var invalidDate = "invalid-date";
            var filtro = new FilterInstancia
            {
                ZKeyQuando = invalidDate,
                ZKeyQuando_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_ZKeyQuando_WhenStartDateValidButEndDateInvalid_ShouldOnlyAddStartParameterAndGenerateSingleDateClause()
        {
            // Arrange
            var validStartDate = "15/06/2023";
            var invalidEndDate = "invalid-date";
            var filtro = new FilterInstancia
            {
                ZKeyQuando = validStartDate,
                ZKeyQuando_end = invalidEndDate,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(1);
            var parameter = result.Value.parametros.First();
            parameter.ParameterName.Should().Be($"@{DBInstanciaDicInfo.ZKeyQuando}");
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.ZKeyQuando}], 103) = CONVERT(DATE, @{DBInstanciaDicInfo.ZKeyQuando}, 103)");
            result.Value.where.Should().NotContain("BETWEEN");
        }

        [Fact]
        public void WFiltro_ZKeyQuando_WhenStartDateInvalidButEndDateValid_ShouldNotAddAnyParameters()
        {
            // Arrange
            var invalidStartDate = "invalid-date";
            var validEndDate = "30/06/2023";
            var filtro = new FilterInstancia
            {
                ZKeyQuando = invalidStartDate,
                ZKeyQuando_end = validEndDate,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_ZKeyQuando_WhenWhitespaceOnlyDates_ShouldNotAddParameters()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyQuando = "   ",
                ZKeyQuando_end = "\t\n",
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_ZKeyQuando_WithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterInstancia
            {
                Objeto = "A",
                ZKeyQuando = testDate,
                ZKeyQuando_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(2); // Nome + ZKeyQuando
            result.Value.where.Should().Contain(TSql.And);
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.ZKeyQuando}], 103) = CONVERT(DATE, @{DBInstanciaDicInfo.ZKeyQuando}, 103)");
        }

        [Fact]
        public void WFiltro_ZKeyQuando_WithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterInstancia
            {
                Objeto = "A",
                ZKeyQuando = testDate,
                ZKeyQuando_end = string.Empty,
                LogicalOperator = TSql.OR
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(TSql.OR);
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.ZKeyQuando}], 103) = CONVERT(DATE, @{DBInstanciaDicInfo.ZKeyQuando}, 103)");
        }

        [Fact]
        public void WFiltro_ZKeyQuando_WhenOnlyEndDateProvided_ShouldNotAddParameters()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyQuando = string.Empty,
                ZKeyQuando_end = "30/06/2023",
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_ZKeyQuando_WhenDateTimeMinValue_ShouldNotAddParameters()
        {
            // Arrange
            var minValueDate = DateTime.MinValue.ToString("dd/MM/yyyy");
            var filtro = new FilterInstancia
            {
                ZKeyQuando = minValueDate,
                ZKeyQuando_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // The IsEmptyDX extension method should catch DateTime.MinValue and return true
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_ZKeyQuando_AsFirstFilter_ShouldNotIncludeLogicalOperatorAtStart()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterInstancia
            {
                ZKeyQuando = testDate,
                ZKeyQuando_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().NotStartWith(TSql.And);
            result.Value.where.Should().StartWith($"CONVERT(DATE,[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.ZKeyQuando}], 103)");
        }

        [Theory]
        [InlineData("15/06/2023", "2023-06-15T00:00:00")]
        [InlineData("01/01/2024", "2024-01-01T00:00:00")]
        [InlineData("31/12/2022", "2022-12-31T00:00:00")]
        public void WFiltro_ZKeyQuando_WhenVariousValidDateFormats_ShouldParseCorrectly(string inputDate, string expectedDateTimeString)
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                ZKeyQuando = inputDate,
                ZKeyQuando_end = string.Empty,
                LogicalOperator = TSql.And
            };
            var expectedDateTime = DateTime.Parse(expectedDateTimeString);
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(1);
            var parameter = result.Value.parametros.First();
            ((DateTime)parameter.Value).Should().Be(expectedDateTime);
        }

#endregion
#endregion
#region Bool Tests
#region LiminarPendente Filter Tests
        [Fact]
        public void WFiltro_LiminarPendenteEqualsIntMinValue_ShouldNotAddParameterOrWhereClause()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                LiminarPendente = int.MinValue
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().NotContain(p => p.ParameterName.Contains(DBInstanciaDicInfo.LiminarPendente));
            result.Value.where.Should().NotContain(DBInstanciaDicInfo.LiminarPendente);
        }

        [Fact]
        public void WFiltro_LiminarPendenteHasValidValue_ShouldAddParameterAndWhereClause()
        {
            // Arrange
            var LiminarPendenteValue = 1;
            var filtro = new FilterInstancia
            {
                LiminarPendente = LiminarPendenteValue,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // Check parameter
            var LiminarPendenteParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.LiminarPendente}");
            LiminarPendenteParameter.Should().NotBeNull();
            LiminarPendenteParameter.Value.Should().Be(LiminarPendenteValue);
            // Check where clause
            result.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.LiminarPendente}] = @{DBInstanciaDicInfo.LiminarPendente}");
        }

        [Fact]
        public void WFiltro_LiminarPendenteWithDifferentValues_ShouldAddCorrectParameterValue()
        {
            // Arrange & Act & Assert for LiminarPendente = 0 (typically female)
            var filtroFemale = new FilterInstancia
            {
                LiminarPendente = 0
            };
            var resultFemale = _service.WFiltro(filtroFemale);
            resultFemale.Should().NotBeNull();
            var femaleParam = resultFemale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.LiminarPendente}");
            femaleParam.Should().NotBeNull();
            femaleParam.Value.Should().Be(0);
            // Arrange & Act & Assert for LiminarPendente = 1 (typically male)
            var filtroMale = new FilterInstancia
            {
                LiminarPendente = 1
            };
            var resultMale = _service.WFiltro(filtroMale);
            resultMale.Should().NotBeNull();
            var maleParam = resultMale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.LiminarPendente}");
            maleParam.Should().NotBeNull();
            maleParam.Value.Should().Be(1);
        }

        [Fact]
        public void WFiltro_LiminarPendenteAsFirstFilter_ShouldNotIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                LiminarPendente = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().StartWith($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.LiminarPendente}] = @{DBInstanciaDicInfo.LiminarPendente}");
            result.Value.where.Should().NotStartWith(" AND ");
        }

        [Fact]
        public void WFiltro_LiminarPendenteWithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Objeto = "Objeto",
                LiminarPendente = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain($" AND ");
        }

        [Fact]
        public void WFiltro_LiminarPendenteWithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Objeto = "Objeto",
                LiminarPendente = 1,
                LogicalOperator = " OR "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(" OR ");
        }

#endregion
#region InterpusemosRecurso Filter Tests
        [Fact]
        public void WFiltro_InterpusemosRecursoEqualsIntMinValue_ShouldNotAddParameterOrWhereClause()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                InterpusemosRecurso = int.MinValue
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().NotContain(p => p.ParameterName.Contains(DBInstanciaDicInfo.InterpusemosRecurso));
            result.Value.where.Should().NotContain(DBInstanciaDicInfo.InterpusemosRecurso);
        }

        [Fact]
        public void WFiltro_InterpusemosRecursoHasValidValue_ShouldAddParameterAndWhereClause()
        {
            // Arrange
            var InterpusemosRecursoValue = 1;
            var filtro = new FilterInstancia
            {
                InterpusemosRecurso = InterpusemosRecursoValue,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // Check parameter
            var InterpusemosRecursoParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.InterpusemosRecurso}");
            InterpusemosRecursoParameter.Should().NotBeNull();
            InterpusemosRecursoParameter.Value.Should().Be(InterpusemosRecursoValue);
            // Check where clause
            result.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.InterpusemosRecurso}] = @{DBInstanciaDicInfo.InterpusemosRecurso}");
        }

        [Fact]
        public void WFiltro_InterpusemosRecursoWithDifferentValues_ShouldAddCorrectParameterValue()
        {
            // Arrange & Act & Assert for InterpusemosRecurso = 0 (typically female)
            var filtroFemale = new FilterInstancia
            {
                InterpusemosRecurso = 0
            };
            var resultFemale = _service.WFiltro(filtroFemale);
            resultFemale.Should().NotBeNull();
            var femaleParam = resultFemale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.InterpusemosRecurso}");
            femaleParam.Should().NotBeNull();
            femaleParam.Value.Should().Be(0);
            // Arrange & Act & Assert for InterpusemosRecurso = 1 (typically male)
            var filtroMale = new FilterInstancia
            {
                InterpusemosRecurso = 1
            };
            var resultMale = _service.WFiltro(filtroMale);
            resultMale.Should().NotBeNull();
            var maleParam = resultMale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.InterpusemosRecurso}");
            maleParam.Should().NotBeNull();
            maleParam.Value.Should().Be(1);
        }

        [Fact]
        public void WFiltro_InterpusemosRecursoAsFirstFilter_ShouldNotIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                InterpusemosRecurso = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().StartWith($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.InterpusemosRecurso}] = @{DBInstanciaDicInfo.InterpusemosRecurso}");
            result.Value.where.Should().NotStartWith(" AND ");
        }

        [Fact]
        public void WFiltro_InterpusemosRecursoWithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Objeto = "Objeto",
                InterpusemosRecurso = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain($" AND ");
        }

        [Fact]
        public void WFiltro_InterpusemosRecursoWithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Objeto = "Objeto",
                InterpusemosRecurso = 1,
                LogicalOperator = " OR "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(" OR ");
        }

#endregion
#region LiminarConcedida Filter Tests
        [Fact]
        public void WFiltro_LiminarConcedidaEqualsIntMinValue_ShouldNotAddParameterOrWhereClause()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                LiminarConcedida = int.MinValue
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().NotContain(p => p.ParameterName.Contains(DBInstanciaDicInfo.LiminarConcedida));
            result.Value.where.Should().NotContain(DBInstanciaDicInfo.LiminarConcedida);
        }

        [Fact]
        public void WFiltro_LiminarConcedidaHasValidValue_ShouldAddParameterAndWhereClause()
        {
            // Arrange
            var LiminarConcedidaValue = 1;
            var filtro = new FilterInstancia
            {
                LiminarConcedida = LiminarConcedidaValue,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // Check parameter
            var LiminarConcedidaParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.LiminarConcedida}");
            LiminarConcedidaParameter.Should().NotBeNull();
            LiminarConcedidaParameter.Value.Should().Be(LiminarConcedidaValue);
            // Check where clause
            result.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.LiminarConcedida}] = @{DBInstanciaDicInfo.LiminarConcedida}");
        }

        [Fact]
        public void WFiltro_LiminarConcedidaWithDifferentValues_ShouldAddCorrectParameterValue()
        {
            // Arrange & Act & Assert for LiminarConcedida = 0 (typically female)
            var filtroFemale = new FilterInstancia
            {
                LiminarConcedida = 0
            };
            var resultFemale = _service.WFiltro(filtroFemale);
            resultFemale.Should().NotBeNull();
            var femaleParam = resultFemale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.LiminarConcedida}");
            femaleParam.Should().NotBeNull();
            femaleParam.Value.Should().Be(0);
            // Arrange & Act & Assert for LiminarConcedida = 1 (typically male)
            var filtroMale = new FilterInstancia
            {
                LiminarConcedida = 1
            };
            var resultMale = _service.WFiltro(filtroMale);
            resultMale.Should().NotBeNull();
            var maleParam = resultMale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.LiminarConcedida}");
            maleParam.Should().NotBeNull();
            maleParam.Value.Should().Be(1);
        }

        [Fact]
        public void WFiltro_LiminarConcedidaAsFirstFilter_ShouldNotIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                LiminarConcedida = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().StartWith($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.LiminarConcedida}] = @{DBInstanciaDicInfo.LiminarConcedida}");
            result.Value.where.Should().NotStartWith(" AND ");
        }

        [Fact]
        public void WFiltro_LiminarConcedidaWithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Objeto = "Objeto",
                LiminarConcedida = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain($" AND ");
        }

        [Fact]
        public void WFiltro_LiminarConcedidaWithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Objeto = "Objeto",
                LiminarConcedida = 1,
                LogicalOperator = " OR "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(" OR ");
        }

#endregion
#region LiminarNegada Filter Tests
        [Fact]
        public void WFiltro_LiminarNegadaEqualsIntMinValue_ShouldNotAddParameterOrWhereClause()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                LiminarNegada = int.MinValue
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().NotContain(p => p.ParameterName.Contains(DBInstanciaDicInfo.LiminarNegada));
            result.Value.where.Should().NotContain(DBInstanciaDicInfo.LiminarNegada);
        }

        [Fact]
        public void WFiltro_LiminarNegadaHasValidValue_ShouldAddParameterAndWhereClause()
        {
            // Arrange
            var LiminarNegadaValue = 1;
            var filtro = new FilterInstancia
            {
                LiminarNegada = LiminarNegadaValue,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // Check parameter
            var LiminarNegadaParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.LiminarNegada}");
            LiminarNegadaParameter.Should().NotBeNull();
            LiminarNegadaParameter.Value.Should().Be(LiminarNegadaValue);
            // Check where clause
            result.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.LiminarNegada}] = @{DBInstanciaDicInfo.LiminarNegada}");
        }

        [Fact]
        public void WFiltro_LiminarNegadaWithDifferentValues_ShouldAddCorrectParameterValue()
        {
            // Arrange & Act & Assert for LiminarNegada = 0 (typically female)
            var filtroFemale = new FilterInstancia
            {
                LiminarNegada = 0
            };
            var resultFemale = _service.WFiltro(filtroFemale);
            resultFemale.Should().NotBeNull();
            var femaleParam = resultFemale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.LiminarNegada}");
            femaleParam.Should().NotBeNull();
            femaleParam.Value.Should().Be(0);
            // Arrange & Act & Assert for LiminarNegada = 1 (typically male)
            var filtroMale = new FilterInstancia
            {
                LiminarNegada = 1
            };
            var resultMale = _service.WFiltro(filtroMale);
            resultMale.Should().NotBeNull();
            var maleParam = resultMale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.LiminarNegada}");
            maleParam.Should().NotBeNull();
            maleParam.Value.Should().Be(1);
        }

        [Fact]
        public void WFiltro_LiminarNegadaAsFirstFilter_ShouldNotIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                LiminarNegada = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().StartWith($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.LiminarNegada}] = @{DBInstanciaDicInfo.LiminarNegada}");
            result.Value.where.Should().NotStartWith(" AND ");
        }

        [Fact]
        public void WFiltro_LiminarNegadaWithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Objeto = "Objeto",
                LiminarNegada = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain($" AND ");
        }

        [Fact]
        public void WFiltro_LiminarNegadaWithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Objeto = "Objeto",
                LiminarNegada = 1,
                LogicalOperator = " OR "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(" OR ");
        }

#endregion
#region LiminarParcial Filter Tests
        [Fact]
        public void WFiltro_LiminarParcialEqualsIntMinValue_ShouldNotAddParameterOrWhereClause()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                LiminarParcial = int.MinValue
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().NotContain(p => p.ParameterName.Contains(DBInstanciaDicInfo.LiminarParcial));
            result.Value.where.Should().NotContain(DBInstanciaDicInfo.LiminarParcial);
        }

        [Fact]
        public void WFiltro_LiminarParcialHasValidValue_ShouldAddParameterAndWhereClause()
        {
            // Arrange
            var LiminarParcialValue = 1;
            var filtro = new FilterInstancia
            {
                LiminarParcial = LiminarParcialValue,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // Check parameter
            var LiminarParcialParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.LiminarParcial}");
            LiminarParcialParameter.Should().NotBeNull();
            LiminarParcialParameter.Value.Should().Be(LiminarParcialValue);
            // Check where clause
            result.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.LiminarParcial}] = @{DBInstanciaDicInfo.LiminarParcial}");
        }

        [Fact]
        public void WFiltro_LiminarParcialWithDifferentValues_ShouldAddCorrectParameterValue()
        {
            // Arrange & Act & Assert for LiminarParcial = 0 (typically female)
            var filtroFemale = new FilterInstancia
            {
                LiminarParcial = 0
            };
            var resultFemale = _service.WFiltro(filtroFemale);
            resultFemale.Should().NotBeNull();
            var femaleParam = resultFemale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.LiminarParcial}");
            femaleParam.Should().NotBeNull();
            femaleParam.Value.Should().Be(0);
            // Arrange & Act & Assert for LiminarParcial = 1 (typically male)
            var filtroMale = new FilterInstancia
            {
                LiminarParcial = 1
            };
            var resultMale = _service.WFiltro(filtroMale);
            resultMale.Should().NotBeNull();
            var maleParam = resultMale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.LiminarParcial}");
            maleParam.Should().NotBeNull();
            maleParam.Value.Should().Be(1);
        }

        [Fact]
        public void WFiltro_LiminarParcialAsFirstFilter_ShouldNotIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                LiminarParcial = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().StartWith($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.LiminarParcial}] = @{DBInstanciaDicInfo.LiminarParcial}");
            result.Value.where.Should().NotStartWith(" AND ");
        }

        [Fact]
        public void WFiltro_LiminarParcialWithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Objeto = "Objeto",
                LiminarParcial = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain($" AND ");
        }

        [Fact]
        public void WFiltro_LiminarParcialWithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Objeto = "Objeto",
                LiminarParcial = 1,
                LogicalOperator = " OR "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(" OR ");
        }

#endregion
#region LiminarCliente Filter Tests
        [Fact]
        public void WFiltro_LiminarClienteEqualsIntMinValue_ShouldNotAddParameterOrWhereClause()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                LiminarCliente = int.MinValue
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().NotContain(p => p.ParameterName.Contains(DBInstanciaDicInfo.LiminarCliente));
            result.Value.where.Should().NotContain(DBInstanciaDicInfo.LiminarCliente);
        }

        [Fact]
        public void WFiltro_LiminarClienteHasValidValue_ShouldAddParameterAndWhereClause()
        {
            // Arrange
            var LiminarClienteValue = 1;
            var filtro = new FilterInstancia
            {
                LiminarCliente = LiminarClienteValue,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // Check parameter
            var LiminarClienteParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.LiminarCliente}");
            LiminarClienteParameter.Should().NotBeNull();
            LiminarClienteParameter.Value.Should().Be(LiminarClienteValue);
            // Check where clause
            result.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.LiminarCliente}] = @{DBInstanciaDicInfo.LiminarCliente}");
        }

        [Fact]
        public void WFiltro_LiminarClienteWithDifferentValues_ShouldAddCorrectParameterValue()
        {
            // Arrange & Act & Assert for LiminarCliente = 0 (typically female)
            var filtroFemale = new FilterInstancia
            {
                LiminarCliente = 0
            };
            var resultFemale = _service.WFiltro(filtroFemale);
            resultFemale.Should().NotBeNull();
            var femaleParam = resultFemale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.LiminarCliente}");
            femaleParam.Should().NotBeNull();
            femaleParam.Value.Should().Be(0);
            // Arrange & Act & Assert for LiminarCliente = 1 (typically male)
            var filtroMale = new FilterInstancia
            {
                LiminarCliente = 1
            };
            var resultMale = _service.WFiltro(filtroMale);
            resultMale.Should().NotBeNull();
            var maleParam = resultMale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.LiminarCliente}");
            maleParam.Should().NotBeNull();
            maleParam.Value.Should().Be(1);
        }

        [Fact]
        public void WFiltro_LiminarClienteAsFirstFilter_ShouldNotIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                LiminarCliente = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().StartWith($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.LiminarCliente}] = @{DBInstanciaDicInfo.LiminarCliente}");
            result.Value.where.Should().NotStartWith(" AND ");
        }

        [Fact]
        public void WFiltro_LiminarClienteWithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Objeto = "Objeto",
                LiminarCliente = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain($" AND ");
        }

        [Fact]
        public void WFiltro_LiminarClienteWithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Objeto = "Objeto",
                LiminarCliente = 1,
                LogicalOperator = " OR "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(" OR ");
        }

#endregion
#region Principal Filter Tests
        [Fact]
        public void WFiltro_PrincipalEqualsIntMinValue_ShouldNotAddParameterOrWhereClause()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Principal = int.MinValue
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().NotContain(p => p.ParameterName.Contains(DBInstanciaDicInfo.Principal));
            result.Value.where.Should().NotContain(DBInstanciaDicInfo.Principal);
        }

        [Fact]
        public void WFiltro_PrincipalHasValidValue_ShouldAddParameterAndWhereClause()
        {
            // Arrange
            var PrincipalValue = 1;
            var filtro = new FilterInstancia
            {
                Principal = PrincipalValue,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // Check parameter
            var PrincipalParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.Principal}");
            PrincipalParameter.Should().NotBeNull();
            PrincipalParameter.Value.Should().Be(PrincipalValue);
            // Check where clause
            result.Value.where.Should().Contain($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.Principal}] = @{DBInstanciaDicInfo.Principal}");
        }

        [Fact]
        public void WFiltro_PrincipalWithDifferentValues_ShouldAddCorrectParameterValue()
        {
            // Arrange & Act & Assert for Principal = 0 (typically female)
            var filtroFemale = new FilterInstancia
            {
                Principal = 0
            };
            var resultFemale = _service.WFiltro(filtroFemale);
            resultFemale.Should().NotBeNull();
            var femaleParam = resultFemale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.Principal}");
            femaleParam.Should().NotBeNull();
            femaleParam.Value.Should().Be(0);
            // Arrange & Act & Assert for Principal = 1 (typically male)
            var filtroMale = new FilterInstancia
            {
                Principal = 1
            };
            var resultMale = _service.WFiltro(filtroMale);
            resultMale.Should().NotBeNull();
            var maleParam = resultMale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBInstanciaDicInfo.Principal}");
            maleParam.Should().NotBeNull();
            maleParam.Value.Should().Be(1);
        }

        [Fact]
        public void WFiltro_PrincipalAsFirstFilter_ShouldNotIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Principal = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().StartWith($"[{DBInstanciaDicInfo.PTabelaNome}].[{DBInstanciaDicInfo.Principal}] = @{DBInstanciaDicInfo.Principal}");
            result.Value.where.Should().NotStartWith(" AND ");
        }

        [Fact]
        public void WFiltro_PrincipalWithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Objeto = "Objeto",
                Principal = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain($" AND ");
        }

        [Fact]
        public void WFiltro_PrincipalWithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var filtro = new FilterInstancia
            {
                Objeto = "Objeto",
                Principal = 1,
                LogicalOperator = " OR "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(" OR ");
        }

#endregion
#endregion
        [Fact]
        public void Dispose_CalledOnce_DisposesCorrectly()
        {
            // Act
            _service.Dispose();
            // Assert - Should not throw any exception
            Assert.True(true);
        }

        [Fact]
        public void Dispose_CalledTwice_DoesNotThrow()
        {
            // Act
            _service.Dispose();
            _service.Dispose();
            // Assert - Should not throw any exception
            Assert.True(true);
        }

        public virtual void Dispose()
        {
            _service?.Dispose();
        }
    }
}