// 100% auto-generated by Source Genesys WebApi Front & Back Creator
// copyright © 2000-2025 Menphis - Sistemas Inteligentes
// This file is part of the Source Genesys project                     
#pragma warning disable IDE0130 // Namespace does not match folder structure

namespace MenphisSI.GerAdv.Services;
#pragma warning restore IDE0130 // Namespace does not match folder structure

public partial class CidadeService(IOptions<AppSettings> appSettings, IFCidadeFactory cidadeFactory, ICidadeReader reader, ICidadeValidation validation, ICidadeWriter writer, IUFReader ufReader, IAdvogadosService advogadosService, IAgendaService agendaService, IBensMateriaisService bensmateriaisService, IClientesService clientesService, IClientesSociosService clientessociosService, IColaboradoresService colaboradoresService, IDivisaoTribunalService divisaotribunalService, IEnderecosService enderecosService, IEscritoriosService escritoriosService, IFornecedoresService fornecedoresService, IForoService foroService, IFuncionariosService funcionariosService, IOponentesService oponentesService, IOponentesRepLegalService oponentesreplegalService, IOutrasPartesClienteService outraspartesclienteService, IPreClientesService preclientesService, IPrepostosService prepostosService, ITerceirosService terceirosService, IHttpContextAccessor httpContextAccessor, HybridCache cache, IMemoryCache memory) : ICidadeService, IDisposable
{
    private readonly IHttpContextAccessor _httpContextAccessor = httpContextAccessor;
    private readonly IOptions<AppSettings> _appSettings = appSettings;
    private readonly HybridCache _cache = cache;
    private readonly IMemoryCache _memoryCache = memory;
    private bool _disposed;
    private readonly IFCidadeFactory cidadeFactory = cidadeFactory;
    private readonly ICidadeReader reader = reader;
    private readonly ICidadeValidation validation = validation;
    private readonly ICidadeWriter writer = writer;
    private readonly IUFReader ufReader = ufReader;
    private readonly IAdvogadosService advogadosService = advogadosService;
    private readonly IAgendaService agendaService = agendaService;
    private readonly IBensMateriaisService bensmateriaisService = bensmateriaisService;
    private readonly IClientesService clientesService = clientesService;
    private readonly IClientesSociosService clientessociosService = clientessociosService;
    private readonly IColaboradoresService colaboradoresService = colaboradoresService;
    private readonly IDivisaoTribunalService divisaotribunalService = divisaotribunalService;
    private readonly IEnderecosService enderecosService = enderecosService;
    private readonly IEscritoriosService escritoriosService = escritoriosService;
    private readonly IFornecedoresService fornecedoresService = fornecedoresService;
    private readonly IForoService foroService = foroService;
    private readonly IFuncionariosService funcionariosService = funcionariosService;
    private readonly IOponentesService oponentesService = oponentesService;
    private readonly IOponentesRepLegalService oponentesreplegalService = oponentesreplegalService;
    private readonly IOutrasPartesClienteService outraspartesclienteService = outraspartesclienteService;
    private readonly IPreClientesService preclientesService = preclientesService;
    private readonly IPrepostosService prepostosService = prepostosService;
    private readonly ITerceirosService terceirosService = terceirosService;
    public async Task<IEnumerable<CidadeResponseAll>> GetAll(int max, [FromRoute, Required] string uri, CancellationToken token = default)
    {
        max = Math.Min(Math.Max(max, 1), BaseConsts.PMaxItens);
        ThrowIfDisposed();
        if (!Uris.ValidaUri(uri, _appSettings))
        {
            throw new Exception("Cidade: URI inválida");
        }

        var entryOptions = new HybridCacheEntryOptions
        {
            Expiration = TimeSpan.FromMinutes(BaseConsts.PMaxMinutesCache),
            LocalCacheExpiration = TimeSpan.FromMinutes(BaseConsts.PMaxMinutesCache)
        };
        using var oCnn = Configuracoes.GetConnectionByUri(uri);
        var keyCache = await reader.ReadStringAuditor(max, uri, "", [], oCnn);
        var cacheKey = $"{uri}-Cidade-Filter-{max}-{keyCache}";
        var result = await _cache.GetOrCreateAsync(cacheKey, async cancel => await GetDataAllAsync(max, string.Empty, [], uri, cancel), entryOptions, cancellationToken: token);
        return result;
    }

    public async Task<IEnumerable<CidadeResponseAll>> Filter([FromQuery] int max, [FromBody] Filters.FilterCidade filtro, [FromRoute, Required] string uri)
    {
        ThrowIfDisposed();
        using var oCnn = Configuracoes.GetConnectionByUri(uri);
        if (oCnn == null)
        {
            throw new DatabaseConnectionException();
        }

        if (max <= 0)
        {
            max = BaseConsts.PMaxItens;
        }

        var filtroResult = filtro == null ? null : WFiltro(filtro!);
        string where = filtroResult?.where ?? string.Empty;
        List<SqlParameter> parameters = filtroResult?.parametros ?? [];
        var filterHash = GetFilterHash(filtro);
        var keyCache = await reader.ReadStringAuditor(max, uri, where, parameters, oCnn);
        var cacheKey = $"{uri}-{max}Cidade-Filter-{where.GetHashCode2()}{filterHash}{keyCache}";
        var entryOptions = new HybridCacheEntryOptions
        {
            Expiration = TimeSpan.FromSeconds(BaseConsts.PMaxGetListSecondsCacheId),
            LocalCacheExpiration = TimeSpan.FromSeconds(BaseConsts.PMaxGetListSecondsCacheId)
        };
        var result = await _cache.GetOrCreateAsync(cacheKey, async cancel => await GetDataAllAsync(max, string.IsNullOrEmpty(where) ? string.Empty : TSql.Where + where, parameters, uri, cancel), entryOptions, cancellationToken: new());
        return result;
    }

    public async Task<CidadeResponse?> GetById([FromQuery] int id, [FromRoute, Required] string uri, CancellationToken token)
    {
        ThrowIfDisposed();
        if (id < 1)
        {
            return new CidadeResponse();
        }

        var entryOptions = new HybridCacheEntryOptions
        {
            Expiration = TimeSpan.FromSeconds(BaseConsts.PMaxSecondsCacheId),
            LocalCacheExpiration = TimeSpan.FromSeconds(BaseConsts.PMaxSecondsCacheId)
        };
        using var oCnn = Configuracoes.GetConnectionByUri(uri);
        try
        {
            var keyCache = await reader.ReadStringAuditor(id, uri, oCnn);
            var result = await _cache.GetOrCreateAsync($"{uri}-Cidade-GetById-{id}-{keyCache}", async cancel => await GetDataByIdAsync(id, oCnn, cancel), entryOptions, cancellationToken: token);
            return result;
        }
        catch (Exception)
        {
            throw new Exception($"Cidade - {uri}-: GetById");
        }
    }

    private async Task<CidadeResponse?> GetDataByIdAsync(int id, MsiSqlConnection? oCnn, CancellationToken token) => await reader.Read(id, oCnn);
    public async Task<CidadeResponse?> AddAndUpdate([FromBody] Models.Cidade? regCidade, [FromRoute, Required] string uri)
    {
        ThrowIfDisposed();
        if (regCidade == null)
        {
            return null;
        }

        if (!Uris.ValidaUri(uri, _appSettings))
        {
            throw new Exception("Cidade: URI inválida");
        }

        using var oCnn = Configuracoes.GetConnectionByUriRw(uri);
        if (oCnn == null)
        {
            return null;
        }

        try
        {
            var validade = await validation.ValidateReg(regCidade, this, ufReader, uri, oCnn);
            if (!validade)
            {
                throw new Exception("Erro inesperado ao validar 0x0!");
            }
        }
        catch (SGValidationException ex)
        {
            throw new Exception(ex.Message);
        }
        catch (Exception)
        {
            throw new Exception("Erro inesperado ao validar 0x1!");
        }

        int operadorId = UserTools.GetAuthenticatedUserId(_httpContextAccessor);
        using var saved = await writer.WriteAsync(regCidade, operadorId, oCnn);
        return reader.Read(saved, oCnn);
    }

    public async Task<CidadeResponse?> Validation([FromBody] Models.Cidade? regCidade, [FromRoute, Required] string uri)
    {
        ThrowIfDisposed();
        if (regCidade == null)
        {
            return null;
        }

        if (!Uris.ValidaUri(uri, _appSettings))
        {
            throw new Exception("Cidade: URI inválida");
        }

        using var oCnn = Configuracoes.GetConnectionByUriRw(uri);
        if (oCnn == null)
        {
            return null;
        }

        try
        {
            var validade = await validation.ValidateReg(regCidade, this, ufReader, uri, oCnn);
            if (!validade)
            {
                throw new Exception("Erro inesperado ao validar 0x0!");
            }
        }
        catch (SGValidationException ex)
        {
            throw new Exception(ex.Message);
        }
        catch (Exception)
        {
            throw new Exception("Erro inesperado ao validar 0x1!");
        }

        if (regCidade.Id.IsEmptyIDNumber())
        {
            return new CidadeResponse();
        }

        return await reader.Read(regCidade.Id, oCnn);
    }

    public async Task<CidadeResponse?> Delete([FromQuery] int? id, [FromRoute, Required] string uri)
    {
        if (id == null || id.IsEmptyIDNumber())
        {
            return null;
        }

        ThrowIfDisposed();
        if (!Uris.ValidaUri(uri, _appSettings))
        {
            throw new Exception("Cidade: URI inválida");
        }

        var nOperador = UserTools.GetAuthenticatedUserId(_httpContextAccessor);
        using var oCnn = Configuracoes.GetConnectionByUriRw(uri);
        if (oCnn == null)
        {
            return null;
        }

        try
        {
            var deleteValidation = await validation.CanDelete(id, this, advogadosService, agendaService, bensmateriaisService, clientesService, clientessociosService, colaboradoresService, divisaotribunalService, enderecosService, escritoriosService, fornecedoresService, foroService, funcionariosService, oponentesService, oponentesreplegalService, outraspartesclienteService, preclientesService, prepostosService, terceirosService, uri, oCnn);
            if (!deleteValidation)
            {
                throw new Exception("Erro inesperado ao validar 0x0!");
            }
        }
        catch (SGValidationException ex)
        {
            throw new Exception(ex.Message);
        }
        catch (Exception)
        {
            throw new Exception("Erro inesperado ao validar 0x1!");
        }

        var cidade = await reader.Read(id ?? default, oCnn);
        try
        {
            if (cidade != null)
            {
                await writer.Delete(cidade, nOperador, oCnn);
                if (_memoryCache is MemoryCache memCache)
                {
                    memCache.Compact(1.0);
                }
            }
        }
        catch (Exception ex)
        {
            throw new Exception(ex.Message);
        }

        return cidade;
    }

    public virtual void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (_disposed)
            return;
        if (disposing)
        {
        //_cache?.Dispose();
        }

        _disposed = true;
    }

    private void ThrowIfDisposed()
    {
        if (_disposed)
        {
            throw new ObjectDisposedException(GetType().Name);
        }
    }
}