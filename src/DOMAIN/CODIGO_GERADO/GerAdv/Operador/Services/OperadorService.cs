// 100% auto-generated by Source Genesys WebApi Front & Back Creator
// copyright © 2000-2025 Menphis - Sistemas Inteligentes
// This file is part of the Source Genesys project                     
#pragma warning disable IDE0130 // Namespace does not match folder structure

namespace MenphisSI.GerAdv.Services;
#pragma warning restore IDE0130 // Namespace does not match folder structure

public partial class OperadorService(IOptions<AppSettings> appSettings, IFOperadorFactory operadorFactory, IOperadorReader reader, IOperadorValidation validation, IOperadorWriter writer, IStatusBiuReader statusbiuReader, IAgendaService agendaService, IAgendaFinanceiroService agendafinanceiroService, IAlarmSMSService alarmsmsService, IAlertasService alertasService, IAlertasEnviadosService alertasenviadosService, IContatoCRMService contatocrmService, IContatoCRMOperadorService contatocrmoperadorService, IDiario2Service diario2Service, IGUTAtividadesService gutatividadesService, IOperadorEMailPopupService operadoremailpopupService, IOperadorGrupoService operadorgrupoService, IOperadorGruposAgendaService operadorgruposagendaService, IOperadorGruposAgendaOperadoresService operadorgruposagendaoperadoresService, IPontoVirtualService pontovirtualService, IPontoVirtualAcessosService pontovirtualacessosService, IProcessosParadosService processosparadosService, IProcessOutputRequestService processoutputrequestService, IReuniaoPessoasService reuniaopessoasService, ISMSAliceService smsaliceService, IStatusBiuService statusbiuService, IHttpContextAccessor httpContextAccessor, HybridCache cache, IMemoryCache memory) : IOperadorService, IDisposable
{
    private readonly IHttpContextAccessor _httpContextAccessor = httpContextAccessor;
    private readonly IOptions<AppSettings> _appSettings = appSettings;
    private readonly HybridCache _cache = cache;
    private readonly IMemoryCache _memoryCache = memory;
    private bool _disposed;
    private readonly IFOperadorFactory operadorFactory = operadorFactory;
    private readonly IOperadorReader reader = reader;
    private readonly IOperadorValidation validation = validation;
    private readonly IOperadorWriter writer = writer;
    private readonly IStatusBiuReader statusbiuReader = statusbiuReader;
    private readonly IAgendaService agendaService = agendaService;
    private readonly IAgendaFinanceiroService agendafinanceiroService = agendafinanceiroService;
    private readonly IAlarmSMSService alarmsmsService = alarmsmsService;
    private readonly IAlertasService alertasService = alertasService;
    private readonly IAlertasEnviadosService alertasenviadosService = alertasenviadosService;
    private readonly IContatoCRMService contatocrmService = contatocrmService;
    private readonly IContatoCRMOperadorService contatocrmoperadorService = contatocrmoperadorService;
    private readonly IDiario2Service diario2Service = diario2Service;
    private readonly IGUTAtividadesService gutatividadesService = gutatividadesService;
    private readonly IOperadorEMailPopupService operadoremailpopupService = operadoremailpopupService;
    private readonly IOperadorGrupoService operadorgrupoService = operadorgrupoService;
    private readonly IOperadorGruposAgendaService operadorgruposagendaService = operadorgruposagendaService;
    private readonly IOperadorGruposAgendaOperadoresService operadorgruposagendaoperadoresService = operadorgruposagendaoperadoresService;
    private readonly IPontoVirtualService pontovirtualService = pontovirtualService;
    private readonly IPontoVirtualAcessosService pontovirtualacessosService = pontovirtualacessosService;
    private readonly IProcessosParadosService processosparadosService = processosparadosService;
    private readonly IProcessOutputRequestService processoutputrequestService = processoutputrequestService;
    private readonly IReuniaoPessoasService reuniaopessoasService = reuniaopessoasService;
    private readonly ISMSAliceService smsaliceService = smsaliceService;
    private readonly IStatusBiuService statusbiuService = statusbiuService;
    public async Task<IEnumerable<OperadorResponseAll>> GetAll(int max, [FromRoute, Required] string uri, CancellationToken token = default)
    {
        max = Math.Min(Math.Max(max, 1), BaseConsts.PMaxItens);
        ThrowIfDisposed();
        if (!Uris.ValidaUri(uri, _appSettings))
        {
            throw new Exception("Operador: URI inválida");
        }

        var entryOptions = new HybridCacheEntryOptions
        {
            Expiration = TimeSpan.FromMinutes(BaseConsts.PMaxMinutesCache),
            LocalCacheExpiration = TimeSpan.FromMinutes(BaseConsts.PMaxMinutesCache)
        };
        using var oCnn = Configuracoes.GetConnectionByUri(uri);
        var keyCache = await reader.ReadStringAuditor(uri, "", [], oCnn);
        var cacheKey = $"{uri}-Operador-Filter-{keyCache}";
        var result = await _cache.GetOrCreateAsync(cacheKey, async cancel => await GetDataAllAsync(max, string.Empty, [], uri, cancel), entryOptions, cancellationToken: token);
        return result;
    }

    public async Task<IEnumerable<OperadorResponseAll>> Filter(Filters.FilterOperador filtro, [FromRoute, Required] string uri)
    {
        ThrowIfDisposed();
        using var oCnn = Configuracoes.GetConnectionByUri(uri);
        if (oCnn == null)
        {
            throw new DatabaseConnectionException();
        }

        var filtroResult = filtro == null ? null : WFiltro(filtro!);
        string where = filtroResult?.where ?? string.Empty;
        List<SqlParameter> parameters = filtroResult?.parametros ?? [];
        var keyCache = await reader.ReadStringAuditor(uri, where, parameters, oCnn);
        var cacheKey = $"{uri}-Operador-Filter-{where.GetHashCode()}{parameters.GetHashCode()}{keyCache}";
        var entryOptions = new HybridCacheEntryOptions
        {
            Expiration = TimeSpan.FromSeconds(BaseConsts.PMaxGetListSecondsCacheId),
            LocalCacheExpiration = TimeSpan.FromSeconds(BaseConsts.PMaxGetListSecondsCacheId)
        };
        var result = await _cache.GetOrCreateAsync(cacheKey, async cancel => await GetDataAllAsync(BaseConsts.PMaxItens, string.IsNullOrEmpty(where) ? string.Empty : TSql.Where + where, parameters, uri, cancel), entryOptions, cancellationToken: new());
        return result;
    }

    public async Task<OperadorResponse?> GetById([FromQuery] int id, [FromRoute, Required] string uri, CancellationToken token)
    {
        ThrowIfDisposed();
        if (id < 1)
        {
            return new OperadorResponse();
        }

        var entryOptions = new HybridCacheEntryOptions
        {
            Expiration = TimeSpan.FromSeconds(BaseConsts.PMaxSecondsCacheId),
            LocalCacheExpiration = TimeSpan.FromSeconds(BaseConsts.PMaxSecondsCacheId)
        };
        using var oCnn = Configuracoes.GetConnectionByUri(uri);
        try
        {
            var keyCache = await reader.ReadStringAuditor(id, uri, oCnn);
            var result = await _cache.GetOrCreateAsync($"{uri}-Operador-GetById-{id}-{keyCache}", async cancel => await GetDataByIdAsync(id, oCnn, cancel), entryOptions, cancellationToken: token);
            return result;
        }
        catch (Exception)
        {
            throw new Exception($"Operador - {uri}-: GetById");
        }
    }

    private async Task<OperadorResponse?> GetDataByIdAsync(int id, MsiSqlConnection oCnn, CancellationToken token) => await reader.Read(id, oCnn);
    public async Task<OperadorResponse?> AddAndUpdate([FromBody] Models.Operador regOperador, [FromRoute, Required] string uri)
    {
        ThrowIfDisposed();
        if (!Uris.ValidaUri(uri, _appSettings))
        {
            throw new Exception("Operador: URI inválida");
        }

        if (regOperador == null)
        {
            return null;
        }

        using var oCnn = Configuracoes.GetConnectionByUriRw(uri);
        if (oCnn == null)
        {
            return null;
        }

        try
        {
            var validade = await validation.ValidateReg(regOperador, this, statusbiuReader, uri, oCnn);
            if (!validade)
            {
                throw new Exception("Erro inesperado ao vaidadar 0x0!");
            }
        }
        catch (SGValidationException ex)
        {
            throw new Exception(ex.Message);
        }
        catch (Exception)
        {
            throw new Exception("Erro inesperado ao vaidadar 0x1!");
        }

        int operadorId = UserTools.GetAuthenticatedUserId(_httpContextAccessor);
        using var saved = await writer.WriteAsync(regOperador, operadorId, oCnn);
        return reader.Read(saved, oCnn);
    }

    public async Task<OperadorResponse?> Validation([FromBody] Models.Operador regOperador, [FromRoute, Required] string uri)
    {
        ThrowIfDisposed();
        if (!Uris.ValidaUri(uri, _appSettings))
        {
            throw new Exception("Operador: URI inválida");
        }

        if (regOperador == null)
        {
            return null;
        }

        using var oCnn = Configuracoes.GetConnectionByUriRw(uri);
        if (oCnn == null)
        {
            return null;
        }

        try
        {
            var validade = await validation.ValidateReg(regOperador, this, statusbiuReader, uri, oCnn);
            if (!validade)
            {
                throw new Exception("Erro inesperado ao vaidadar 0x0!");
            }
        }
        catch (SGValidationException ex)
        {
            throw new Exception(ex.Message);
        }
        catch (Exception)
        {
            throw new Exception("Erro inesperado ao vaidadar 0x1!");
        }

        if (regOperador.Id.IsEmptyIDNumber())
        {
            return new OperadorResponse();
        }

        return await reader.Read(regOperador.Id, oCnn);
    }

    public async Task<OperadorResponse?> Delete([FromQuery] int id, [FromRoute, Required] string uri)
    {
        ThrowIfDisposed();
        if (!Uris.ValidaUri(uri, _appSettings))
        {
            throw new Exception("Operador: URI inválida");
        }

        if (id.IsEmptyIDNumber())
        {
            return null;
        }

        var nOperador = UserTools.GetAuthenticatedUserId(_httpContextAccessor);
        if (id == nOperador)
        {
            throw new Exception("Você não pode excluir a si mesmo.");
        }

        using var oCnn = Configuracoes.GetConnectionByUriRw(uri);
        if (oCnn == null)
        {
            return null;
        }

        var currentOperador = await reader.Read(UserTools.GetAuthenticatedUserId(_httpContextAccessor), oCnn) ?? throw new Exception("Operador atual não encontrado.");
        if (!currentOperador.Situacao || !currentOperador.Master)
        {
            throw new Exception("Você não tem privilégios para excluir operador.");
        }

        try
        {
            var deleteValidation = await validation.CanDelete(id, this, agendaService, agendafinanceiroService, alarmsmsService, alertasService, alertasenviadosService, contatocrmService, contatocrmoperadorService, diario2Service, gutatividadesService, operadoremailpopupService, operadorgrupoService, operadorgruposagendaService, operadorgruposagendaoperadoresService, pontovirtualService, pontovirtualacessosService, processosparadosService, processoutputrequestService, reuniaopessoasService, smsaliceService, statusbiuService, uri, oCnn);
            if (!deleteValidation)
            {
                throw new Exception("Erro inesperado ao vaidadar 0x0!");
            }
        }
        catch (SGValidationException ex)
        {
            throw new Exception(ex.Message);
        }
        catch (Exception)
        {
            throw new Exception("Erro inesperado ao vaidadar 0x1!");
        }

        var operador = await reader.Read(id, oCnn);
        try
        {
            if (operador != null)
            {
                var operWrite = await reader.ReadM(id, oCnn);
                if (operWrite == null)
                {
                    throw new Exception("Operador não encontrado para exclusão.");
                }

                operWrite.Situacao = false;
                operWrite.Excluido = true;
                using var saved = await writer.WriteAsync(operWrite, nOperador, oCnn);
                return operador;
            }
        }
        catch (Exception ex)
        {
            throw new Exception(ex.Message);
        }

        return operador;
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    protected virtual void Dispose(bool disposing)
    {
        if (_disposed)
            return;
        if (disposing)
        {
        //_cache?.Dispose();
        }

        _disposed = true;
    }

    private void ThrowIfDisposed()
    {
        if (_disposed)
        {
            throw new ObjectDisposedException(GetType().Name);
        }
    }
}