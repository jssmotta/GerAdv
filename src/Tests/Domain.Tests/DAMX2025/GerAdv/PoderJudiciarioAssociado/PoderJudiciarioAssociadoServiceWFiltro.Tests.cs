// 100% auto-generated by Source Genesys WebApi Front & Back Creator
// copyright © 2000-2025 Menphis - Sistemas Inteligentes
// This file is part of the Source Genesys project                     
namespace MenphisSI.GerAdv.WFiltro.Tests
{
    public class PoderJudiciarioAssociadoServiceWFiltroTests : IDisposable
    {
        private readonly Mock<IOptions<AppSettings>> _mockAppSettings;
        private readonly Mock<IFPoderJudiciarioAssociadoFactory> _mockPoderJudiciarioAssociadoFactory;
        private readonly Mock<IPoderJudiciarioAssociadoReader> _mockReader;
        private readonly Mock<IPoderJudiciarioAssociadoValidation> _mockValidation;
        private readonly Mock<IPoderJudiciarioAssociadoWriter> _mockWriter;
        private readonly Mock<IJusticaReader> _mockJusticaReader;
        private readonly Mock<IAreaReader> _mockAreaReader;
        private readonly Mock<ITribunalReader> _mockTribunalReader;
        private readonly Mock<IForoReader> _mockForoReader;
        private readonly Mock<ICidadeReader> _mockCidadeReader;
        private readonly Mock<IHttpContextAccessor> _mockHttpContextAccessor;
        private readonly Mock<HybridCache> _mockCache;
        private readonly Mock<IMemoryCache> _mockMemoryCache;
        private readonly PoderJudiciarioAssociadoService _service;
        public PoderJudiciarioAssociadoServiceWFiltroTests()
        {
            _mockAppSettings = new Mock<IOptions<AppSettings>>();
            _mockPoderJudiciarioAssociadoFactory = new Mock<IFPoderJudiciarioAssociadoFactory>();
            _mockReader = new Mock<IPoderJudiciarioAssociadoReader>();
            _mockValidation = new Mock<IPoderJudiciarioAssociadoValidation>();
            _mockWriter = new Mock<IPoderJudiciarioAssociadoWriter>();
            _mockJusticaReader = new Mock<IJusticaReader>();
            _mockAreaReader = new Mock<IAreaReader>();
            _mockTribunalReader = new Mock<ITribunalReader>();
            _mockForoReader = new Mock<IForoReader>();
            _mockCidadeReader = new Mock<ICidadeReader>();
            _mockHttpContextAccessor = new Mock<IHttpContextAccessor>();
            _mockCache = new Mock<HybridCache>();
            _mockMemoryCache = new Mock<IMemoryCache>();
            var appSettings = new AppSettings();
            _mockAppSettings.Setup(x => x.Value).Returns(appSettings);
            _service = new PoderJudiciarioAssociadoService(_mockAppSettings.Object, _mockPoderJudiciarioAssociadoFactory.Object, _mockReader.Object, _mockValidation.Object, _mockWriter.Object, _mockJusticaReader.Object, _mockAreaReader.Object, _mockTribunalReader.Object, _mockForoReader.Object, _mockCidadeReader.Object, _mockHttpContextAccessor.Object, _mockCache.Object, _mockMemoryCache.Object);
        }

        [Fact]
        public void WFiltro_QuandoFiltroEhNull_DeveRetornarResultadoVazio()
        {
            // Arrange
            FilterPoderJudiciarioAssociado? filtro = null;
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().BeNull();
        }

        [Fact]
        public void WFiltro_QuandoTodosCamposSaoValoresPadrao_DeveRetornarResultadoVazio()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado(); // Todos os valores padrão
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_ComTodosOsCamposPreenchidos_DeveProcessarRapidamente()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica = 1,
                JusticaNome = "João",
                Area = 1,
                AreaNome = "João",
                Tribunal = 1,
                TribunalNome = "João",
                Foro = 1,
                ForoNome = "João",
                Cidade = 1,
                SubDivisaoNome = "João",
                CidadeNome = "João",
                SubDivisao = 1,
                Tipo = 1,
                GUID = Guid.NewGuid().ToString(),
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var stopwatch = System.Diagnostics.Stopwatch.StartNew();
            var resultado = _service.WFiltro(filtro);
            stopwatch.Stop();
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().NotBeEmpty();
            resultado.Value.where.Should().NotBeEmpty();
            stopwatch.ElapsedMilliseconds.Should().BeLessThan(100); // Deve processar em menos de 100ms
        }

#region String Tests
        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_JusticaNome_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string justicanomeComWhitespace)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                JusticaNome = justicanomeComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_JusticaNome_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var justicanomeGigante = new string ('A', 1000);
            var filtro = new FilterPoderJudiciarioAssociado
            {
                JusticaNome = justicanomeGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{justicanomeGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_JusticaNome_ComCaracteresEspeciais_DeveProcessarCorretamente(string justicanomeComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                JusticaNome = justicanomeComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(justicanomeComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_JusticaNomePoderJudiciarioAssociado_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                JusticaNome = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_JusticaNomePoderJudiciarioAssociado_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                JusticaNome = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_JusticaNomePoderJudiciarioAssociado_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomePoderJudiciarioAssociado = "João Silva";
            var filtro = new FilterPoderJudiciarioAssociado
            {
                JusticaNome = nomePoderJudiciarioAssociado,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_JusticaNomePoderJudiciarioAssociado_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                JusticaNome = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_JusticaNomePoderJudiciarioAssociado_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                JusticaNome = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_JusticaNomePoderJudiciarioAssociado_StringsVazias_NaoDeveIncluirNoFiltro(string? nomePoderJudiciarioAssociado)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                JusticaNome = nomePoderJudiciarioAssociado,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_JusticaNomePoderJudiciarioAssociado_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                JusticaNome = "João",
                Area = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@pjaJusticaNome");
            resultado.Value.where.Should().Contain("@pjaArea");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @pjaJusticaNome");
            resultado.Value.where.Should().Contain("= @pjaArea");
        }

        [Fact]
        public void WFiltro_JusticaNomePoderJudiciarioAssociado_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomePoderJudiciarioAssociado = "João Silva";
            var filtro = new FilterPoderJudiciarioAssociado
            {
                JusticaNome = nomePoderJudiciarioAssociado,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.JusticaNome}]");
            resultado.Value.where.Should().Contain("like @pjaJusticaNome");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@pjaJusticaNome");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_AreaNome_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string areanomeComWhitespace)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                AreaNome = areanomeComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_AreaNome_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var areanomeGigante = new string ('A', 1000);
            var filtro = new FilterPoderJudiciarioAssociado
            {
                AreaNome = areanomeGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{areanomeGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_AreaNome_ComCaracteresEspeciais_DeveProcessarCorretamente(string areanomeComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                AreaNome = areanomeComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(areanomeComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_AreaNomePoderJudiciarioAssociado_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                AreaNome = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_AreaNomePoderJudiciarioAssociado_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                AreaNome = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_AreaNomePoderJudiciarioAssociado_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomePoderJudiciarioAssociado = "João Silva";
            var filtro = new FilterPoderJudiciarioAssociado
            {
                AreaNome = nomePoderJudiciarioAssociado,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_AreaNomePoderJudiciarioAssociado_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                AreaNome = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_AreaNomePoderJudiciarioAssociado_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                AreaNome = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_AreaNomePoderJudiciarioAssociado_StringsVazias_NaoDeveIncluirNoFiltro(string? nomePoderJudiciarioAssociado)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                AreaNome = nomePoderJudiciarioAssociado,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_AreaNomePoderJudiciarioAssociado_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                AreaNome = "João",
                Area = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@pjaAreaNome");
            resultado.Value.where.Should().Contain("@pjaArea");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @pjaAreaNome");
            resultado.Value.where.Should().Contain("= @pjaArea");
        }

        [Fact]
        public void WFiltro_AreaNomePoderJudiciarioAssociado_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomePoderJudiciarioAssociado = "João Silva";
            var filtro = new FilterPoderJudiciarioAssociado
            {
                AreaNome = nomePoderJudiciarioAssociado,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.AreaNome}]");
            resultado.Value.where.Should().Contain("like @pjaAreaNome");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@pjaAreaNome");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_TribunalNome_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string tribunalnomeComWhitespace)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                TribunalNome = tribunalnomeComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_TribunalNome_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var tribunalnomeGigante = new string ('A', 1000);
            var filtro = new FilterPoderJudiciarioAssociado
            {
                TribunalNome = tribunalnomeGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{tribunalnomeGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_TribunalNome_ComCaracteresEspeciais_DeveProcessarCorretamente(string tribunalnomeComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                TribunalNome = tribunalnomeComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(tribunalnomeComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_TribunalNomePoderJudiciarioAssociado_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                TribunalNome = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_TribunalNomePoderJudiciarioAssociado_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                TribunalNome = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_TribunalNomePoderJudiciarioAssociado_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomePoderJudiciarioAssociado = "João Silva";
            var filtro = new FilterPoderJudiciarioAssociado
            {
                TribunalNome = nomePoderJudiciarioAssociado,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_TribunalNomePoderJudiciarioAssociado_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                TribunalNome = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_TribunalNomePoderJudiciarioAssociado_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                TribunalNome = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_TribunalNomePoderJudiciarioAssociado_StringsVazias_NaoDeveIncluirNoFiltro(string? nomePoderJudiciarioAssociado)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                TribunalNome = nomePoderJudiciarioAssociado,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_TribunalNomePoderJudiciarioAssociado_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                TribunalNome = "João",
                Area = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@pjaTribunalNome");
            resultado.Value.where.Should().Contain("@pjaArea");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @pjaTribunalNome");
            resultado.Value.where.Should().Contain("= @pjaArea");
        }

        [Fact]
        public void WFiltro_TribunalNomePoderJudiciarioAssociado_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomePoderJudiciarioAssociado = "João Silva";
            var filtro = new FilterPoderJudiciarioAssociado
            {
                TribunalNome = nomePoderJudiciarioAssociado,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.TribunalNome}]");
            resultado.Value.where.Should().Contain("like @pjaTribunalNome");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@pjaTribunalNome");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_ForoNome_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string foronomeComWhitespace)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                ForoNome = foronomeComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_ForoNome_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var foronomeGigante = new string ('A', 1000);
            var filtro = new FilterPoderJudiciarioAssociado
            {
                ForoNome = foronomeGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{foronomeGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_ForoNome_ComCaracteresEspeciais_DeveProcessarCorretamente(string foronomeComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                ForoNome = foronomeComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(foronomeComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_ForoNomePoderJudiciarioAssociado_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                ForoNome = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_ForoNomePoderJudiciarioAssociado_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                ForoNome = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_ForoNomePoderJudiciarioAssociado_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomePoderJudiciarioAssociado = "João Silva";
            var filtro = new FilterPoderJudiciarioAssociado
            {
                ForoNome = nomePoderJudiciarioAssociado,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_ForoNomePoderJudiciarioAssociado_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                ForoNome = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_ForoNomePoderJudiciarioAssociado_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                ForoNome = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_ForoNomePoderJudiciarioAssociado_StringsVazias_NaoDeveIncluirNoFiltro(string? nomePoderJudiciarioAssociado)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                ForoNome = nomePoderJudiciarioAssociado,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_ForoNomePoderJudiciarioAssociado_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                ForoNome = "João",
                Area = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@pjaForoNome");
            resultado.Value.where.Should().Contain("@pjaArea");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @pjaForoNome");
            resultado.Value.where.Should().Contain("= @pjaArea");
        }

        [Fact]
        public void WFiltro_ForoNomePoderJudiciarioAssociado_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomePoderJudiciarioAssociado = "João Silva";
            var filtro = new FilterPoderJudiciarioAssociado
            {
                ForoNome = nomePoderJudiciarioAssociado,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.ForoNome}]");
            resultado.Value.where.Should().Contain("like @pjaForoNome");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@pjaForoNome");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_SubDivisaoNome_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string subdivisaonomeComWhitespace)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisaoNome = subdivisaonomeComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_SubDivisaoNome_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var subdivisaonomeGigante = new string ('A', 1000);
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisaoNome = subdivisaonomeGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{subdivisaonomeGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_SubDivisaoNome_ComCaracteresEspeciais_DeveProcessarCorretamente(string subdivisaonomeComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisaoNome = subdivisaonomeComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(subdivisaonomeComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_SubDivisaoNomePoderJudiciarioAssociado_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisaoNome = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_SubDivisaoNomePoderJudiciarioAssociado_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisaoNome = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_SubDivisaoNomePoderJudiciarioAssociado_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomePoderJudiciarioAssociado = "João Silva";
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisaoNome = nomePoderJudiciarioAssociado,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_SubDivisaoNomePoderJudiciarioAssociado_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisaoNome = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_SubDivisaoNomePoderJudiciarioAssociado_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisaoNome = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_SubDivisaoNomePoderJudiciarioAssociado_StringsVazias_NaoDeveIncluirNoFiltro(string? nomePoderJudiciarioAssociado)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisaoNome = nomePoderJudiciarioAssociado,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_SubDivisaoNomePoderJudiciarioAssociado_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisaoNome = "João",
                Area = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@pjaSubDivisaoNome");
            resultado.Value.where.Should().Contain("@pjaArea");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @pjaSubDivisaoNome");
            resultado.Value.where.Should().Contain("= @pjaArea");
        }

        [Fact]
        public void WFiltro_SubDivisaoNomePoderJudiciarioAssociado_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomePoderJudiciarioAssociado = "João Silva";
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisaoNome = nomePoderJudiciarioAssociado,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.SubDivisaoNome}]");
            resultado.Value.where.Should().Contain("like @pjaSubDivisaoNome");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@pjaSubDivisaoNome");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_CidadeNome_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string cidadenomeComWhitespace)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                CidadeNome = cidadenomeComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_CidadeNome_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var cidadenomeGigante = new string ('A', 1000);
            var filtro = new FilterPoderJudiciarioAssociado
            {
                CidadeNome = cidadenomeGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{cidadenomeGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_CidadeNome_ComCaracteresEspeciais_DeveProcessarCorretamente(string cidadenomeComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                CidadeNome = cidadenomeComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(cidadenomeComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_CidadeNomePoderJudiciarioAssociado_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                CidadeNome = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_CidadeNomePoderJudiciarioAssociado_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                CidadeNome = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_CidadeNomePoderJudiciarioAssociado_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomePoderJudiciarioAssociado = "João Silva";
            var filtro = new FilterPoderJudiciarioAssociado
            {
                CidadeNome = nomePoderJudiciarioAssociado,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_CidadeNomePoderJudiciarioAssociado_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                CidadeNome = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_CidadeNomePoderJudiciarioAssociado_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                CidadeNome = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_CidadeNomePoderJudiciarioAssociado_StringsVazias_NaoDeveIncluirNoFiltro(string? nomePoderJudiciarioAssociado)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                CidadeNome = nomePoderJudiciarioAssociado,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_CidadeNomePoderJudiciarioAssociado_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                CidadeNome = "João",
                Area = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@pjaCidadeNome");
            resultado.Value.where.Should().Contain("@pjaArea");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @pjaCidadeNome");
            resultado.Value.where.Should().Contain("= @pjaArea");
        }

        [Fact]
        public void WFiltro_CidadeNomePoderJudiciarioAssociado_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomePoderJudiciarioAssociado = "João Silva";
            var filtro = new FilterPoderJudiciarioAssociado
            {
                CidadeNome = nomePoderJudiciarioAssociado,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.CidadeNome}]");
            resultado.Value.where.Should().Contain("like @pjaCidadeNome");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@pjaCidadeNome");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_GUID_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string guidComWhitespace)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                GUID = guidComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_GUID_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var guidGigante = new string ('A', 1000);
            var filtro = new FilterPoderJudiciarioAssociado
            {
                GUID = guidGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{guidGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_GUID_ComCaracteresEspeciais_DeveProcessarCorretamente(string guidComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                GUID = guidComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(guidComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_GUIDPoderJudiciarioAssociado_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                GUID = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_GUIDPoderJudiciarioAssociado_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                GUID = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_GUIDPoderJudiciarioAssociado_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomePoderJudiciarioAssociado = "João Silva";
            var filtro = new FilterPoderJudiciarioAssociado
            {
                GUID = nomePoderJudiciarioAssociado,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_GUIDPoderJudiciarioAssociado_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                GUID = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_GUIDPoderJudiciarioAssociado_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                GUID = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_GUIDPoderJudiciarioAssociado_StringsVazias_NaoDeveIncluirNoFiltro(string? nomePoderJudiciarioAssociado)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                GUID = nomePoderJudiciarioAssociado,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_GUIDPoderJudiciarioAssociado_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                GUID = "João",
                Area = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@pjaGUID");
            resultado.Value.where.Should().Contain("@pjaArea");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @pjaGUID");
            resultado.Value.where.Should().Contain("= @pjaArea");
        }

        [Fact]
        public void WFiltro_GUIDPoderJudiciarioAssociado_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomePoderJudiciarioAssociado = "João Silva";
            var filtro = new FilterPoderJudiciarioAssociado
            {
                GUID = nomePoderJudiciarioAssociado,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.GUID}]");
            resultado.Value.where.Should().Contain("like @pjaGUID");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@pjaGUID");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

#endregion
#region Integer Tests
#region filtro.Justica_end Tests
        [Fact]
        public void WFiltro_Justica_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Justica_end_QuandoTemValorPositivo_SemJusticaInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorJusticaEnd = 5000;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica = int.MinValue, // Não define salário inicial
                Justica_end = valorJusticaEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Justica inicial válido, não deve incluir condição WHERE, mas o parâmetro Justica_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Justica_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Justica_end_QuandoSomenteValorInicial_SemJusticaEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorJustica = 2500;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica = valorJustica,
                Justica_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.Justica}] = @{DBPoderJudiciarioAssociadoDicInfo.Justica}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBPoderJudiciarioAssociadoDicInfo.Justica}");
            parametro.Value.Should().Be(valorJustica);
        }

        [Fact]
        public void WFiltro_Justica_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorJusticaInicial = 1000;
            var valorJusticaFinal = 5000;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica = valorJusticaInicial,
                Justica_end = valorJusticaFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].{DBPoderJudiciarioAssociadoDicInfo.Justica} BETWEEN @{DBPoderJudiciarioAssociadoDicInfo.Justica} AND @{DBPoderJudiciarioAssociadoDicInfo.Justica}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Justica}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Justica}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorJusticaInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorJusticaFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Justica_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica = valorInicial,
                Justica_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Justica}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Justica}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Justica_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica = 1000,
                Justica_end = 5000,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.Justica}");
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.JusticaNome}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Justica_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica = 1000,
                Justica_end = 5000,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Justica_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica = 1000,
                Justica_end = 5000,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Justica_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica = 1000,
                Justica_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].{DBPoderJudiciarioAssociadoDicInfo.Justica} BETWEEN");
        }

        [Fact]
        public void WFiltro_Justica_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica = 1000,
                Justica_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Justica_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica = 1000,
                Justica_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Justica_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorJusticaInicial = 2500;
            var valorJusticaFinal = 4750;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica = valorJusticaInicial,
                Justica_end = valorJusticaFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Justica}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Justica}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorJusticaInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorJusticaFinal);
        }

        [Fact]
        public void WFiltro_Justica_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica = 0,
                Justica_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Justica_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica = 0,
                Justica_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Justica_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica = 1500,
                Justica_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Justica == int.MinValue) && !(filtro.Justica_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].{DBPoderJudiciarioAssociadoDicInfo.Justica} BETWEEN @{DBPoderJudiciarioAssociadoDicInfo.Justica} AND @{DBPoderJudiciarioAssociadoDicInfo.Justica}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Justica_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica = 2000,
                Justica_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Justica == int.MinValue) && filtro.Justica_end == int.MinValue
            // Deve resultar em igualdade quando apenas Justica tem valor válido
            resultado.Value.where.Should().Be($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.Justica}] = @{DBPoderJudiciarioAssociadoDicInfo.Justica}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Justica_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Justica Isolated Tests
        [Fact]
        public void WFiltro_Justica_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Justica_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorJustica = 5;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica = valorJustica,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.Justica}] = @{DBPoderJudiciarioAssociadoDicInfo.Justica}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBPoderJudiciarioAssociadoDicInfo.Justica}");
            parametro.Value.Should().Be(valorJustica);
        }

        [Fact]
        public void WFiltro_Justica_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorJustica = 0;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica = valorJustica,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBPoderJudiciarioAssociadoDicInfo.Justica}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorJustica);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Justica_DiferentesValoresValidos_DeveProcessarCorretamente(int valorJustica)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica = valorJustica,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorJustica);
            resultado.Value.where.Should().Contain($"= @{DBPoderJudiciarioAssociadoDicInfo.Justica}");
        }

        [Fact]
        public void WFiltro_Justica_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.Justica}");
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.JusticaNome}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Justica_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Justica_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Justica_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Justica_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.Justica}]");
        }

        [Fact]
        public void WFiltro_Justica_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Justica_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Justica_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Justica_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorJustica = 42;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica = valorJustica,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorJustica);
        }

#endregion
        [Fact]
        public void WFiltro_Justica_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Justica_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorJustica = 1;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica = valorJustica,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Justica
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.Justica}] = @pjaJustica");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@pjaJustica");
            parametro.Value.Should().Be(valorJustica);
        }

        [Fact]
        public void WFiltro_Justica_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@pjaJustica");
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.JusticaNome}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Justica_DiferentesValores_DeveFuncionar(int valorJustica)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Justica = valorJustica,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorJustica);
        }

#region filtro.Area_end Tests
        [Fact]
        public void WFiltro_Area_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Area_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Area_end_QuandoTemValorPositivo_SemAreaInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorAreaEnd = 5000;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Area = int.MinValue, // Não define salário inicial
                Area_end = valorAreaEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Area inicial válido, não deve incluir condição WHERE, mas o parâmetro Area_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Area_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Area_end_QuandoSomenteValorInicial_SemAreaEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorArea = 2500;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Area = valorArea,
                Area_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.Area}] = @{DBPoderJudiciarioAssociadoDicInfo.Area}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBPoderJudiciarioAssociadoDicInfo.Area}");
            parametro.Value.Should().Be(valorArea);
        }

        [Fact]
        public void WFiltro_Area_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorAreaInicial = 1000;
            var valorAreaFinal = 5000;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Area = valorAreaInicial,
                Area_end = valorAreaFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].{DBPoderJudiciarioAssociadoDicInfo.Area} BETWEEN @{DBPoderJudiciarioAssociadoDicInfo.Area} AND @{DBPoderJudiciarioAssociadoDicInfo.Area}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Area}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Area}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorAreaInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorAreaFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Area_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Area = valorInicial,
                Area_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Area}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Area}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Area_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Area = 1000,
                Area_end = 5000,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.Area}");
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.JusticaNome}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Area_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Area = 1000,
                Area_end = 5000,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Area_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Area = 1000,
                Area_end = 5000,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Area_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Area = 1000,
                Area_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].{DBPoderJudiciarioAssociadoDicInfo.Area} BETWEEN");
        }

        [Fact]
        public void WFiltro_Area_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Area = 1000,
                Area_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Area_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Area = 1000,
                Area_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Area_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorAreaInicial = 2500;
            var valorAreaFinal = 4750;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Area = valorAreaInicial,
                Area_end = valorAreaFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Area}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Area}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorAreaInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorAreaFinal);
        }

        [Fact]
        public void WFiltro_Area_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Area = 0,
                Area_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Area_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Area = 0,
                Area_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Area_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Area = 1500,
                Area_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Area == int.MinValue) && !(filtro.Area_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].{DBPoderJudiciarioAssociadoDicInfo.Area} BETWEEN @{DBPoderJudiciarioAssociadoDicInfo.Area} AND @{DBPoderJudiciarioAssociadoDicInfo.Area}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Area_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Area = 2000,
                Area_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Area == int.MinValue) && filtro.Area_end == int.MinValue
            // Deve resultar em igualdade quando apenas Area tem valor válido
            resultado.Value.where.Should().Be($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.Area}] = @{DBPoderJudiciarioAssociadoDicInfo.Area}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Area_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Area = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Area Isolated Tests
        [Fact]
        public void WFiltro_Area_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Area = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Area_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorArea = 5;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Area = valorArea,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.Area}] = @{DBPoderJudiciarioAssociadoDicInfo.Area}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBPoderJudiciarioAssociadoDicInfo.Area}");
            parametro.Value.Should().Be(valorArea);
        }

        [Fact]
        public void WFiltro_Area_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorArea = 0;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Area = valorArea,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBPoderJudiciarioAssociadoDicInfo.Area}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorArea);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Area_DiferentesValoresValidos_DeveProcessarCorretamente(int valorArea)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Area = valorArea,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorArea);
            resultado.Value.where.Should().Contain($"= @{DBPoderJudiciarioAssociadoDicInfo.Area}");
        }

        [Fact]
        public void WFiltro_Area_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Area = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.Area}");
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.JusticaNome}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Area_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Area = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Area_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Area = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Area_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Area = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Area_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Area = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.Area}]");
        }

        [Fact]
        public void WFiltro_Area_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Area = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Area_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Area = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Area_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Area = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Area_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorArea = 42;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Area = valorArea,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorArea);
        }

#endregion
        [Fact]
        public void WFiltro_Area_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Area = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Area_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorArea = 1;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Area = valorArea,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Area
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.Area}] = @pjaArea");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@pjaArea");
            parametro.Value.Should().Be(valorArea);
        }

        [Fact]
        public void WFiltro_Area_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Area = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@pjaArea");
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.JusticaNome}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Area_DiferentesValores_DeveFuncionar(int valorArea)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Area = valorArea,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorArea);
        }

#region filtro.Tribunal_end Tests
        [Fact]
        public void WFiltro_Tribunal_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tribunal_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Tribunal_end_QuandoTemValorPositivo_SemTribunalInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorTribunalEnd = 5000;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tribunal = int.MinValue, // Não define salário inicial
                Tribunal_end = valorTribunalEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Tribunal inicial válido, não deve incluir condição WHERE, mas o parâmetro Tribunal_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Tribunal_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Tribunal_end_QuandoSomenteValorInicial_SemTribunalEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorTribunal = 2500;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tribunal = valorTribunal,
                Tribunal_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.Tribunal}] = @{DBPoderJudiciarioAssociadoDicInfo.Tribunal}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBPoderJudiciarioAssociadoDicInfo.Tribunal}");
            parametro.Value.Should().Be(valorTribunal);
        }

        [Fact]
        public void WFiltro_Tribunal_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorTribunalInicial = 1000;
            var valorTribunalFinal = 5000;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tribunal = valorTribunalInicial,
                Tribunal_end = valorTribunalFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].{DBPoderJudiciarioAssociadoDicInfo.Tribunal} BETWEEN @{DBPoderJudiciarioAssociadoDicInfo.Tribunal} AND @{DBPoderJudiciarioAssociadoDicInfo.Tribunal}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Tribunal}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Tribunal}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorTribunalInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorTribunalFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Tribunal_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tribunal = valorInicial,
                Tribunal_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Tribunal}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Tribunal}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Tribunal_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tribunal = 1000,
                Tribunal_end = 5000,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.Tribunal}");
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.JusticaNome}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Tribunal_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tribunal = 1000,
                Tribunal_end = 5000,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Tribunal_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tribunal = 1000,
                Tribunal_end = 5000,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Tribunal_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tribunal = 1000,
                Tribunal_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].{DBPoderJudiciarioAssociadoDicInfo.Tribunal} BETWEEN");
        }

        [Fact]
        public void WFiltro_Tribunal_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tribunal = 1000,
                Tribunal_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Tribunal_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tribunal = 1000,
                Tribunal_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Tribunal_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorTribunalInicial = 2500;
            var valorTribunalFinal = 4750;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tribunal = valorTribunalInicial,
                Tribunal_end = valorTribunalFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Tribunal}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Tribunal}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorTribunalInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorTribunalFinal);
        }

        [Fact]
        public void WFiltro_Tribunal_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tribunal = 0,
                Tribunal_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Tribunal_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tribunal = 0,
                Tribunal_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Tribunal_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tribunal = 1500,
                Tribunal_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Tribunal == int.MinValue) && !(filtro.Tribunal_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].{DBPoderJudiciarioAssociadoDicInfo.Tribunal} BETWEEN @{DBPoderJudiciarioAssociadoDicInfo.Tribunal} AND @{DBPoderJudiciarioAssociadoDicInfo.Tribunal}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Tribunal_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tribunal = 2000,
                Tribunal_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Tribunal == int.MinValue) && filtro.Tribunal_end == int.MinValue
            // Deve resultar em igualdade quando apenas Tribunal tem valor válido
            resultado.Value.where.Should().Be($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.Tribunal}] = @{DBPoderJudiciarioAssociadoDicInfo.Tribunal}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Tribunal_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tribunal = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Tribunal Isolated Tests
        [Fact]
        public void WFiltro_Tribunal_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tribunal = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Tribunal_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorTribunal = 5;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tribunal = valorTribunal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.Tribunal}] = @{DBPoderJudiciarioAssociadoDicInfo.Tribunal}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBPoderJudiciarioAssociadoDicInfo.Tribunal}");
            parametro.Value.Should().Be(valorTribunal);
        }

        [Fact]
        public void WFiltro_Tribunal_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorTribunal = 0;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tribunal = valorTribunal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBPoderJudiciarioAssociadoDicInfo.Tribunal}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorTribunal);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Tribunal_DiferentesValoresValidos_DeveProcessarCorretamente(int valorTribunal)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tribunal = valorTribunal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorTribunal);
            resultado.Value.where.Should().Contain($"= @{DBPoderJudiciarioAssociadoDicInfo.Tribunal}");
        }

        [Fact]
        public void WFiltro_Tribunal_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tribunal = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.Tribunal}");
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.JusticaNome}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Tribunal_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tribunal = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Tribunal_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tribunal = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Tribunal_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tribunal = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Tribunal_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tribunal = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.Tribunal}]");
        }

        [Fact]
        public void WFiltro_Tribunal_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tribunal = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Tribunal_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tribunal = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Tribunal_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tribunal = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Tribunal_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorTribunal = 42;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tribunal = valorTribunal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorTribunal);
        }

#endregion
        [Fact]
        public void WFiltro_Tribunal_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tribunal = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Tribunal_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorTribunal = 1;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tribunal = valorTribunal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Tribunal
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.Tribunal}] = @pjaTribunal");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@pjaTribunal");
            parametro.Value.Should().Be(valorTribunal);
        }

        [Fact]
        public void WFiltro_Tribunal_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tribunal = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@pjaTribunal");
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.JusticaNome}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Tribunal_DiferentesValores_DeveFuncionar(int valorTribunal)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tribunal = valorTribunal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorTribunal);
        }

#region filtro.Foro_end Tests
        [Fact]
        public void WFiltro_Foro_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Foro_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Foro_end_QuandoTemValorPositivo_SemForoInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorForoEnd = 5000;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Foro = int.MinValue, // Não define salário inicial
                Foro_end = valorForoEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Foro inicial válido, não deve incluir condição WHERE, mas o parâmetro Foro_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Foro_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Foro_end_QuandoSomenteValorInicial_SemForoEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorForo = 2500;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Foro = valorForo,
                Foro_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.Foro}] = @{DBPoderJudiciarioAssociadoDicInfo.Foro}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBPoderJudiciarioAssociadoDicInfo.Foro}");
            parametro.Value.Should().Be(valorForo);
        }

        [Fact]
        public void WFiltro_Foro_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorForoInicial = 1000;
            var valorForoFinal = 5000;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Foro = valorForoInicial,
                Foro_end = valorForoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].{DBPoderJudiciarioAssociadoDicInfo.Foro} BETWEEN @{DBPoderJudiciarioAssociadoDicInfo.Foro} AND @{DBPoderJudiciarioAssociadoDicInfo.Foro}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Foro}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Foro}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorForoInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorForoFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Foro_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Foro = valorInicial,
                Foro_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Foro}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Foro}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Foro_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Foro = 1000,
                Foro_end = 5000,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.Foro}");
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.JusticaNome}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Foro_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Foro = 1000,
                Foro_end = 5000,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Foro_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Foro = 1000,
                Foro_end = 5000,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Foro_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Foro = 1000,
                Foro_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].{DBPoderJudiciarioAssociadoDicInfo.Foro} BETWEEN");
        }

        [Fact]
        public void WFiltro_Foro_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Foro = 1000,
                Foro_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Foro_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Foro = 1000,
                Foro_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Foro_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorForoInicial = 2500;
            var valorForoFinal = 4750;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Foro = valorForoInicial,
                Foro_end = valorForoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Foro}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Foro}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorForoInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorForoFinal);
        }

        [Fact]
        public void WFiltro_Foro_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Foro = 0,
                Foro_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Foro_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Foro = 0,
                Foro_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Foro_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Foro = 1500,
                Foro_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Foro == int.MinValue) && !(filtro.Foro_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].{DBPoderJudiciarioAssociadoDicInfo.Foro} BETWEEN @{DBPoderJudiciarioAssociadoDicInfo.Foro} AND @{DBPoderJudiciarioAssociadoDicInfo.Foro}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Foro_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Foro = 2000,
                Foro_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Foro == int.MinValue) && filtro.Foro_end == int.MinValue
            // Deve resultar em igualdade quando apenas Foro tem valor válido
            resultado.Value.where.Should().Be($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.Foro}] = @{DBPoderJudiciarioAssociadoDicInfo.Foro}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Foro_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Foro = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Foro Isolated Tests
        [Fact]
        public void WFiltro_Foro_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Foro = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Foro_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorForo = 5;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Foro = valorForo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.Foro}] = @{DBPoderJudiciarioAssociadoDicInfo.Foro}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBPoderJudiciarioAssociadoDicInfo.Foro}");
            parametro.Value.Should().Be(valorForo);
        }

        [Fact]
        public void WFiltro_Foro_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorForo = 0;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Foro = valorForo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBPoderJudiciarioAssociadoDicInfo.Foro}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorForo);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Foro_DiferentesValoresValidos_DeveProcessarCorretamente(int valorForo)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Foro = valorForo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorForo);
            resultado.Value.where.Should().Contain($"= @{DBPoderJudiciarioAssociadoDicInfo.Foro}");
        }

        [Fact]
        public void WFiltro_Foro_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Foro = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.Foro}");
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.JusticaNome}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Foro_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Foro = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Foro_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Foro = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Foro_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Foro = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Foro_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Foro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.Foro}]");
        }

        [Fact]
        public void WFiltro_Foro_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Foro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Foro_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Foro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Foro_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Foro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Foro_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorForo = 42;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Foro = valorForo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorForo);
        }

#endregion
        [Fact]
        public void WFiltro_Foro_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Foro = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Foro_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorForo = 1;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Foro = valorForo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Foro
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.Foro}] = @pjaForo");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@pjaForo");
            parametro.Value.Should().Be(valorForo);
        }

        [Fact]
        public void WFiltro_Foro_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Foro = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@pjaForo");
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.JusticaNome}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Foro_DiferentesValores_DeveFuncionar(int valorForo)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Foro = valorForo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorForo);
        }

#region filtro.Cidade_end Tests
        [Fact]
        public void WFiltro_Cidade_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Cidade_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Cidade_end_QuandoTemValorPositivo_SemCidadeInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorCidadeEnd = 5000;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Cidade = int.MinValue, // Não define salário inicial
                Cidade_end = valorCidadeEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Cidade inicial válido, não deve incluir condição WHERE, mas o parâmetro Cidade_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Cidade_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Cidade_end_QuandoSomenteValorInicial_SemCidadeEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorCidade = 2500;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Cidade = valorCidade,
                Cidade_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.Cidade}] = @{DBPoderJudiciarioAssociadoDicInfo.Cidade}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBPoderJudiciarioAssociadoDicInfo.Cidade}");
            parametro.Value.Should().Be(valorCidade);
        }

        [Fact]
        public void WFiltro_Cidade_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorCidadeInicial = 1000;
            var valorCidadeFinal = 5000;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Cidade = valorCidadeInicial,
                Cidade_end = valorCidadeFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].{DBPoderJudiciarioAssociadoDicInfo.Cidade} BETWEEN @{DBPoderJudiciarioAssociadoDicInfo.Cidade} AND @{DBPoderJudiciarioAssociadoDicInfo.Cidade}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Cidade}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Cidade}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorCidadeInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorCidadeFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Cidade_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Cidade = valorInicial,
                Cidade_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Cidade}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Cidade}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Cidade_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Cidade = 1000,
                Cidade_end = 5000,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.Cidade}");
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.JusticaNome}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Cidade_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Cidade = 1000,
                Cidade_end = 5000,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Cidade_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Cidade = 1000,
                Cidade_end = 5000,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Cidade_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Cidade = 1000,
                Cidade_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].{DBPoderJudiciarioAssociadoDicInfo.Cidade} BETWEEN");
        }

        [Fact]
        public void WFiltro_Cidade_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Cidade = 1000,
                Cidade_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Cidade_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Cidade = 1000,
                Cidade_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Cidade_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorCidadeInicial = 2500;
            var valorCidadeFinal = 4750;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Cidade = valorCidadeInicial,
                Cidade_end = valorCidadeFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Cidade}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Cidade}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorCidadeInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorCidadeFinal);
        }

        [Fact]
        public void WFiltro_Cidade_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Cidade = 0,
                Cidade_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Cidade_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Cidade = 0,
                Cidade_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Cidade_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Cidade = 1500,
                Cidade_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Cidade == int.MinValue) && !(filtro.Cidade_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].{DBPoderJudiciarioAssociadoDicInfo.Cidade} BETWEEN @{DBPoderJudiciarioAssociadoDicInfo.Cidade} AND @{DBPoderJudiciarioAssociadoDicInfo.Cidade}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Cidade_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Cidade = 2000,
                Cidade_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Cidade == int.MinValue) && filtro.Cidade_end == int.MinValue
            // Deve resultar em igualdade quando apenas Cidade tem valor válido
            resultado.Value.where.Should().Be($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.Cidade}] = @{DBPoderJudiciarioAssociadoDicInfo.Cidade}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Cidade_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Cidade = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Cidade Isolated Tests
        [Fact]
        public void WFiltro_Cidade_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Cidade = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Cidade_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorCidade = 5;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Cidade = valorCidade,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.Cidade}] = @{DBPoderJudiciarioAssociadoDicInfo.Cidade}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBPoderJudiciarioAssociadoDicInfo.Cidade}");
            parametro.Value.Should().Be(valorCidade);
        }

        [Fact]
        public void WFiltro_Cidade_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorCidade = 0;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Cidade = valorCidade,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBPoderJudiciarioAssociadoDicInfo.Cidade}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCidade);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Cidade_DiferentesValoresValidos_DeveProcessarCorretamente(int valorCidade)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Cidade = valorCidade,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCidade);
            resultado.Value.where.Should().Contain($"= @{DBPoderJudiciarioAssociadoDicInfo.Cidade}");
        }

        [Fact]
        public void WFiltro_Cidade_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Cidade = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.Cidade}");
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.JusticaNome}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Cidade_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Cidade = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Cidade_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Cidade = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Cidade_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Cidade = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Cidade_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Cidade = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.Cidade}]");
        }

        [Fact]
        public void WFiltro_Cidade_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Cidade = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Cidade_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Cidade = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Cidade_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Cidade = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Cidade_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorCidade = 42;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Cidade = valorCidade,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorCidade);
        }

#endregion
        [Fact]
        public void WFiltro_Cidade_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Cidade = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Cidade_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorCidade = 1;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Cidade = valorCidade,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Cidade
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.Cidade}] = @pjaCidade");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@pjaCidade");
            parametro.Value.Should().Be(valorCidade);
        }

        [Fact]
        public void WFiltro_Cidade_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Cidade = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@pjaCidade");
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.JusticaNome}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Cidade_DiferentesValores_DeveFuncionar(int valorCidade)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Cidade = valorCidade,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCidade);
        }

#region filtro.SubDivisao_end Tests
        [Fact]
        public void WFiltro_SubDivisao_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisao_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_SubDivisao_end_QuandoTemValorPositivo_SemSubDivisaoInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorSubDivisaoEnd = 5000;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisao = int.MinValue, // Não define salário inicial
                SubDivisao_end = valorSubDivisaoEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há SubDivisao inicial válido, não deve incluir condição WHERE, mas o parâmetro SubDivisao_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // SubDivisao_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_SubDivisao_end_QuandoSomenteValorInicial_SemSubDivisaoEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorSubDivisao = 2500;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisao = valorSubDivisao,
                SubDivisao_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.SubDivisao}] = @{DBPoderJudiciarioAssociadoDicInfo.SubDivisao}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBPoderJudiciarioAssociadoDicInfo.SubDivisao}");
            parametro.Value.Should().Be(valorSubDivisao);
        }

        [Fact]
        public void WFiltro_SubDivisao_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorSubDivisaoInicial = 1000;
            var valorSubDivisaoFinal = 5000;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisao = valorSubDivisaoInicial,
                SubDivisao_end = valorSubDivisaoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].{DBPoderJudiciarioAssociadoDicInfo.SubDivisao} BETWEEN @{DBPoderJudiciarioAssociadoDicInfo.SubDivisao} AND @{DBPoderJudiciarioAssociadoDicInfo.SubDivisao}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.SubDivisao}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.SubDivisao}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorSubDivisaoInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorSubDivisaoFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_SubDivisao_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisao = valorInicial,
                SubDivisao_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.SubDivisao}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.SubDivisao}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_SubDivisao_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisao = 1000,
                SubDivisao_end = 5000,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.SubDivisao}");
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.JusticaNome}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_SubDivisao_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisao = 1000,
                SubDivisao_end = 5000,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_SubDivisao_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisao = 1000,
                SubDivisao_end = 5000,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_SubDivisao_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisao = 1000,
                SubDivisao_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].{DBPoderJudiciarioAssociadoDicInfo.SubDivisao} BETWEEN");
        }

        [Fact]
        public void WFiltro_SubDivisao_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisao = 1000,
                SubDivisao_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_SubDivisao_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisao = 1000,
                SubDivisao_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_SubDivisao_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorSubDivisaoInicial = 2500;
            var valorSubDivisaoFinal = 4750;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisao = valorSubDivisaoInicial,
                SubDivisao_end = valorSubDivisaoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.SubDivisao}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.SubDivisao}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorSubDivisaoInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorSubDivisaoFinal);
        }

        [Fact]
        public void WFiltro_SubDivisao_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisao = 0,
                SubDivisao_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_SubDivisao_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisao = 0,
                SubDivisao_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_SubDivisao_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisao = 1500,
                SubDivisao_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.SubDivisao == int.MinValue) && !(filtro.SubDivisao_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].{DBPoderJudiciarioAssociadoDicInfo.SubDivisao} BETWEEN @{DBPoderJudiciarioAssociadoDicInfo.SubDivisao} AND @{DBPoderJudiciarioAssociadoDicInfo.SubDivisao}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_SubDivisao_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisao = 2000,
                SubDivisao_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.SubDivisao == int.MinValue) && filtro.SubDivisao_end == int.MinValue
            // Deve resultar em igualdade quando apenas SubDivisao tem valor válido
            resultado.Value.where.Should().Be($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.SubDivisao}] = @{DBPoderJudiciarioAssociadoDicInfo.SubDivisao}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_SubDivisao_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisao = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.SubDivisao Isolated Tests
        [Fact]
        public void WFiltro_SubDivisao_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisao = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_SubDivisao_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorSubDivisao = 5;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisao = valorSubDivisao,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.SubDivisao}] = @{DBPoderJudiciarioAssociadoDicInfo.SubDivisao}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBPoderJudiciarioAssociadoDicInfo.SubDivisao}");
            parametro.Value.Should().Be(valorSubDivisao);
        }

        [Fact]
        public void WFiltro_SubDivisao_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorSubDivisao = 0;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisao = valorSubDivisao,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBPoderJudiciarioAssociadoDicInfo.SubDivisao}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorSubDivisao);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_SubDivisao_DiferentesValoresValidos_DeveProcessarCorretamente(int valorSubDivisao)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisao = valorSubDivisao,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorSubDivisao);
            resultado.Value.where.Should().Contain($"= @{DBPoderJudiciarioAssociadoDicInfo.SubDivisao}");
        }

        [Fact]
        public void WFiltro_SubDivisao_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisao = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.SubDivisao}");
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.JusticaNome}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_SubDivisao_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisao = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_SubDivisao_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisao = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_SubDivisao_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisao = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_SubDivisao_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisao = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.SubDivisao}]");
        }

        [Fact]
        public void WFiltro_SubDivisao_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisao = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_SubDivisao_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisao = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_SubDivisao_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisao = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_SubDivisao_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorSubDivisao = 42;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisao = valorSubDivisao,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorSubDivisao);
        }

#endregion
        [Fact]
        public void WFiltro_SubDivisao_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisao = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_SubDivisao_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorSubDivisao = 1;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisao = valorSubDivisao,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do SubDivisao
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.SubDivisao}] = @pjaSubDivisao");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@pjaSubDivisao");
            parametro.Value.Should().Be(valorSubDivisao);
        }

        [Fact]
        public void WFiltro_SubDivisao_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisao = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@pjaSubDivisao");
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.JusticaNome}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_SubDivisao_DiferentesValores_DeveFuncionar(int valorSubDivisao)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                SubDivisao = valorSubDivisao,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorSubDivisao);
        }

#region filtro.Tipo_end Tests
        [Fact]
        public void WFiltro_Tipo_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tipo_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Tipo_end_QuandoTemValorPositivo_SemTipoInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorTipoEnd = 5000;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tipo = int.MinValue, // Não define salário inicial
                Tipo_end = valorTipoEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Tipo inicial válido, não deve incluir condição WHERE, mas o parâmetro Tipo_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Tipo_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Tipo_end_QuandoSomenteValorInicial_SemTipoEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorTipo = 2500;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tipo = valorTipo,
                Tipo_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.Tipo}] = @{DBPoderJudiciarioAssociadoDicInfo.Tipo}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBPoderJudiciarioAssociadoDicInfo.Tipo}");
            parametro.Value.Should().Be(valorTipo);
        }

        [Fact]
        public void WFiltro_Tipo_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorTipoInicial = 1000;
            var valorTipoFinal = 5000;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tipo = valorTipoInicial,
                Tipo_end = valorTipoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].{DBPoderJudiciarioAssociadoDicInfo.Tipo} BETWEEN @{DBPoderJudiciarioAssociadoDicInfo.Tipo} AND @{DBPoderJudiciarioAssociadoDicInfo.Tipo}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Tipo}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Tipo}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorTipoInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorTipoFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Tipo_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tipo = valorInicial,
                Tipo_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Tipo}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Tipo}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Tipo_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tipo = 1000,
                Tipo_end = 5000,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.Tipo}");
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.JusticaNome}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Tipo_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tipo = 1000,
                Tipo_end = 5000,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Tipo_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tipo = 1000,
                Tipo_end = 5000,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Tipo_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tipo = 1000,
                Tipo_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].{DBPoderJudiciarioAssociadoDicInfo.Tipo} BETWEEN");
        }

        [Fact]
        public void WFiltro_Tipo_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tipo = 1000,
                Tipo_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Tipo_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tipo = 1000,
                Tipo_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Tipo_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorTipoInicial = 2500;
            var valorTipoFinal = 4750;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tipo = valorTipoInicial,
                Tipo_end = valorTipoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Tipo}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.Tipo}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorTipoInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorTipoFinal);
        }

        [Fact]
        public void WFiltro_Tipo_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tipo = 0,
                Tipo_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Tipo_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tipo = 0,
                Tipo_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Tipo_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tipo = 1500,
                Tipo_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Tipo == int.MinValue) && !(filtro.Tipo_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].{DBPoderJudiciarioAssociadoDicInfo.Tipo} BETWEEN @{DBPoderJudiciarioAssociadoDicInfo.Tipo} AND @{DBPoderJudiciarioAssociadoDicInfo.Tipo}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Tipo_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tipo = 2000,
                Tipo_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Tipo == int.MinValue) && filtro.Tipo_end == int.MinValue
            // Deve resultar em igualdade quando apenas Tipo tem valor válido
            resultado.Value.where.Should().Be($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.Tipo}] = @{DBPoderJudiciarioAssociadoDicInfo.Tipo}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Tipo_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tipo = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Tipo Isolated Tests
        [Fact]
        public void WFiltro_Tipo_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tipo = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Tipo_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorTipo = 5;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tipo = valorTipo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.Tipo}] = @{DBPoderJudiciarioAssociadoDicInfo.Tipo}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBPoderJudiciarioAssociadoDicInfo.Tipo}");
            parametro.Value.Should().Be(valorTipo);
        }

        [Fact]
        public void WFiltro_Tipo_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorTipo = 0;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tipo = valorTipo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBPoderJudiciarioAssociadoDicInfo.Tipo}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorTipo);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Tipo_DiferentesValoresValidos_DeveProcessarCorretamente(int valorTipo)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tipo = valorTipo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorTipo);
            resultado.Value.where.Should().Contain($"= @{DBPoderJudiciarioAssociadoDicInfo.Tipo}");
        }

        [Fact]
        public void WFiltro_Tipo_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tipo = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.Tipo}");
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.JusticaNome}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Tipo_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tipo = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Tipo_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tipo = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Tipo_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tipo = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Tipo_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tipo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.Tipo}]");
        }

        [Fact]
        public void WFiltro_Tipo_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tipo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Tipo_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tipo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Tipo_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tipo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Tipo_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorTipo = 42;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tipo = valorTipo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorTipo);
        }

#endregion
        [Fact]
        public void WFiltro_Tipo_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tipo = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Tipo_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorTipo = 1;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tipo = valorTipo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Tipo
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.Tipo}] = @pjaTipo");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@pjaTipo");
            parametro.Value.Should().Be(valorTipo);
        }

        [Fact]
        public void WFiltro_Tipo_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tipo = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@pjaTipo");
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.JusticaNome}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Tipo_DiferentesValores_DeveFuncionar(int valorTipo)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Tipo = valorTipo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorTipo);
        }

#region filtro.Codigo_filtro_end Tests
        [Fact]
        public void WFiltro_Codigo_filtro_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Codigo_filtro_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Codigo_filtro_end_QuandoTemValorPositivo_SemCodigo_filtroInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorCodigo_filtroEnd = 5000;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Codigo_filtro = int.MinValue, // Não define salário inicial
                Codigo_filtro_end = valorCodigo_filtroEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Codigo_filtro inicial válido, não deve incluir condição WHERE, mas o parâmetro Codigo_filtro_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Codigo_filtro_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Codigo_filtro_end_QuandoSomenteValorInicial_SemCodigo_filtroEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorCodigo_filtro = 2500;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Codigo_filtro = valorCodigo_filtro,
                Codigo_filtro_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.CampoCodigo}] = @{DBPoderJudiciarioAssociadoDicInfo.CampoCodigo}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBPoderJudiciarioAssociadoDicInfo.CampoCodigo}");
            parametro.Value.Should().Be(valorCodigo_filtro);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorCodigo_filtroInicial = 1000;
            var valorCodigo_filtroFinal = 5000;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Codigo_filtro = valorCodigo_filtroInicial,
                Codigo_filtro_end = valorCodigo_filtroFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].{DBPoderJudiciarioAssociadoDicInfo.CampoCodigo} BETWEEN @{DBPoderJudiciarioAssociadoDicInfo.CampoCodigo} AND @{DBPoderJudiciarioAssociadoDicInfo.CampoCodigo}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.CampoCodigo}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.CampoCodigo}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorCodigo_filtroInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorCodigo_filtroFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Codigo_filtro_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Codigo_filtro = valorInicial,
                Codigo_filtro_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.CampoCodigo}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.CampoCodigo}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.CampoCodigo}");
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.JusticaNome}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].{DBPoderJudiciarioAssociadoDicInfo.CampoCodigo} BETWEEN");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorCodigo_filtroInicial = 2500;
            var valorCodigo_filtroFinal = 4750;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Codigo_filtro = valorCodigo_filtroInicial,
                Codigo_filtro_end = valorCodigo_filtroFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.CampoCodigo}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBPoderJudiciarioAssociadoDicInfo.CampoCodigo}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorCodigo_filtroInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorCodigo_filtroFinal);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Codigo_filtro = 0,
                Codigo_filtro_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Codigo_filtro = 0,
                Codigo_filtro_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Codigo_filtro = 1500,
                Codigo_filtro_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Codigo_filtro == int.MinValue) && !(filtro.Codigo_filtro_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].{DBPoderJudiciarioAssociadoDicInfo.CampoCodigo} BETWEEN @{DBPoderJudiciarioAssociadoDicInfo.CampoCodigo} AND @{DBPoderJudiciarioAssociadoDicInfo.CampoCodigo}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Codigo_filtro = 2000,
                Codigo_filtro_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Codigo_filtro == int.MinValue) && filtro.Codigo_filtro_end == int.MinValue
            // Deve resultar em igualdade quando apenas Codigo_filtro tem valor válido
            resultado.Value.where.Should().Be($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.CampoCodigo}] = @{DBPoderJudiciarioAssociadoDicInfo.CampoCodigo}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Codigo_filtro_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Codigo_filtro = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Codigo_filtro Isolated Tests
        [Fact]
        public void WFiltro_Codigo_filtro_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Codigo_filtro = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorCodigo_filtro = 5;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.CampoCodigo}] = @{DBPoderJudiciarioAssociadoDicInfo.CampoCodigo}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBPoderJudiciarioAssociadoDicInfo.CampoCodigo}");
            parametro.Value.Should().Be(valorCodigo_filtro);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorCodigo_filtro = 0;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBPoderJudiciarioAssociadoDicInfo.CampoCodigo}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCodigo_filtro);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Codigo_filtro_DiferentesValoresValidos_DeveProcessarCorretamente(int valorCodigo_filtro)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCodigo_filtro);
            resultado.Value.where.Should().Contain($"= @{DBPoderJudiciarioAssociadoDicInfo.CampoCodigo}");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Codigo_filtro = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.CampoCodigo}");
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.JusticaNome}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Codigo_filtro = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Codigo_filtro = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Codigo_filtro = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Codigo_filtro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.CampoCodigo}]");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Codigo_filtro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Codigo_filtro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Codigo_filtro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorCodigo_filtro = 42;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorCodigo_filtro);
        }

#endregion
        [Fact]
        public void WFiltro_Codigo_filtro_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Codigo_filtro = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorCodigo_filtro = 1;
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Codigo_filtro
            resultado.Value.where.Should().Contain($"[{DBPoderJudiciarioAssociadoDicInfo.PTabelaNome}].[{DBPoderJudiciarioAssociadoDicInfo.CampoCodigo}] = @{DBPoderJudiciarioAssociadoDicInfo.CampoCodigo}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBPoderJudiciarioAssociadoDicInfo.CampoCodigo}");
            parametro.Value.Should().Be(valorCodigo_filtro);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Codigo_filtro = 1,
                JusticaNome = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.CampoCodigo}");
            resultado.Value.where.Should().Contain($"@{DBPoderJudiciarioAssociadoDicInfo.JusticaNome}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Codigo_filtro_DiferentesValores_DeveFuncionar(int valorCodigo_filtro)
        {
            // Arrange
            var filtro = new FilterPoderJudiciarioAssociado
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCodigo_filtro);
        }

#endregion
#region Decimal Tests
#endregion
#region DateTime Tests
#endregion
#region Bool Tests
#endregion
        [Fact]
        public void Dispose_CalledOnce_DisposesCorrectly()
        {
            // Act
            _service.Dispose();
            // Assert - Should not throw any exception
            Assert.True(true);
        }

        [Fact]
        public void Dispose_CalledTwice_DoesNotThrow()
        {
            // Act
            _service.Dispose();
            _service.Dispose();
            // Assert - Should not throw any exception
            Assert.True(true);
        }

        public virtual void Dispose()
        {
            _service?.Dispose();
        }
    }
}