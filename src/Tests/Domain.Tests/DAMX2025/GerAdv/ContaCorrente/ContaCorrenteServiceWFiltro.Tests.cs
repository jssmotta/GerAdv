// 100% auto-generated by Source Genesys WebApi Front & Back Creator
// copyright © 2000-2025 Menphis - Sistemas Inteligentes
// This file is part of the Source Genesys project                     
namespace MenphisSI.GerAdv.WFiltro.Tests
{
    public class ContaCorrenteServiceWFiltroTests : IDisposable
    {
        private readonly Mock<IOptions<AppSettings>> _mockAppSettings;
        private readonly Mock<IFContaCorrenteFactory> _mockContaCorrenteFactory;
        private readonly Mock<IContaCorrenteReader> _mockReader;
        private readonly Mock<IContaCorrenteValidation> _mockValidation;
        private readonly Mock<IContaCorrenteWriter> _mockWriter;
        private readonly Mock<IClientesReader> _mockClientesReader;
        private readonly Mock<IHttpContextAccessor> _mockHttpContextAccessor;
        private readonly Mock<HybridCache> _mockCache;
        private readonly Mock<IMemoryCache> _mockMemoryCache;
        private readonly ContaCorrenteService _service;
        public ContaCorrenteServiceWFiltroTests()
        {
            _mockAppSettings = new Mock<IOptions<AppSettings>>();
            _mockContaCorrenteFactory = new Mock<IFContaCorrenteFactory>();
            _mockReader = new Mock<IContaCorrenteReader>();
            _mockValidation = new Mock<IContaCorrenteValidation>();
            _mockWriter = new Mock<IContaCorrenteWriter>();
            _mockClientesReader = new Mock<IClientesReader>();
            _mockHttpContextAccessor = new Mock<IHttpContextAccessor>();
            _mockCache = new Mock<HybridCache>();
            _mockMemoryCache = new Mock<IMemoryCache>();
            var appSettings = new AppSettings();
            _mockAppSettings.Setup(x => x.Value).Returns(appSettings);
            _service = new ContaCorrenteService(_mockAppSettings.Object, _mockContaCorrenteFactory.Object, _mockReader.Object, _mockValidation.Object, _mockWriter.Object, _mockClientesReader.Object, _mockHttpContextAccessor.Object, _mockCache.Object, _mockMemoryCache.Object);
        }

        [Fact]
        public void WFiltro_QuandoFiltroEhNull_DeveRetornarResultadoVazio()
        {
            // Arrange
            FilterContaCorrente? filtro = null;
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().BeNull();
        }

        [Fact]
        public void WFiltro_QuandoTodosCamposSaoValoresPadrao_DeveRetornarResultadoVazio()
        {
            // Arrange
            var filtro = new FilterContaCorrente(); // Todos os valores padrão
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_ComTodosOsCamposPreenchidos_DeveProcessarRapidamente()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                CIAcordo = 1,
                Quitado = 2,
                IDContrato = 1,
                QuitadoID = 1,
                DebitoID = 1,
                LivroCaixaID = 1,
                Sucumbencia = 1,
                DistRegra = 2,
                DtOriginal = "24/04/1975",
                Processo = 1,
                ParcelaX = 1,
                Valor = 0m,
                Data = "27/05/2022",
                Cliente = 1,
                Historico = "MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM",
                Contrato = 1,
                Pago = 2,
                Distribuir = 1,
                LC = 2,
                IDHTrab = 1,
                NroParcelas = 1,
                ValorPrincipal = 0m,
                ParcelaPrincipalID = 1,
                Hide = 1,
                DataPgto = "24/04/1975",
                GUID = Guid.NewGuid().ToString(),
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var stopwatch = System.Diagnostics.Stopwatch.StartNew();
            var resultado = _service.WFiltro(filtro);
            stopwatch.Stop();
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().NotBeEmpty();
            resultado.Value.where.Should().NotBeEmpty();
            stopwatch.ElapsedMilliseconds.Should().BeLessThan(100); // Deve processar em menos de 100ms
        }

#region String Tests
        [Fact]
        public void WFiltro_DataContaCorrente_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Data = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_DataContaCorrente_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Data = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_DataContaCorrente_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeContaCorrente = "João Silva";
            var filtro = new FilterContaCorrente
            {
                Data = nomeContaCorrente,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_DataContaCorrente_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Data = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_DataContaCorrente_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Data = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_DataContaCorrente_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeContaCorrente)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Data = nomeContaCorrente,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DataContaCorrente_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Data = "João",
                IDContrato = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@ctoData");
            resultado.Value.where.Should().Contain("@ctoIDContrato");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @ctoData");
            resultado.Value.where.Should().Contain("= @ctoIDContrato");
        }

        [Fact]
        public void WFiltro_DataContaCorrente_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeContaCorrente = "João Silva";
            var filtro = new FilterContaCorrente
            {
                Data = nomeContaCorrente,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.Data}]");
            resultado.Value.where.Should().Contain("like @ctoData");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@ctoData");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_Historico_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string historicoComWhitespace)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Historico = historicoComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_Historico_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var historicoGigante = new string ('A', 1000);
            var filtro = new FilterContaCorrente
            {
                Historico = historicoGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{historicoGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_Historico_ComCaracteresEspeciais_DeveProcessarCorretamente(string historicoComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Historico = historicoComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(historicoComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_HistoricoContaCorrente_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Historico = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_HistoricoContaCorrente_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Historico = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_HistoricoContaCorrente_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeContaCorrente = "João Silva";
            var filtro = new FilterContaCorrente
            {
                Historico = nomeContaCorrente,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_HistoricoContaCorrente_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Historico = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_HistoricoContaCorrente_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Historico = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_HistoricoContaCorrente_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeContaCorrente)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Historico = nomeContaCorrente,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_HistoricoContaCorrente_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Historico = "João",
                IDContrato = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@ctoHistorico");
            resultado.Value.where.Should().Contain("@ctoIDContrato");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @ctoHistorico");
            resultado.Value.where.Should().Contain("= @ctoIDContrato");
        }

        [Fact]
        public void WFiltro_HistoricoContaCorrente_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeContaCorrente = "João Silva";
            var filtro = new FilterContaCorrente
            {
                Historico = nomeContaCorrente,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.Historico}]");
            resultado.Value.where.Should().Contain("like @ctoHistorico");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@ctoHistorico");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

        [Theory]
        [InlineData("     ")] // Apenas espaços
        [InlineData("\t\t\t")] // Apenas tabs
        [InlineData("\n\n\n")] // Apenas quebras de linha
        [InlineData("\r\n\r\n")] // Carriage return + line feed
        public void WFiltro_GUID_ComStringComApenasWhitespace_NaoDeveIncluirNoFiltro(string guidComWhitespace)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                GUID = guidComWhitespace,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_GUID_ComStringMuitoLonga_DeveProcessarCorretamente()
        {
            // Arrange
            var guidGigante = new string ('A', 1000);
            var filtro = new FilterContaCorrente
            {
                GUID = guidGigante,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().Be($"%{guidGigante}%");
        }

        [Theory]
        [InlineData("João'Silva")] // Com aspas simples
        [InlineData("João\"Silva")] // Com aspas duplas
        [InlineData("João;DROP%TABLE--")] // SQL injection attempt
        [InlineData("João<script>alert('xss')</script>")] // XSS attempt
        public void WFiltro_GUID_ComCaracteresEspeciais_DeveProcessarCorretamente(string guidComCaracteresEspeciais)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                GUID = guidComCaracteresEspeciais,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Contain(guidComCaracteresEspeciais);
        }

        [Fact]
        public void WFiltro_GUIDContaCorrente_QuandoStringVazia_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                GUID = string.Empty,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando string vazia
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_GUIDContaCorrente_QuandoStringNull_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                GUID = null,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando null
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_GUIDContaCorrente_SemWildcard_DeveRetornarValorOriginal()
        {
            // Arrange
            var nomeContaCorrente = "João Silva";
            var filtro = new FilterContaCorrente
            {
                GUID = nomeContaCorrente,
                WildcardChar = '\0', // Sem wildcard
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Sem wildcard, deve retornar valor original
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("João Silva");
        }

        [Theory]
        [InlineData('%', "João Silva", "%João%Silva%")]
        [InlineData('*', "João Silva", "*João*Silva*")]
        [InlineData('\0', "João Silva", "João Silva")]
        [InlineData(' ', "João Silva", "João Silva")]
        public void WFiltro_GUIDContaCorrente_DiferentesWildcards_DeveAplicarCorretamente(char wildcardChar, string nomeOriginal, string esperado)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                GUID = nomeOriginal,
                WildcardChar = wildcardChar,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(esperado);
        }

        [Fact]
        public void WFiltro_GUIDContaCorrente_StringComEspacos_DeveSubstituirEspacosPorWildcard()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                GUID = "João da Silva",
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            // Espaços devem ser substituídos por wildcards
            var parametro = resultado.Value.parametros.First();
            parametro.Value.ToString().Should().Be("%João%da%Silva%");
        }

        [Theory]
        [InlineData("")]
        [InlineData("   ")]
        [InlineData(null)]
        public void WFiltro_GUIDContaCorrente_StringsVazias_NaoDeveIncluirNoFiltro(string? nomeContaCorrente)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                GUID = nomeContaCorrente,
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_GUIDContaCorrente_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                GUID = "João",
                IDContrato = 1, // Campo INT para testar combinação
                WildcardChar = '%',
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@ctoGUID");
            resultado.Value.where.Should().Contain("@ctoIDContrato");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica se um usa LIKE e outro usa =
            resultado.Value.where.Should().Contain("like @ctoGUID");
            resultado.Value.where.Should().Contain("= @ctoIDContrato");
        }

        [Fact]
        public void WFiltro_GUIDContaCorrente_QuandoTemValor_DeveIncluirNoFiltroComLike()
        {
            // Arrange
            var nomeContaCorrente = "João Silva";
            var filtro = new FilterContaCorrente
            {
                GUID = nomeContaCorrente,
                WildcardChar = '%', // Wildcard padrão SQL
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição com LIKE
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.GUID}]");
            resultado.Value.where.Should().Contain("like @ctoGUID");
            resultado.Value.where.Should().Contain(DevourerConsts.MsiCollate);
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico (com wildcard aplicado)
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@ctoGUID");
            parametro.Value.ToString().Should().Be("%João%Silva%"); // ApplyWildCard aplicado
        }

#endregion
#region Integer Tests
#region filtro.CIAcordo_end Tests
        [Fact]
        public void WFiltro_CIAcordo_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                CIAcordo_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_CIAcordo_end_QuandoTemValorPositivo_SemCIAcordoInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorCIAcordoEnd = 5000;
            var filtro = new FilterContaCorrente
            {
                CIAcordo = int.MinValue, // Não define salário inicial
                CIAcordo_end = valorCIAcordoEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há CIAcordo inicial válido, não deve incluir condição WHERE, mas o parâmetro CIAcordo_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // CIAcordo_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_CIAcordo_end_QuandoSomenteValorInicial_SemCIAcordoEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorCIAcordo = 2500;
            var filtro = new FilterContaCorrente
            {
                CIAcordo = valorCIAcordo,
                CIAcordo_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.CIAcordo}] = @{DBContaCorrenteDicInfo.CIAcordo}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContaCorrenteDicInfo.CIAcordo}");
            parametro.Value.Should().Be(valorCIAcordo);
        }

        [Fact]
        public void WFiltro_CIAcordo_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorCIAcordoInicial = 1000;
            var valorCIAcordoFinal = 5000;
            var filtro = new FilterContaCorrente
            {
                CIAcordo = valorCIAcordoInicial,
                CIAcordo_end = valorCIAcordoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.CIAcordo} BETWEEN @{DBContaCorrenteDicInfo.CIAcordo} AND @{DBContaCorrenteDicInfo.CIAcordo}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.CIAcordo}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.CIAcordo}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorCIAcordoInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorCIAcordoFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_CIAcordo_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                CIAcordo = valorInicial,
                CIAcordo_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.CIAcordo}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.CIAcordo}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_CIAcordo_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                CIAcordo = 1000,
                CIAcordo_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.CIAcordo}");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_CIAcordo_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                CIAcordo = 1000,
                CIAcordo_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_CIAcordo_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                CIAcordo = 1000,
                CIAcordo_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_CIAcordo_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                CIAcordo = 1000,
                CIAcordo_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.CIAcordo} BETWEEN");
        }

        [Fact]
        public void WFiltro_CIAcordo_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                CIAcordo = 1000,
                CIAcordo_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_CIAcordo_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                CIAcordo = 1000,
                CIAcordo_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_CIAcordo_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorCIAcordoInicial = 2500;
            var valorCIAcordoFinal = 4750;
            var filtro = new FilterContaCorrente
            {
                CIAcordo = valorCIAcordoInicial,
                CIAcordo_end = valorCIAcordoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.CIAcordo}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.CIAcordo}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorCIAcordoInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorCIAcordoFinal);
        }

        [Fact]
        public void WFiltro_CIAcordo_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                CIAcordo = 0,
                CIAcordo_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_CIAcordo_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                CIAcordo = 0,
                CIAcordo_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_CIAcordo_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                CIAcordo = 1500,
                CIAcordo_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.CIAcordo == int.MinValue) && !(filtro.CIAcordo_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.CIAcordo} BETWEEN @{DBContaCorrenteDicInfo.CIAcordo} AND @{DBContaCorrenteDicInfo.CIAcordo}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_CIAcordo_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                CIAcordo = 2000,
                CIAcordo_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.CIAcordo == int.MinValue) && filtro.CIAcordo_end == int.MinValue
            // Deve resultar em igualdade quando apenas CIAcordo tem valor válido
            resultado.Value.where.Should().Be($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.CIAcordo}] = @{DBContaCorrenteDicInfo.CIAcordo}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_CIAcordo_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                CIAcordo = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.CIAcordo Isolated Tests
        [Fact]
        public void WFiltro_CIAcordo_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                CIAcordo = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_CIAcordo_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorCIAcordo = 5;
            var filtro = new FilterContaCorrente
            {
                CIAcordo = valorCIAcordo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.CIAcordo}] = @{DBContaCorrenteDicInfo.CIAcordo}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContaCorrenteDicInfo.CIAcordo}");
            parametro.Value.Should().Be(valorCIAcordo);
        }

        [Fact]
        public void WFiltro_CIAcordo_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorCIAcordo = 0;
            var filtro = new FilterContaCorrente
            {
                CIAcordo = valorCIAcordo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBContaCorrenteDicInfo.CIAcordo}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCIAcordo);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_CIAcordo_DiferentesValoresValidos_DeveProcessarCorretamente(int valorCIAcordo)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                CIAcordo = valorCIAcordo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCIAcordo);
            resultado.Value.where.Should().Contain($"= @{DBContaCorrenteDicInfo.CIAcordo}");
        }

        [Fact]
        public void WFiltro_CIAcordo_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                CIAcordo = 1,
                Data = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.CIAcordo}");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_CIAcordo_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                CIAcordo = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_CIAcordo_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                CIAcordo = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_CIAcordo_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                CIAcordo = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_CIAcordo_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                CIAcordo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.CIAcordo}]");
        }

        [Fact]
        public void WFiltro_CIAcordo_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                CIAcordo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_CIAcordo_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                CIAcordo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_CIAcordo_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                CIAcordo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_CIAcordo_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorCIAcordo = 42;
            var filtro = new FilterContaCorrente
            {
                CIAcordo = valorCIAcordo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorCIAcordo);
        }

#endregion
        [Fact]
        public void WFiltro_CIAcordo_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                CIAcordo = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_CIAcordo_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorCIAcordo = 1;
            var filtro = new FilterContaCorrente
            {
                CIAcordo = valorCIAcordo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do CIAcordo
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.CIAcordo}] = @ctoCIAcordo");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@ctoCIAcordo");
            parametro.Value.Should().Be(valorCIAcordo);
        }

        [Fact]
        public void WFiltro_CIAcordo_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                CIAcordo = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@ctoCIAcordo");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_CIAcordo_DiferentesValores_DeveFuncionar(int valorCIAcordo)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                CIAcordo = valorCIAcordo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCIAcordo);
        }

#region filtro.IDContrato_end Tests
        [Fact]
        public void WFiltro_IDContrato_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDContrato_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_IDContrato_end_QuandoTemValorPositivo_SemIDContratoInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorIDContratoEnd = 5000;
            var filtro = new FilterContaCorrente
            {
                IDContrato = int.MinValue, // Não define salário inicial
                IDContrato_end = valorIDContratoEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há IDContrato inicial válido, não deve incluir condição WHERE, mas o parâmetro IDContrato_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // IDContrato_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_IDContrato_end_QuandoSomenteValorInicial_SemIDContratoEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorIDContrato = 2500;
            var filtro = new FilterContaCorrente
            {
                IDContrato = valorIDContrato,
                IDContrato_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.IDContrato}] = @{DBContaCorrenteDicInfo.IDContrato}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContaCorrenteDicInfo.IDContrato}");
            parametro.Value.Should().Be(valorIDContrato);
        }

        [Fact]
        public void WFiltro_IDContrato_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorIDContratoInicial = 1000;
            var valorIDContratoFinal = 5000;
            var filtro = new FilterContaCorrente
            {
                IDContrato = valorIDContratoInicial,
                IDContrato_end = valorIDContratoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.IDContrato} BETWEEN @{DBContaCorrenteDicInfo.IDContrato} AND @{DBContaCorrenteDicInfo.IDContrato}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.IDContrato}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.IDContrato}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorIDContratoInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorIDContratoFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_IDContrato_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDContrato = valorInicial,
                IDContrato_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.IDContrato}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.IDContrato}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_IDContrato_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDContrato = 1000,
                IDContrato_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.IDContrato}");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_IDContrato_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDContrato = 1000,
                IDContrato_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_IDContrato_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDContrato = 1000,
                IDContrato_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_IDContrato_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDContrato = 1000,
                IDContrato_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.IDContrato} BETWEEN");
        }

        [Fact]
        public void WFiltro_IDContrato_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDContrato = 1000,
                IDContrato_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_IDContrato_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDContrato = 1000,
                IDContrato_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_IDContrato_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorIDContratoInicial = 2500;
            var valorIDContratoFinal = 4750;
            var filtro = new FilterContaCorrente
            {
                IDContrato = valorIDContratoInicial,
                IDContrato_end = valorIDContratoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.IDContrato}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.IDContrato}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorIDContratoInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorIDContratoFinal);
        }

        [Fact]
        public void WFiltro_IDContrato_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDContrato = 0,
                IDContrato_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_IDContrato_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDContrato = 0,
                IDContrato_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_IDContrato_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDContrato = 1500,
                IDContrato_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.IDContrato == int.MinValue) && !(filtro.IDContrato_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.IDContrato} BETWEEN @{DBContaCorrenteDicInfo.IDContrato} AND @{DBContaCorrenteDicInfo.IDContrato}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_IDContrato_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDContrato = 2000,
                IDContrato_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.IDContrato == int.MinValue) && filtro.IDContrato_end == int.MinValue
            // Deve resultar em igualdade quando apenas IDContrato tem valor válido
            resultado.Value.where.Should().Be($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.IDContrato}] = @{DBContaCorrenteDicInfo.IDContrato}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_IDContrato_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDContrato = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.IDContrato Isolated Tests
        [Fact]
        public void WFiltro_IDContrato_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDContrato = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_IDContrato_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorIDContrato = 5;
            var filtro = new FilterContaCorrente
            {
                IDContrato = valorIDContrato,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.IDContrato}] = @{DBContaCorrenteDicInfo.IDContrato}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContaCorrenteDicInfo.IDContrato}");
            parametro.Value.Should().Be(valorIDContrato);
        }

        [Fact]
        public void WFiltro_IDContrato_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorIDContrato = 0;
            var filtro = new FilterContaCorrente
            {
                IDContrato = valorIDContrato,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBContaCorrenteDicInfo.IDContrato}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorIDContrato);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_IDContrato_DiferentesValoresValidos_DeveProcessarCorretamente(int valorIDContrato)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDContrato = valorIDContrato,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorIDContrato);
            resultado.Value.where.Should().Contain($"= @{DBContaCorrenteDicInfo.IDContrato}");
        }

        [Fact]
        public void WFiltro_IDContrato_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDContrato = 1,
                Data = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.IDContrato}");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_IDContrato_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDContrato = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_IDContrato_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDContrato = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_IDContrato_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDContrato = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_IDContrato_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDContrato = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.IDContrato}]");
        }

        [Fact]
        public void WFiltro_IDContrato_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDContrato = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_IDContrato_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDContrato = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_IDContrato_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDContrato = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_IDContrato_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorIDContrato = 42;
            var filtro = new FilterContaCorrente
            {
                IDContrato = valorIDContrato,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorIDContrato);
        }

#endregion
        [Fact]
        public void WFiltro_IDContrato_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDContrato = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_IDContrato_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorIDContrato = 1;
            var filtro = new FilterContaCorrente
            {
                IDContrato = valorIDContrato,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do IDContrato
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.IDContrato}] = @ctoIDContrato");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@ctoIDContrato");
            parametro.Value.Should().Be(valorIDContrato);
        }

        [Fact]
        public void WFiltro_IDContrato_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDContrato = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@ctoIDContrato");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_IDContrato_DiferentesValores_DeveFuncionar(int valorIDContrato)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDContrato = valorIDContrato,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorIDContrato);
        }

#region filtro.QuitadoID_end Tests
        [Fact]
        public void WFiltro_QuitadoID_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                QuitadoID_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_QuitadoID_end_QuandoTemValorPositivo_SemQuitadoIDInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorQuitadoIDEnd = 5000;
            var filtro = new FilterContaCorrente
            {
                QuitadoID = int.MinValue, // Não define salário inicial
                QuitadoID_end = valorQuitadoIDEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há QuitadoID inicial válido, não deve incluir condição WHERE, mas o parâmetro QuitadoID_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // QuitadoID_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_QuitadoID_end_QuandoSomenteValorInicial_SemQuitadoIDEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorQuitadoID = 2500;
            var filtro = new FilterContaCorrente
            {
                QuitadoID = valorQuitadoID,
                QuitadoID_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.QuitadoID}] = @{DBContaCorrenteDicInfo.QuitadoID}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContaCorrenteDicInfo.QuitadoID}");
            parametro.Value.Should().Be(valorQuitadoID);
        }

        [Fact]
        public void WFiltro_QuitadoID_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorQuitadoIDInicial = 1000;
            var valorQuitadoIDFinal = 5000;
            var filtro = new FilterContaCorrente
            {
                QuitadoID = valorQuitadoIDInicial,
                QuitadoID_end = valorQuitadoIDFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.QuitadoID} BETWEEN @{DBContaCorrenteDicInfo.QuitadoID} AND @{DBContaCorrenteDicInfo.QuitadoID}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.QuitadoID}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.QuitadoID}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorQuitadoIDInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorQuitadoIDFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_QuitadoID_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                QuitadoID = valorInicial,
                QuitadoID_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.QuitadoID}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.QuitadoID}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_QuitadoID_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                QuitadoID = 1000,
                QuitadoID_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.QuitadoID}");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_QuitadoID_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                QuitadoID = 1000,
                QuitadoID_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_QuitadoID_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                QuitadoID = 1000,
                QuitadoID_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_QuitadoID_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                QuitadoID = 1000,
                QuitadoID_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.QuitadoID} BETWEEN");
        }

        [Fact]
        public void WFiltro_QuitadoID_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                QuitadoID = 1000,
                QuitadoID_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_QuitadoID_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                QuitadoID = 1000,
                QuitadoID_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_QuitadoID_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorQuitadoIDInicial = 2500;
            var valorQuitadoIDFinal = 4750;
            var filtro = new FilterContaCorrente
            {
                QuitadoID = valorQuitadoIDInicial,
                QuitadoID_end = valorQuitadoIDFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.QuitadoID}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.QuitadoID}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorQuitadoIDInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorQuitadoIDFinal);
        }

        [Fact]
        public void WFiltro_QuitadoID_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                QuitadoID = 0,
                QuitadoID_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_QuitadoID_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                QuitadoID = 0,
                QuitadoID_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_QuitadoID_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                QuitadoID = 1500,
                QuitadoID_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.QuitadoID == int.MinValue) && !(filtro.QuitadoID_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.QuitadoID} BETWEEN @{DBContaCorrenteDicInfo.QuitadoID} AND @{DBContaCorrenteDicInfo.QuitadoID}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_QuitadoID_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                QuitadoID = 2000,
                QuitadoID_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.QuitadoID == int.MinValue) && filtro.QuitadoID_end == int.MinValue
            // Deve resultar em igualdade quando apenas QuitadoID tem valor válido
            resultado.Value.where.Should().Be($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.QuitadoID}] = @{DBContaCorrenteDicInfo.QuitadoID}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_QuitadoID_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                QuitadoID = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.QuitadoID Isolated Tests
        [Fact]
        public void WFiltro_QuitadoID_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                QuitadoID = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_QuitadoID_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorQuitadoID = 5;
            var filtro = new FilterContaCorrente
            {
                QuitadoID = valorQuitadoID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.QuitadoID}] = @{DBContaCorrenteDicInfo.QuitadoID}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContaCorrenteDicInfo.QuitadoID}");
            parametro.Value.Should().Be(valorQuitadoID);
        }

        [Fact]
        public void WFiltro_QuitadoID_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorQuitadoID = 0;
            var filtro = new FilterContaCorrente
            {
                QuitadoID = valorQuitadoID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBContaCorrenteDicInfo.QuitadoID}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorQuitadoID);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_QuitadoID_DiferentesValoresValidos_DeveProcessarCorretamente(int valorQuitadoID)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                QuitadoID = valorQuitadoID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorQuitadoID);
            resultado.Value.where.Should().Contain($"= @{DBContaCorrenteDicInfo.QuitadoID}");
        }

        [Fact]
        public void WFiltro_QuitadoID_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                QuitadoID = 1,
                Data = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.QuitadoID}");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_QuitadoID_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                QuitadoID = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_QuitadoID_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                QuitadoID = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_QuitadoID_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                QuitadoID = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_QuitadoID_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                QuitadoID = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.QuitadoID}]");
        }

        [Fact]
        public void WFiltro_QuitadoID_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                QuitadoID = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_QuitadoID_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                QuitadoID = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_QuitadoID_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                QuitadoID = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_QuitadoID_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorQuitadoID = 42;
            var filtro = new FilterContaCorrente
            {
                QuitadoID = valorQuitadoID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorQuitadoID);
        }

#endregion
        [Fact]
        public void WFiltro_QuitadoID_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                QuitadoID = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_QuitadoID_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorQuitadoID = 1;
            var filtro = new FilterContaCorrente
            {
                QuitadoID = valorQuitadoID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do QuitadoID
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.QuitadoID}] = @ctoQuitadoID");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@ctoQuitadoID");
            parametro.Value.Should().Be(valorQuitadoID);
        }

        [Fact]
        public void WFiltro_QuitadoID_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                QuitadoID = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@ctoQuitadoID");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_QuitadoID_DiferentesValores_DeveFuncionar(int valorQuitadoID)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                QuitadoID = valorQuitadoID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorQuitadoID);
        }

#region filtro.DebitoID_end Tests
        [Fact]
        public void WFiltro_DebitoID_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DebitoID_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_DebitoID_end_QuandoTemValorPositivo_SemDebitoIDInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorDebitoIDEnd = 5000;
            var filtro = new FilterContaCorrente
            {
                DebitoID = int.MinValue, // Não define salário inicial
                DebitoID_end = valorDebitoIDEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há DebitoID inicial válido, não deve incluir condição WHERE, mas o parâmetro DebitoID_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // DebitoID_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_DebitoID_end_QuandoSomenteValorInicial_SemDebitoIDEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorDebitoID = 2500;
            var filtro = new FilterContaCorrente
            {
                DebitoID = valorDebitoID,
                DebitoID_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.DebitoID}] = @{DBContaCorrenteDicInfo.DebitoID}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContaCorrenteDicInfo.DebitoID}");
            parametro.Value.Should().Be(valorDebitoID);
        }

        [Fact]
        public void WFiltro_DebitoID_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorDebitoIDInicial = 1000;
            var valorDebitoIDFinal = 5000;
            var filtro = new FilterContaCorrente
            {
                DebitoID = valorDebitoIDInicial,
                DebitoID_end = valorDebitoIDFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.DebitoID} BETWEEN @{DBContaCorrenteDicInfo.DebitoID} AND @{DBContaCorrenteDicInfo.DebitoID}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.DebitoID}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.DebitoID}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorDebitoIDInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorDebitoIDFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_DebitoID_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DebitoID = valorInicial,
                DebitoID_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.DebitoID}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.DebitoID}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_DebitoID_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DebitoID = 1000,
                DebitoID_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.DebitoID}");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_DebitoID_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DebitoID = 1000,
                DebitoID_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_DebitoID_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DebitoID = 1000,
                DebitoID_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_DebitoID_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DebitoID = 1000,
                DebitoID_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.DebitoID} BETWEEN");
        }

        [Fact]
        public void WFiltro_DebitoID_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DebitoID = 1000,
                DebitoID_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_DebitoID_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DebitoID = 1000,
                DebitoID_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_DebitoID_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorDebitoIDInicial = 2500;
            var valorDebitoIDFinal = 4750;
            var filtro = new FilterContaCorrente
            {
                DebitoID = valorDebitoIDInicial,
                DebitoID_end = valorDebitoIDFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.DebitoID}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.DebitoID}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorDebitoIDInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorDebitoIDFinal);
        }

        [Fact]
        public void WFiltro_DebitoID_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DebitoID = 0,
                DebitoID_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_DebitoID_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DebitoID = 0,
                DebitoID_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_DebitoID_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DebitoID = 1500,
                DebitoID_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.DebitoID == int.MinValue) && !(filtro.DebitoID_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.DebitoID} BETWEEN @{DBContaCorrenteDicInfo.DebitoID} AND @{DBContaCorrenteDicInfo.DebitoID}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_DebitoID_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DebitoID = 2000,
                DebitoID_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.DebitoID == int.MinValue) && filtro.DebitoID_end == int.MinValue
            // Deve resultar em igualdade quando apenas DebitoID tem valor válido
            resultado.Value.where.Should().Be($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.DebitoID}] = @{DBContaCorrenteDicInfo.DebitoID}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_DebitoID_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DebitoID = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.DebitoID Isolated Tests
        [Fact]
        public void WFiltro_DebitoID_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DebitoID = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_DebitoID_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorDebitoID = 5;
            var filtro = new FilterContaCorrente
            {
                DebitoID = valorDebitoID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.DebitoID}] = @{DBContaCorrenteDicInfo.DebitoID}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContaCorrenteDicInfo.DebitoID}");
            parametro.Value.Should().Be(valorDebitoID);
        }

        [Fact]
        public void WFiltro_DebitoID_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorDebitoID = 0;
            var filtro = new FilterContaCorrente
            {
                DebitoID = valorDebitoID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBContaCorrenteDicInfo.DebitoID}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorDebitoID);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_DebitoID_DiferentesValoresValidos_DeveProcessarCorretamente(int valorDebitoID)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DebitoID = valorDebitoID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorDebitoID);
            resultado.Value.where.Should().Contain($"= @{DBContaCorrenteDicInfo.DebitoID}");
        }

        [Fact]
        public void WFiltro_DebitoID_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DebitoID = 1,
                Data = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.DebitoID}");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_DebitoID_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DebitoID = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_DebitoID_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DebitoID = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_DebitoID_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DebitoID = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_DebitoID_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DebitoID = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.DebitoID}]");
        }

        [Fact]
        public void WFiltro_DebitoID_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DebitoID = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_DebitoID_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DebitoID = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_DebitoID_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DebitoID = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_DebitoID_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorDebitoID = 42;
            var filtro = new FilterContaCorrente
            {
                DebitoID = valorDebitoID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorDebitoID);
        }

#endregion
        [Fact]
        public void WFiltro_DebitoID_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DebitoID = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_DebitoID_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorDebitoID = 1;
            var filtro = new FilterContaCorrente
            {
                DebitoID = valorDebitoID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do DebitoID
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.DebitoID}] = @ctoDebitoID");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@ctoDebitoID");
            parametro.Value.Should().Be(valorDebitoID);
        }

        [Fact]
        public void WFiltro_DebitoID_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DebitoID = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@ctoDebitoID");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_DebitoID_DiferentesValores_DeveFuncionar(int valorDebitoID)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DebitoID = valorDebitoID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorDebitoID);
        }

#region filtro.LivroCaixaID_end Tests
        [Fact]
        public void WFiltro_LivroCaixaID_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                LivroCaixaID_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_LivroCaixaID_end_QuandoTemValorPositivo_SemLivroCaixaIDInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorLivroCaixaIDEnd = 5000;
            var filtro = new FilterContaCorrente
            {
                LivroCaixaID = int.MinValue, // Não define salário inicial
                LivroCaixaID_end = valorLivroCaixaIDEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há LivroCaixaID inicial válido, não deve incluir condição WHERE, mas o parâmetro LivroCaixaID_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // LivroCaixaID_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_LivroCaixaID_end_QuandoSomenteValorInicial_SemLivroCaixaIDEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorLivroCaixaID = 2500;
            var filtro = new FilterContaCorrente
            {
                LivroCaixaID = valorLivroCaixaID,
                LivroCaixaID_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.LivroCaixaID}] = @{DBContaCorrenteDicInfo.LivroCaixaID}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContaCorrenteDicInfo.LivroCaixaID}");
            parametro.Value.Should().Be(valorLivroCaixaID);
        }

        [Fact]
        public void WFiltro_LivroCaixaID_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorLivroCaixaIDInicial = 1000;
            var valorLivroCaixaIDFinal = 5000;
            var filtro = new FilterContaCorrente
            {
                LivroCaixaID = valorLivroCaixaIDInicial,
                LivroCaixaID_end = valorLivroCaixaIDFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.LivroCaixaID} BETWEEN @{DBContaCorrenteDicInfo.LivroCaixaID} AND @{DBContaCorrenteDicInfo.LivroCaixaID}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.LivroCaixaID}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.LivroCaixaID}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorLivroCaixaIDInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorLivroCaixaIDFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_LivroCaixaID_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                LivroCaixaID = valorInicial,
                LivroCaixaID_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.LivroCaixaID}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.LivroCaixaID}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_LivroCaixaID_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                LivroCaixaID = 1000,
                LivroCaixaID_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.LivroCaixaID}");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_LivroCaixaID_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                LivroCaixaID = 1000,
                LivroCaixaID_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_LivroCaixaID_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                LivroCaixaID = 1000,
                LivroCaixaID_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_LivroCaixaID_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                LivroCaixaID = 1000,
                LivroCaixaID_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.LivroCaixaID} BETWEEN");
        }

        [Fact]
        public void WFiltro_LivroCaixaID_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                LivroCaixaID = 1000,
                LivroCaixaID_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_LivroCaixaID_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                LivroCaixaID = 1000,
                LivroCaixaID_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_LivroCaixaID_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorLivroCaixaIDInicial = 2500;
            var valorLivroCaixaIDFinal = 4750;
            var filtro = new FilterContaCorrente
            {
                LivroCaixaID = valorLivroCaixaIDInicial,
                LivroCaixaID_end = valorLivroCaixaIDFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.LivroCaixaID}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.LivroCaixaID}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorLivroCaixaIDInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorLivroCaixaIDFinal);
        }

        [Fact]
        public void WFiltro_LivroCaixaID_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                LivroCaixaID = 0,
                LivroCaixaID_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_LivroCaixaID_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                LivroCaixaID = 0,
                LivroCaixaID_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_LivroCaixaID_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                LivroCaixaID = 1500,
                LivroCaixaID_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.LivroCaixaID == int.MinValue) && !(filtro.LivroCaixaID_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.LivroCaixaID} BETWEEN @{DBContaCorrenteDicInfo.LivroCaixaID} AND @{DBContaCorrenteDicInfo.LivroCaixaID}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_LivroCaixaID_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                LivroCaixaID = 2000,
                LivroCaixaID_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.LivroCaixaID == int.MinValue) && filtro.LivroCaixaID_end == int.MinValue
            // Deve resultar em igualdade quando apenas LivroCaixaID tem valor válido
            resultado.Value.where.Should().Be($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.LivroCaixaID}] = @{DBContaCorrenteDicInfo.LivroCaixaID}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_LivroCaixaID_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                LivroCaixaID = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.LivroCaixaID Isolated Tests
        [Fact]
        public void WFiltro_LivroCaixaID_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                LivroCaixaID = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_LivroCaixaID_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorLivroCaixaID = 5;
            var filtro = new FilterContaCorrente
            {
                LivroCaixaID = valorLivroCaixaID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.LivroCaixaID}] = @{DBContaCorrenteDicInfo.LivroCaixaID}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContaCorrenteDicInfo.LivroCaixaID}");
            parametro.Value.Should().Be(valorLivroCaixaID);
        }

        [Fact]
        public void WFiltro_LivroCaixaID_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorLivroCaixaID = 0;
            var filtro = new FilterContaCorrente
            {
                LivroCaixaID = valorLivroCaixaID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBContaCorrenteDicInfo.LivroCaixaID}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorLivroCaixaID);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_LivroCaixaID_DiferentesValoresValidos_DeveProcessarCorretamente(int valorLivroCaixaID)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                LivroCaixaID = valorLivroCaixaID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorLivroCaixaID);
            resultado.Value.where.Should().Contain($"= @{DBContaCorrenteDicInfo.LivroCaixaID}");
        }

        [Fact]
        public void WFiltro_LivroCaixaID_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                LivroCaixaID = 1,
                Data = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.LivroCaixaID}");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_LivroCaixaID_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                LivroCaixaID = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_LivroCaixaID_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                LivroCaixaID = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_LivroCaixaID_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                LivroCaixaID = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_LivroCaixaID_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                LivroCaixaID = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.LivroCaixaID}]");
        }

        [Fact]
        public void WFiltro_LivroCaixaID_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                LivroCaixaID = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_LivroCaixaID_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                LivroCaixaID = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_LivroCaixaID_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                LivroCaixaID = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_LivroCaixaID_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorLivroCaixaID = 42;
            var filtro = new FilterContaCorrente
            {
                LivroCaixaID = valorLivroCaixaID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorLivroCaixaID);
        }

#endregion
        [Fact]
        public void WFiltro_LivroCaixaID_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                LivroCaixaID = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_LivroCaixaID_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorLivroCaixaID = 1;
            var filtro = new FilterContaCorrente
            {
                LivroCaixaID = valorLivroCaixaID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do LivroCaixaID
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.LivroCaixaID}] = @ctoLivroCaixaID");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@ctoLivroCaixaID");
            parametro.Value.Should().Be(valorLivroCaixaID);
        }

        [Fact]
        public void WFiltro_LivroCaixaID_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                LivroCaixaID = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@ctoLivroCaixaID");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_LivroCaixaID_DiferentesValores_DeveFuncionar(int valorLivroCaixaID)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                LivroCaixaID = valorLivroCaixaID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorLivroCaixaID);
        }

#region filtro.Processo_end Tests
        [Fact]
        public void WFiltro_Processo_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Processo_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Processo_end_QuandoTemValorPositivo_SemProcessoInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorProcessoEnd = 5000;
            var filtro = new FilterContaCorrente
            {
                Processo = int.MinValue, // Não define salário inicial
                Processo_end = valorProcessoEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Processo inicial válido, não deve incluir condição WHERE, mas o parâmetro Processo_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Processo_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Processo_end_QuandoSomenteValorInicial_SemProcessoEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorProcesso = 2500;
            var filtro = new FilterContaCorrente
            {
                Processo = valorProcesso,
                Processo_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.Processo}] = @{DBContaCorrenteDicInfo.Processo}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContaCorrenteDicInfo.Processo}");
            parametro.Value.Should().Be(valorProcesso);
        }

        [Fact]
        public void WFiltro_Processo_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorProcessoInicial = 1000;
            var valorProcessoFinal = 5000;
            var filtro = new FilterContaCorrente
            {
                Processo = valorProcessoInicial,
                Processo_end = valorProcessoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.Processo} BETWEEN @{DBContaCorrenteDicInfo.Processo} AND @{DBContaCorrenteDicInfo.Processo}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Processo}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Processo}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorProcessoInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorProcessoFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Processo_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Processo = valorInicial,
                Processo_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Processo}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Processo}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Processo_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Processo = 1000,
                Processo_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Processo}");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Processo_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Processo = 1000,
                Processo_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Processo_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Processo = 1000,
                Processo_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Processo_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Processo = 1000,
                Processo_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.Processo} BETWEEN");
        }

        [Fact]
        public void WFiltro_Processo_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Processo = 1000,
                Processo_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Processo_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Processo = 1000,
                Processo_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Processo_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorProcessoInicial = 2500;
            var valorProcessoFinal = 4750;
            var filtro = new FilterContaCorrente
            {
                Processo = valorProcessoInicial,
                Processo_end = valorProcessoFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Processo}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Processo}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorProcessoInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorProcessoFinal);
        }

        [Fact]
        public void WFiltro_Processo_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Processo = 0,
                Processo_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Processo_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Processo = 0,
                Processo_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Processo_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Processo = 1500,
                Processo_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Processo == int.MinValue) && !(filtro.Processo_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.Processo} BETWEEN @{DBContaCorrenteDicInfo.Processo} AND @{DBContaCorrenteDicInfo.Processo}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Processo_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Processo = 2000,
                Processo_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Processo == int.MinValue) && filtro.Processo_end == int.MinValue
            // Deve resultar em igualdade quando apenas Processo tem valor válido
            resultado.Value.where.Should().Be($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.Processo}] = @{DBContaCorrenteDicInfo.Processo}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Processo_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Processo = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Processo Isolated Tests
        [Fact]
        public void WFiltro_Processo_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Processo = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Processo_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorProcesso = 5;
            var filtro = new FilterContaCorrente
            {
                Processo = valorProcesso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.Processo}] = @{DBContaCorrenteDicInfo.Processo}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContaCorrenteDicInfo.Processo}");
            parametro.Value.Should().Be(valorProcesso);
        }

        [Fact]
        public void WFiltro_Processo_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorProcesso = 0;
            var filtro = new FilterContaCorrente
            {
                Processo = valorProcesso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBContaCorrenteDicInfo.Processo}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorProcesso);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Processo_DiferentesValoresValidos_DeveProcessarCorretamente(int valorProcesso)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Processo = valorProcesso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorProcesso);
            resultado.Value.where.Should().Contain($"= @{DBContaCorrenteDicInfo.Processo}");
        }

        [Fact]
        public void WFiltro_Processo_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Processo = 1,
                Data = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Processo}");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Processo_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Processo = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Processo_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Processo = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Processo_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Processo = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Processo_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Processo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.Processo}]");
        }

        [Fact]
        public void WFiltro_Processo_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Processo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Processo_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Processo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Processo_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Processo = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Processo_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorProcesso = 42;
            var filtro = new FilterContaCorrente
            {
                Processo = valorProcesso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorProcesso);
        }

#endregion
        [Fact]
        public void WFiltro_Processo_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Processo = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Processo_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorProcesso = 1;
            var filtro = new FilterContaCorrente
            {
                Processo = valorProcesso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Processo
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.Processo}] = @ctoProcesso");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@ctoProcesso");
            parametro.Value.Should().Be(valorProcesso);
        }

        [Fact]
        public void WFiltro_Processo_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Processo = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@ctoProcesso");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Processo_DiferentesValores_DeveFuncionar(int valorProcesso)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Processo = valorProcesso,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorProcesso);
        }

#region filtro.ParcelaX_end Tests
        [Fact]
        public void WFiltro_ParcelaX_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaX_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_ParcelaX_end_QuandoTemValorPositivo_SemParcelaXInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorParcelaXEnd = 5000;
            var filtro = new FilterContaCorrente
            {
                ParcelaX = int.MinValue, // Não define salário inicial
                ParcelaX_end = valorParcelaXEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há ParcelaX inicial válido, não deve incluir condição WHERE, mas o parâmetro ParcelaX_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // ParcelaX_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_ParcelaX_end_QuandoSomenteValorInicial_SemParcelaXEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorParcelaX = 2500;
            var filtro = new FilterContaCorrente
            {
                ParcelaX = valorParcelaX,
                ParcelaX_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.ParcelaX}] = @{DBContaCorrenteDicInfo.ParcelaX}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContaCorrenteDicInfo.ParcelaX}");
            parametro.Value.Should().Be(valorParcelaX);
        }

        [Fact]
        public void WFiltro_ParcelaX_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorParcelaXInicial = 1000;
            var valorParcelaXFinal = 5000;
            var filtro = new FilterContaCorrente
            {
                ParcelaX = valorParcelaXInicial,
                ParcelaX_end = valorParcelaXFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.ParcelaX} BETWEEN @{DBContaCorrenteDicInfo.ParcelaX} AND @{DBContaCorrenteDicInfo.ParcelaX}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.ParcelaX}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.ParcelaX}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorParcelaXInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorParcelaXFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_ParcelaX_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaX = valorInicial,
                ParcelaX_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.ParcelaX}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.ParcelaX}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_ParcelaX_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaX = 1000,
                ParcelaX_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.ParcelaX}");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_ParcelaX_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaX = 1000,
                ParcelaX_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_ParcelaX_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaX = 1000,
                ParcelaX_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_ParcelaX_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaX = 1000,
                ParcelaX_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.ParcelaX} BETWEEN");
        }

        [Fact]
        public void WFiltro_ParcelaX_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaX = 1000,
                ParcelaX_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_ParcelaX_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaX = 1000,
                ParcelaX_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_ParcelaX_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorParcelaXInicial = 2500;
            var valorParcelaXFinal = 4750;
            var filtro = new FilterContaCorrente
            {
                ParcelaX = valorParcelaXInicial,
                ParcelaX_end = valorParcelaXFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.ParcelaX}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.ParcelaX}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorParcelaXInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorParcelaXFinal);
        }

        [Fact]
        public void WFiltro_ParcelaX_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaX = 0,
                ParcelaX_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_ParcelaX_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaX = 0,
                ParcelaX_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_ParcelaX_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaX = 1500,
                ParcelaX_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.ParcelaX == int.MinValue) && !(filtro.ParcelaX_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.ParcelaX} BETWEEN @{DBContaCorrenteDicInfo.ParcelaX} AND @{DBContaCorrenteDicInfo.ParcelaX}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_ParcelaX_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaX = 2000,
                ParcelaX_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.ParcelaX == int.MinValue) && filtro.ParcelaX_end == int.MinValue
            // Deve resultar em igualdade quando apenas ParcelaX tem valor válido
            resultado.Value.where.Should().Be($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.ParcelaX}] = @{DBContaCorrenteDicInfo.ParcelaX}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_ParcelaX_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaX = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.ParcelaX Isolated Tests
        [Fact]
        public void WFiltro_ParcelaX_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaX = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_ParcelaX_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorParcelaX = 5;
            var filtro = new FilterContaCorrente
            {
                ParcelaX = valorParcelaX,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.ParcelaX}] = @{DBContaCorrenteDicInfo.ParcelaX}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContaCorrenteDicInfo.ParcelaX}");
            parametro.Value.Should().Be(valorParcelaX);
        }

        [Fact]
        public void WFiltro_ParcelaX_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorParcelaX = 0;
            var filtro = new FilterContaCorrente
            {
                ParcelaX = valorParcelaX,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBContaCorrenteDicInfo.ParcelaX}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorParcelaX);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_ParcelaX_DiferentesValoresValidos_DeveProcessarCorretamente(int valorParcelaX)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaX = valorParcelaX,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorParcelaX);
            resultado.Value.where.Should().Contain($"= @{DBContaCorrenteDicInfo.ParcelaX}");
        }

        [Fact]
        public void WFiltro_ParcelaX_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaX = 1,
                Data = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.ParcelaX}");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_ParcelaX_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaX = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_ParcelaX_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaX = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_ParcelaX_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaX = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_ParcelaX_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaX = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.ParcelaX}]");
        }

        [Fact]
        public void WFiltro_ParcelaX_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaX = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_ParcelaX_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaX = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_ParcelaX_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaX = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_ParcelaX_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorParcelaX = 42;
            var filtro = new FilterContaCorrente
            {
                ParcelaX = valorParcelaX,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorParcelaX);
        }

#endregion
        [Fact]
        public void WFiltro_ParcelaX_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaX = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_ParcelaX_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorParcelaX = 1;
            var filtro = new FilterContaCorrente
            {
                ParcelaX = valorParcelaX,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do ParcelaX
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.ParcelaX}] = @ctoParcelaX");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@ctoParcelaX");
            parametro.Value.Should().Be(valorParcelaX);
        }

        [Fact]
        public void WFiltro_ParcelaX_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaX = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@ctoParcelaX");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_ParcelaX_DiferentesValores_DeveFuncionar(int valorParcelaX)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaX = valorParcelaX,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorParcelaX);
        }

#region filtro.Cliente_end Tests
        [Fact]
        public void WFiltro_Cliente_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Cliente_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Cliente_end_QuandoTemValorPositivo_SemClienteInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorClienteEnd = 5000;
            var filtro = new FilterContaCorrente
            {
                Cliente = int.MinValue, // Não define salário inicial
                Cliente_end = valorClienteEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Cliente inicial válido, não deve incluir condição WHERE, mas o parâmetro Cliente_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Cliente_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Cliente_end_QuandoSomenteValorInicial_SemClienteEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorCliente = 2500;
            var filtro = new FilterContaCorrente
            {
                Cliente = valorCliente,
                Cliente_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.Cliente}] = @{DBContaCorrenteDicInfo.Cliente}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContaCorrenteDicInfo.Cliente}");
            parametro.Value.Should().Be(valorCliente);
        }

        [Fact]
        public void WFiltro_Cliente_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorClienteInicial = 1000;
            var valorClienteFinal = 5000;
            var filtro = new FilterContaCorrente
            {
                Cliente = valorClienteInicial,
                Cliente_end = valorClienteFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.Cliente} BETWEEN @{DBContaCorrenteDicInfo.Cliente} AND @{DBContaCorrenteDicInfo.Cliente}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Cliente}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Cliente}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorClienteInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorClienteFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Cliente_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Cliente = valorInicial,
                Cliente_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Cliente}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Cliente}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Cliente_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Cliente = 1000,
                Cliente_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Cliente}");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Cliente_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Cliente = 1000,
                Cliente_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Cliente_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Cliente = 1000,
                Cliente_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Cliente_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Cliente = 1000,
                Cliente_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.Cliente} BETWEEN");
        }

        [Fact]
        public void WFiltro_Cliente_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Cliente = 1000,
                Cliente_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Cliente_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Cliente = 1000,
                Cliente_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Cliente_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorClienteInicial = 2500;
            var valorClienteFinal = 4750;
            var filtro = new FilterContaCorrente
            {
                Cliente = valorClienteInicial,
                Cliente_end = valorClienteFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Cliente}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Cliente}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorClienteInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorClienteFinal);
        }

        [Fact]
        public void WFiltro_Cliente_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Cliente = 0,
                Cliente_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Cliente_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Cliente = 0,
                Cliente_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Cliente_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Cliente = 1500,
                Cliente_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Cliente == int.MinValue) && !(filtro.Cliente_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.Cliente} BETWEEN @{DBContaCorrenteDicInfo.Cliente} AND @{DBContaCorrenteDicInfo.Cliente}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Cliente_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Cliente = 2000,
                Cliente_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Cliente == int.MinValue) && filtro.Cliente_end == int.MinValue
            // Deve resultar em igualdade quando apenas Cliente tem valor válido
            resultado.Value.where.Should().Be($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.Cliente}] = @{DBContaCorrenteDicInfo.Cliente}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Cliente_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Cliente = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Cliente Isolated Tests
        [Fact]
        public void WFiltro_Cliente_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Cliente = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Cliente_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorCliente = 5;
            var filtro = new FilterContaCorrente
            {
                Cliente = valorCliente,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.Cliente}] = @{DBContaCorrenteDicInfo.Cliente}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContaCorrenteDicInfo.Cliente}");
            parametro.Value.Should().Be(valorCliente);
        }

        [Fact]
        public void WFiltro_Cliente_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorCliente = 0;
            var filtro = new FilterContaCorrente
            {
                Cliente = valorCliente,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBContaCorrenteDicInfo.Cliente}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCliente);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Cliente_DiferentesValoresValidos_DeveProcessarCorretamente(int valorCliente)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Cliente = valorCliente,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCliente);
            resultado.Value.where.Should().Contain($"= @{DBContaCorrenteDicInfo.Cliente}");
        }

        [Fact]
        public void WFiltro_Cliente_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Cliente = 1,
                Data = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Cliente}");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Cliente_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Cliente = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Cliente_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Cliente = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Cliente_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Cliente = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Cliente_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Cliente = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.Cliente}]");
        }

        [Fact]
        public void WFiltro_Cliente_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Cliente = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Cliente_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Cliente = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Cliente_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Cliente = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Cliente_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorCliente = 42;
            var filtro = new FilterContaCorrente
            {
                Cliente = valorCliente,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorCliente);
        }

#endregion
        [Fact]
        public void WFiltro_Cliente_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Cliente = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Cliente_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorCliente = 1;
            var filtro = new FilterContaCorrente
            {
                Cliente = valorCliente,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Cliente
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.Cliente}] = @ctoCliente");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@ctoCliente");
            parametro.Value.Should().Be(valorCliente);
        }

        [Fact]
        public void WFiltro_Cliente_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Cliente = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@ctoCliente");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Cliente_DiferentesValores_DeveFuncionar(int valorCliente)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Cliente = valorCliente,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCliente);
        }

#region filtro.IDHTrab_end Tests
        [Fact]
        public void WFiltro_IDHTrab_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDHTrab_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_IDHTrab_end_QuandoTemValorPositivo_SemIDHTrabInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorIDHTrabEnd = 5000;
            var filtro = new FilterContaCorrente
            {
                IDHTrab = int.MinValue, // Não define salário inicial
                IDHTrab_end = valorIDHTrabEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há IDHTrab inicial válido, não deve incluir condição WHERE, mas o parâmetro IDHTrab_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // IDHTrab_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_IDHTrab_end_QuandoSomenteValorInicial_SemIDHTrabEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorIDHTrab = 2500;
            var filtro = new FilterContaCorrente
            {
                IDHTrab = valorIDHTrab,
                IDHTrab_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.IDHTrab}] = @{DBContaCorrenteDicInfo.IDHTrab}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContaCorrenteDicInfo.IDHTrab}");
            parametro.Value.Should().Be(valorIDHTrab);
        }

        [Fact]
        public void WFiltro_IDHTrab_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorIDHTrabInicial = 1000;
            var valorIDHTrabFinal = 5000;
            var filtro = new FilterContaCorrente
            {
                IDHTrab = valorIDHTrabInicial,
                IDHTrab_end = valorIDHTrabFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.IDHTrab} BETWEEN @{DBContaCorrenteDicInfo.IDHTrab} AND @{DBContaCorrenteDicInfo.IDHTrab}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.IDHTrab}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.IDHTrab}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorIDHTrabInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorIDHTrabFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_IDHTrab_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDHTrab = valorInicial,
                IDHTrab_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.IDHTrab}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.IDHTrab}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_IDHTrab_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDHTrab = 1000,
                IDHTrab_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.IDHTrab}");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_IDHTrab_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDHTrab = 1000,
                IDHTrab_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_IDHTrab_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDHTrab = 1000,
                IDHTrab_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_IDHTrab_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDHTrab = 1000,
                IDHTrab_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.IDHTrab} BETWEEN");
        }

        [Fact]
        public void WFiltro_IDHTrab_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDHTrab = 1000,
                IDHTrab_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_IDHTrab_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDHTrab = 1000,
                IDHTrab_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_IDHTrab_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorIDHTrabInicial = 2500;
            var valorIDHTrabFinal = 4750;
            var filtro = new FilterContaCorrente
            {
                IDHTrab = valorIDHTrabInicial,
                IDHTrab_end = valorIDHTrabFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.IDHTrab}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.IDHTrab}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorIDHTrabInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorIDHTrabFinal);
        }

        [Fact]
        public void WFiltro_IDHTrab_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDHTrab = 0,
                IDHTrab_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_IDHTrab_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDHTrab = 0,
                IDHTrab_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_IDHTrab_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDHTrab = 1500,
                IDHTrab_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.IDHTrab == int.MinValue) && !(filtro.IDHTrab_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.IDHTrab} BETWEEN @{DBContaCorrenteDicInfo.IDHTrab} AND @{DBContaCorrenteDicInfo.IDHTrab}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_IDHTrab_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDHTrab = 2000,
                IDHTrab_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.IDHTrab == int.MinValue) && filtro.IDHTrab_end == int.MinValue
            // Deve resultar em igualdade quando apenas IDHTrab tem valor válido
            resultado.Value.where.Should().Be($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.IDHTrab}] = @{DBContaCorrenteDicInfo.IDHTrab}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_IDHTrab_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDHTrab = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.IDHTrab Isolated Tests
        [Fact]
        public void WFiltro_IDHTrab_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDHTrab = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_IDHTrab_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorIDHTrab = 5;
            var filtro = new FilterContaCorrente
            {
                IDHTrab = valorIDHTrab,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.IDHTrab}] = @{DBContaCorrenteDicInfo.IDHTrab}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContaCorrenteDicInfo.IDHTrab}");
            parametro.Value.Should().Be(valorIDHTrab);
        }

        [Fact]
        public void WFiltro_IDHTrab_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorIDHTrab = 0;
            var filtro = new FilterContaCorrente
            {
                IDHTrab = valorIDHTrab,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBContaCorrenteDicInfo.IDHTrab}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorIDHTrab);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_IDHTrab_DiferentesValoresValidos_DeveProcessarCorretamente(int valorIDHTrab)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDHTrab = valorIDHTrab,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorIDHTrab);
            resultado.Value.where.Should().Contain($"= @{DBContaCorrenteDicInfo.IDHTrab}");
        }

        [Fact]
        public void WFiltro_IDHTrab_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDHTrab = 1,
                Data = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.IDHTrab}");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_IDHTrab_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDHTrab = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_IDHTrab_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDHTrab = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_IDHTrab_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDHTrab = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_IDHTrab_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDHTrab = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.IDHTrab}]");
        }

        [Fact]
        public void WFiltro_IDHTrab_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDHTrab = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_IDHTrab_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDHTrab = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_IDHTrab_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDHTrab = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_IDHTrab_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorIDHTrab = 42;
            var filtro = new FilterContaCorrente
            {
                IDHTrab = valorIDHTrab,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorIDHTrab);
        }

#endregion
        [Fact]
        public void WFiltro_IDHTrab_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDHTrab = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_IDHTrab_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorIDHTrab = 1;
            var filtro = new FilterContaCorrente
            {
                IDHTrab = valorIDHTrab,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do IDHTrab
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.IDHTrab}] = @ctoIDHTrab");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@ctoIDHTrab");
            parametro.Value.Should().Be(valorIDHTrab);
        }

        [Fact]
        public void WFiltro_IDHTrab_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDHTrab = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@ctoIDHTrab");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_IDHTrab_DiferentesValores_DeveFuncionar(int valorIDHTrab)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                IDHTrab = valorIDHTrab,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorIDHTrab);
        }

#region filtro.NroParcelas_end Tests
        [Fact]
        public void WFiltro_NroParcelas_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                NroParcelas_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_NroParcelas_end_QuandoTemValorPositivo_SemNroParcelasInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorNroParcelasEnd = 5000;
            var filtro = new FilterContaCorrente
            {
                NroParcelas = int.MinValue, // Não define salário inicial
                NroParcelas_end = valorNroParcelasEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há NroParcelas inicial válido, não deve incluir condição WHERE, mas o parâmetro NroParcelas_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // NroParcelas_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_NroParcelas_end_QuandoSomenteValorInicial_SemNroParcelasEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorNroParcelas = 2500;
            var filtro = new FilterContaCorrente
            {
                NroParcelas = valorNroParcelas,
                NroParcelas_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.NroParcelas}] = @{DBContaCorrenteDicInfo.NroParcelas}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContaCorrenteDicInfo.NroParcelas}");
            parametro.Value.Should().Be(valorNroParcelas);
        }

        [Fact]
        public void WFiltro_NroParcelas_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorNroParcelasInicial = 1000;
            var valorNroParcelasFinal = 5000;
            var filtro = new FilterContaCorrente
            {
                NroParcelas = valorNroParcelasInicial,
                NroParcelas_end = valorNroParcelasFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.NroParcelas} BETWEEN @{DBContaCorrenteDicInfo.NroParcelas} AND @{DBContaCorrenteDicInfo.NroParcelas}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.NroParcelas}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.NroParcelas}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorNroParcelasInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorNroParcelasFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_NroParcelas_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                NroParcelas = valorInicial,
                NroParcelas_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.NroParcelas}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.NroParcelas}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_NroParcelas_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                NroParcelas = 1000,
                NroParcelas_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.NroParcelas}");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_NroParcelas_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                NroParcelas = 1000,
                NroParcelas_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_NroParcelas_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                NroParcelas = 1000,
                NroParcelas_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_NroParcelas_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                NroParcelas = 1000,
                NroParcelas_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.NroParcelas} BETWEEN");
        }

        [Fact]
        public void WFiltro_NroParcelas_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                NroParcelas = 1000,
                NroParcelas_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_NroParcelas_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                NroParcelas = 1000,
                NroParcelas_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_NroParcelas_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorNroParcelasInicial = 2500;
            var valorNroParcelasFinal = 4750;
            var filtro = new FilterContaCorrente
            {
                NroParcelas = valorNroParcelasInicial,
                NroParcelas_end = valorNroParcelasFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.NroParcelas}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.NroParcelas}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorNroParcelasInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorNroParcelasFinal);
        }

        [Fact]
        public void WFiltro_NroParcelas_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                NroParcelas = 0,
                NroParcelas_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_NroParcelas_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                NroParcelas = 0,
                NroParcelas_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_NroParcelas_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                NroParcelas = 1500,
                NroParcelas_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.NroParcelas == int.MinValue) && !(filtro.NroParcelas_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.NroParcelas} BETWEEN @{DBContaCorrenteDicInfo.NroParcelas} AND @{DBContaCorrenteDicInfo.NroParcelas}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_NroParcelas_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                NroParcelas = 2000,
                NroParcelas_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.NroParcelas == int.MinValue) && filtro.NroParcelas_end == int.MinValue
            // Deve resultar em igualdade quando apenas NroParcelas tem valor válido
            resultado.Value.where.Should().Be($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.NroParcelas}] = @{DBContaCorrenteDicInfo.NroParcelas}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_NroParcelas_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                NroParcelas = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.NroParcelas Isolated Tests
        [Fact]
        public void WFiltro_NroParcelas_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                NroParcelas = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_NroParcelas_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorNroParcelas = 5;
            var filtro = new FilterContaCorrente
            {
                NroParcelas = valorNroParcelas,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.NroParcelas}] = @{DBContaCorrenteDicInfo.NroParcelas}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContaCorrenteDicInfo.NroParcelas}");
            parametro.Value.Should().Be(valorNroParcelas);
        }

        [Fact]
        public void WFiltro_NroParcelas_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorNroParcelas = 0;
            var filtro = new FilterContaCorrente
            {
                NroParcelas = valorNroParcelas,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBContaCorrenteDicInfo.NroParcelas}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorNroParcelas);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_NroParcelas_DiferentesValoresValidos_DeveProcessarCorretamente(int valorNroParcelas)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                NroParcelas = valorNroParcelas,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorNroParcelas);
            resultado.Value.where.Should().Contain($"= @{DBContaCorrenteDicInfo.NroParcelas}");
        }

        [Fact]
        public void WFiltro_NroParcelas_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                NroParcelas = 1,
                Data = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.NroParcelas}");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_NroParcelas_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                NroParcelas = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_NroParcelas_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                NroParcelas = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_NroParcelas_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                NroParcelas = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_NroParcelas_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                NroParcelas = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.NroParcelas}]");
        }

        [Fact]
        public void WFiltro_NroParcelas_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                NroParcelas = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_NroParcelas_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                NroParcelas = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_NroParcelas_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                NroParcelas = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_NroParcelas_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorNroParcelas = 42;
            var filtro = new FilterContaCorrente
            {
                NroParcelas = valorNroParcelas,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorNroParcelas);
        }

#endregion
        [Fact]
        public void WFiltro_NroParcelas_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                NroParcelas = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_NroParcelas_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorNroParcelas = 1;
            var filtro = new FilterContaCorrente
            {
                NroParcelas = valorNroParcelas,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do NroParcelas
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.NroParcelas}] = @ctoNroParcelas");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@ctoNroParcelas");
            parametro.Value.Should().Be(valorNroParcelas);
        }

        [Fact]
        public void WFiltro_NroParcelas_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                NroParcelas = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@ctoNroParcelas");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_NroParcelas_DiferentesValores_DeveFuncionar(int valorNroParcelas)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                NroParcelas = valorNroParcelas,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorNroParcelas);
        }

#region filtro.ParcelaPrincipalID_end Tests
        [Fact]
        public void WFiltro_ParcelaPrincipalID_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaPrincipalID_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_ParcelaPrincipalID_end_QuandoTemValorPositivo_SemParcelaPrincipalIDInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorParcelaPrincipalIDEnd = 5000;
            var filtro = new FilterContaCorrente
            {
                ParcelaPrincipalID = int.MinValue, // Não define salário inicial
                ParcelaPrincipalID_end = valorParcelaPrincipalIDEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há ParcelaPrincipalID inicial válido, não deve incluir condição WHERE, mas o parâmetro ParcelaPrincipalID_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // ParcelaPrincipalID_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_ParcelaPrincipalID_end_QuandoSomenteValorInicial_SemParcelaPrincipalIDEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorParcelaPrincipalID = 2500;
            var filtro = new FilterContaCorrente
            {
                ParcelaPrincipalID = valorParcelaPrincipalID,
                ParcelaPrincipalID_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.ParcelaPrincipalID}] = @{DBContaCorrenteDicInfo.ParcelaPrincipalID}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContaCorrenteDicInfo.ParcelaPrincipalID}");
            parametro.Value.Should().Be(valorParcelaPrincipalID);
        }

        [Fact]
        public void WFiltro_ParcelaPrincipalID_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorParcelaPrincipalIDInicial = 1000;
            var valorParcelaPrincipalIDFinal = 5000;
            var filtro = new FilterContaCorrente
            {
                ParcelaPrincipalID = valorParcelaPrincipalIDInicial,
                ParcelaPrincipalID_end = valorParcelaPrincipalIDFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.ParcelaPrincipalID} BETWEEN @{DBContaCorrenteDicInfo.ParcelaPrincipalID} AND @{DBContaCorrenteDicInfo.ParcelaPrincipalID}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.ParcelaPrincipalID}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.ParcelaPrincipalID}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorParcelaPrincipalIDInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorParcelaPrincipalIDFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_ParcelaPrincipalID_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaPrincipalID = valorInicial,
                ParcelaPrincipalID_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.ParcelaPrincipalID}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.ParcelaPrincipalID}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_ParcelaPrincipalID_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaPrincipalID = 1000,
                ParcelaPrincipalID_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.ParcelaPrincipalID}");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_ParcelaPrincipalID_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaPrincipalID = 1000,
                ParcelaPrincipalID_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_ParcelaPrincipalID_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaPrincipalID = 1000,
                ParcelaPrincipalID_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_ParcelaPrincipalID_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaPrincipalID = 1000,
                ParcelaPrincipalID_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.ParcelaPrincipalID} BETWEEN");
        }

        [Fact]
        public void WFiltro_ParcelaPrincipalID_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaPrincipalID = 1000,
                ParcelaPrincipalID_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_ParcelaPrincipalID_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaPrincipalID = 1000,
                ParcelaPrincipalID_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_ParcelaPrincipalID_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorParcelaPrincipalIDInicial = 2500;
            var valorParcelaPrincipalIDFinal = 4750;
            var filtro = new FilterContaCorrente
            {
                ParcelaPrincipalID = valorParcelaPrincipalIDInicial,
                ParcelaPrincipalID_end = valorParcelaPrincipalIDFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.ParcelaPrincipalID}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.ParcelaPrincipalID}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorParcelaPrincipalIDInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorParcelaPrincipalIDFinal);
        }

        [Fact]
        public void WFiltro_ParcelaPrincipalID_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaPrincipalID = 0,
                ParcelaPrincipalID_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_ParcelaPrincipalID_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaPrincipalID = 0,
                ParcelaPrincipalID_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_ParcelaPrincipalID_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaPrincipalID = 1500,
                ParcelaPrincipalID_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.ParcelaPrincipalID == int.MinValue) && !(filtro.ParcelaPrincipalID_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.ParcelaPrincipalID} BETWEEN @{DBContaCorrenteDicInfo.ParcelaPrincipalID} AND @{DBContaCorrenteDicInfo.ParcelaPrincipalID}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_ParcelaPrincipalID_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaPrincipalID = 2000,
                ParcelaPrincipalID_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.ParcelaPrincipalID == int.MinValue) && filtro.ParcelaPrincipalID_end == int.MinValue
            // Deve resultar em igualdade quando apenas ParcelaPrincipalID tem valor válido
            resultado.Value.where.Should().Be($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.ParcelaPrincipalID}] = @{DBContaCorrenteDicInfo.ParcelaPrincipalID}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_ParcelaPrincipalID_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaPrincipalID = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.ParcelaPrincipalID Isolated Tests
        [Fact]
        public void WFiltro_ParcelaPrincipalID_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaPrincipalID = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_ParcelaPrincipalID_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorParcelaPrincipalID = 5;
            var filtro = new FilterContaCorrente
            {
                ParcelaPrincipalID = valorParcelaPrincipalID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.ParcelaPrincipalID}] = @{DBContaCorrenteDicInfo.ParcelaPrincipalID}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContaCorrenteDicInfo.ParcelaPrincipalID}");
            parametro.Value.Should().Be(valorParcelaPrincipalID);
        }

        [Fact]
        public void WFiltro_ParcelaPrincipalID_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorParcelaPrincipalID = 0;
            var filtro = new FilterContaCorrente
            {
                ParcelaPrincipalID = valorParcelaPrincipalID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBContaCorrenteDicInfo.ParcelaPrincipalID}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorParcelaPrincipalID);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_ParcelaPrincipalID_DiferentesValoresValidos_DeveProcessarCorretamente(int valorParcelaPrincipalID)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaPrincipalID = valorParcelaPrincipalID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorParcelaPrincipalID);
            resultado.Value.where.Should().Contain($"= @{DBContaCorrenteDicInfo.ParcelaPrincipalID}");
        }

        [Fact]
        public void WFiltro_ParcelaPrincipalID_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaPrincipalID = 1,
                Data = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.ParcelaPrincipalID}");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_ParcelaPrincipalID_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaPrincipalID = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_ParcelaPrincipalID_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaPrincipalID = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_ParcelaPrincipalID_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaPrincipalID = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_ParcelaPrincipalID_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaPrincipalID = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.ParcelaPrincipalID}]");
        }

        [Fact]
        public void WFiltro_ParcelaPrincipalID_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaPrincipalID = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_ParcelaPrincipalID_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaPrincipalID = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_ParcelaPrincipalID_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaPrincipalID = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_ParcelaPrincipalID_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorParcelaPrincipalID = 42;
            var filtro = new FilterContaCorrente
            {
                ParcelaPrincipalID = valorParcelaPrincipalID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorParcelaPrincipalID);
        }

#endregion
        [Fact]
        public void WFiltro_ParcelaPrincipalID_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaPrincipalID = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_ParcelaPrincipalID_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorParcelaPrincipalID = 1;
            var filtro = new FilterContaCorrente
            {
                ParcelaPrincipalID = valorParcelaPrincipalID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do ParcelaPrincipalID
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.ParcelaPrincipalID}] = @ctoParcelaPrincipalID");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@ctoParcelaPrincipalID");
            parametro.Value.Should().Be(valorParcelaPrincipalID);
        }

        [Fact]
        public void WFiltro_ParcelaPrincipalID_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaPrincipalID = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@ctoParcelaPrincipalID");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_ParcelaPrincipalID_DiferentesValores_DeveFuncionar(int valorParcelaPrincipalID)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ParcelaPrincipalID = valorParcelaPrincipalID,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorParcelaPrincipalID);
        }

#region filtro.Codigo_filtro_end Tests
        [Fact]
        public void WFiltro_Codigo_filtro_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Codigo_filtro_end = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Codigo_filtro_end_QuandoTemValorPositivo_SemCodigo_filtroInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorCodigo_filtroEnd = 5000;
            var filtro = new FilterContaCorrente
            {
                Codigo_filtro = int.MinValue, // Não define salário inicial
                Codigo_filtro_end = valorCodigo_filtroEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Codigo_filtro inicial válido, não deve incluir condição WHERE, mas o parâmetro Codigo_filtro_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Codigo_filtro_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Codigo_filtro_end_QuandoSomenteValorInicial_SemCodigo_filtroEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorCodigo_filtro = 2500;
            var filtro = new FilterContaCorrente
            {
                Codigo_filtro = valorCodigo_filtro,
                Codigo_filtro_end = int.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.CampoCodigo}] = @{DBContaCorrenteDicInfo.CampoCodigo}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContaCorrenteDicInfo.CampoCodigo}");
            parametro.Value.Should().Be(valorCodigo_filtro);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorCodigo_filtroInicial = 1000;
            var valorCodigo_filtroFinal = 5000;
            var filtro = new FilterContaCorrente
            {
                Codigo_filtro = valorCodigo_filtroInicial,
                Codigo_filtro_end = valorCodigo_filtroFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.CampoCodigo} BETWEEN @{DBContaCorrenteDicInfo.CampoCodigo} AND @{DBContaCorrenteDicInfo.CampoCodigo}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.CampoCodigo}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.CampoCodigo}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorCodigo_filtroInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorCodigo_filtroFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500, 7500)]
        [InlineData(10000, 50000)]
        public void WFiltro_Codigo_filtro_RangeDiferentesValores_DeveProcessarCorretamente(int valorInicial, int valorFinal)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Codigo_filtro = valorInicial,
                Codigo_filtro_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.CampoCodigo}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.CampoCodigo}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.CampoCodigo}");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.CampoCodigo} BETWEEN");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Codigo_filtro = 1000,
                Codigo_filtro_end = 5000,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorCodigo_filtroInicial = 2500;
            var valorCodigo_filtroFinal = 4750;
            var filtro = new FilterContaCorrente
            {
                Codigo_filtro = valorCodigo_filtroInicial,
                Codigo_filtro_end = valorCodigo_filtroFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.CampoCodigo}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.CampoCodigo}_end");
            parametroInicial.Value.Should().BeOfType<int>();
            parametroInicial.Value.Should().Be(valorCodigo_filtroInicial);
            parametroFinal.Value.Should().BeOfType<int>();
            parametroFinal.Value.Should().Be(valorCodigo_filtroFinal);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Codigo_filtro = 0,
                Codigo_filtro_end = 0,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Codigo_filtro = 0,
                Codigo_filtro_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Codigo_filtro = 1500,
                Codigo_filtro_end = 4500,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Codigo_filtro == int.MinValue) && !(filtro.Codigo_filtro_end == int.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.CampoCodigo} BETWEEN @{DBContaCorrenteDicInfo.CampoCodigo} AND @{DBContaCorrenteDicInfo.CampoCodigo}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Codigo_filtro = 2000,
                Codigo_filtro_end = int.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Codigo_filtro == int.MinValue) && filtro.Codigo_filtro_end == int.MinValue
            // Deve resultar em igualdade quando apenas Codigo_filtro tem valor válido
            resultado.Value.where.Should().Be($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.CampoCodigo}] = @{DBContaCorrenteDicInfo.CampoCodigo}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData(int.MaxValue)]
        [InlineData(0)]
        [InlineData(-1)]
        public void WFiltro_Codigo_filtro_ComValoresExtremos_DeveProcessarCorretamente(int valorExtremo)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Codigo_filtro = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
        }

#region filtro.Codigo_filtro Isolated Tests
        [Fact]
        public void WFiltro_Codigo_filtro_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Codigo_filtro = int.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorCodigo_filtro = 5;
            var filtro = new FilterContaCorrente
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.CampoCodigo}] = @{DBContaCorrenteDicInfo.CampoCodigo}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContaCorrenteDicInfo.CampoCodigo}");
            parametro.Value.Should().Be(valorCodigo_filtro);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorCodigo_filtro = 0;
            var filtro = new FilterContaCorrente
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBContaCorrenteDicInfo.CampoCodigo}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCodigo_filtro);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Codigo_filtro_DiferentesValoresValidos_DeveProcessarCorretamente(int valorCodigo_filtro)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCodigo_filtro);
            resultado.Value.where.Should().Contain($"= @{DBContaCorrenteDicInfo.CampoCodigo}");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Codigo_filtro = 1,
                Data = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.CampoCodigo}");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Codigo_filtro = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Codigo_filtro = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Codigo_filtro = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Codigo_filtro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.CampoCodigo}]");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Codigo_filtro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Codigo_filtro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Codigo_filtro = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            int valorCodigo_filtro = 42;
            var filtro = new FilterContaCorrente
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<int>();
            parametro.Value.Should().Be(valorCodigo_filtro);
        }

#endregion
        [Fact]
        public void WFiltro_Codigo_filtro_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Codigo_filtro = int.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Codigo_filtro_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            var valorCodigo_filtro = 1;
            var filtro = new FilterContaCorrente
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Codigo_filtro
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.CampoCodigo}] = @{DBContaCorrenteDicInfo.CampoCodigo}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContaCorrenteDicInfo.CampoCodigo}");
            parametro.Value.Should().Be(valorCodigo_filtro);
        }

        [Fact]
        public void WFiltro_Codigo_filtro_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Codigo_filtro = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.CampoCodigo}");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1)]
        [InlineData(999)]
        public void WFiltro_Codigo_filtro_DiferentesValores_DeveFuncionar(int valorCodigo_filtro)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Codigo_filtro = valorCodigo_filtro,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorCodigo_filtro);
        }

#endregion
#region Decimal Tests
#region filtro.Valor_end Tests
        [Fact]
        public void WFiltro_Valor_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Valor_end = decimal.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Valor_end_QuandoTemValorPositivo_SemValorInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorValorEnd = 5000m;
            var filtro = new FilterContaCorrente
            {
                Valor = decimal.MinValue, // Não define salário inicial
                Valor_end = valorValorEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há Valor inicial válido, não deve incluir condição WHERE, mas o parâmetro Valor_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // Valor_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_Valor_end_QuandoSomenteValorInicial_SemValorEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorValor = 2500m;
            var filtro = new FilterContaCorrente
            {
                Valor = valorValor,
                Valor_end = decimal.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.Valor}] = @{DBContaCorrenteDicInfo.Valor}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContaCorrenteDicInfo.Valor}");
            parametro.Value.Should().Be(valorValor);
        }

        [Fact]
        public void WFiltro_Valor_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorValorInicial = 1000m;
            var valorValorFinal = 5000m;
            var filtro = new FilterContaCorrente
            {
                Valor = valorValorInicial,
                Valor_end = valorValorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.Valor} BETWEEN @{DBContaCorrenteDicInfo.Valor} AND @{DBContaCorrenteDicInfo.Valor}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Valor}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Valor}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorValorInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorValorFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500.50, 7500.75)]
        [InlineData(10000, 50000)]
        public void WFiltro_Valor_RangeDiferentesValores_DeveProcessarCorretamente(decimal valorInicial, decimal valorFinal)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Valor = valorInicial,
                Valor_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Valor}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Valor}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_Valor_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Valor = 1000m,
                Valor_end = 5000m,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Valor}");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Valor_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Valor = 1000m,
                Valor_end = 5000m,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_Valor_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Valor = 1000m,
                Valor_end = 5000m,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Valor_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Valor = 1000m,
                Valor_end = 5000m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.Valor} BETWEEN");
        }

        [Fact]
        public void WFiltro_Valor_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Valor = 1000m,
                Valor_end = 5000m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Valor_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Valor = 1000m,
                Valor_end = 5000m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Valor_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorValorInicial = 1500.50m;
            var valorValorFinal = 3750.75m;
            var filtro = new FilterContaCorrente
            {
                Valor = valorValorInicial,
                Valor_end = valorValorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Valor}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Valor}_end");
            parametroInicial.Value.Should().BeOfType<decimal>();
            parametroInicial.Value.Should().Be(valorValorInicial);
            parametroFinal.Value.Should().BeOfType<decimal>();
            parametroFinal.Value.Should().Be(valorValorFinal);
        }

        [Fact]
        public void WFiltro_Valor_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Valor = 0m,
                Valor_end = 0m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Valor_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Valor = 0m,
                Valor_end = decimal.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_Valor_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Valor = 1500m,
                Valor_end = 4500m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Valor == decimal.MinValue) && !(filtro.Valor_end == decimal.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.Valor} BETWEEN @{DBContaCorrenteDicInfo.Valor} AND @{DBContaCorrenteDicInfo.Valor}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Valor_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Valor = 2000m,
                Valor_end = decimal.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.Valor == decimal.MinValue) && filtro.Valor_end == decimal.MinValue
            // Deve resultar em igualdade quando apenas Valor tem valor válido
            resultado.Value.where.Should().Be($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.Valor}] = @{DBContaCorrenteDicInfo.Valor}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData("79228162514264337593543950335")]
        [InlineData("-79228162514264337593543950335")] // MinValue é usado como "não filtrar"
        [InlineData("0.01")]
        [InlineData("-999999.99")]
        public void WFiltro_Valor_ComValoresExtremos_DeveProcessarCorretamente(string valorExtremoStr)
        {
            // Arrange
            var valorExtremo = decimal.Parse(valorExtremoStr, System.Globalization.CultureInfo.InvariantCulture);
            var filtro = new FilterContaCorrente
            {
                Valor = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(valorExtremo == decimal.MinValue ? 0 : 1);
            if (valorExtremo != decimal.MinValue)
            {
                resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
            }
        }

#region filtro.Valor Isolated Tests
        [Fact]
        public void WFiltro_Valor_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Valor = decimal.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_Valor_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorValor = 5;
            var filtro = new FilterContaCorrente
            {
                Valor = valorValor,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.Valor}] = @{DBContaCorrenteDicInfo.Valor}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContaCorrenteDicInfo.Valor}");
            parametro.Value.Should().Be(valorValor);
        }

        [Fact]
        public void WFiltro_Valor_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorValor = 0;
            var filtro = new FilterContaCorrente
            {
                Valor = valorValor,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBContaCorrenteDicInfo.Valor}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorValor);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_Valor_DiferentesValoresValidos_DeveProcessarCorretamente(decimal valorValor)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Valor = valorValor,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorValor);
            resultado.Value.where.Should().Contain($"= @{DBContaCorrenteDicInfo.Valor}");
        }

        [Fact]
        public void WFiltro_Valor_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Valor = 1,
                Data = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Valor}");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Valor_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Valor = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_Valor_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Valor = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Valor_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Valor = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_Valor_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Valor = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.Valor}]");
        }

        [Fact]
        public void WFiltro_Valor_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Valor = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_Valor_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Valor = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_Valor_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Valor = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_Valor_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            var valorValor = (decimal)42.12;
            var filtro = new FilterContaCorrente
            {
                Valor = valorValor,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<decimal>();
            parametro.Value.Should().Be(valorValor);
        }

#endregion
        [Fact]
        public void WFiltro_Valor_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Valor = decimal.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_Valor_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            decimal valorValor = 1;
            var filtro = new FilterContaCorrente
            {
                Valor = valorValor,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do Valor
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.Valor}] = @ctoValor");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@ctoValor");
            parametro.Value.Should().Be(valorValor);
        }

        [Fact]
        public void WFiltro_Valor_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Valor = (decimal)1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@ctoValor");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1.2)]
        [InlineData(999.40)]
        public void WFiltro_Valor_DiferentesValores_DeveFuncionar(decimal valorValor)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Valor = valorValor,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorValor);
        }

#region filtro.ValorPrincipal_end Tests
        [Fact]
        public void WFiltro_ValorPrincipal_end_QuandoDecimalMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ValorPrincipal_end = decimal.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_ValorPrincipal_end_QuandoTemValorPositivo_SemValorPrincipalInicial_DeveAdicionarParametroMasNaoCondicionaWhere()
        {
            // Arrange
            var valorValorPrincipalEnd = 5000m;
            var filtro = new FilterContaCorrente
            {
                ValorPrincipal = decimal.MinValue, // Não define salário inicial
                ValorPrincipal_end = valorValorPrincipalEnd,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como não há ValorPrincipal inicial válido, não deve incluir condição WHERE, mas o parâmetro ValorPrincipal_end é adicionado
            resultado.Value.where.Should().BeEmpty();
            resultado.Value.parametros.Should().HaveCount(0); // ValorPrincipal_end parameter is added
            var parametro = resultado.Value.parametros?.FirstOrDefault();
            parametro.Should().BeNull();
        }

        [Fact]
        public void WFiltro_ValorPrincipal_end_QuandoSomenteValorInicial_SemValorPrincipalEnd_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var valorValorPrincipal = 2500m;
            var filtro = new FilterContaCorrente
            {
                ValorPrincipal = valorValorPrincipal,
                ValorPrincipal_end = decimal.MinValue, // Não define salário final
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.ValorPrincipal}] = @{DBContaCorrenteDicInfo.ValorPrincipal}");
            resultado.Value.where.Should().NotContain("BETWEEN");
            // Deve ter exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContaCorrenteDicInfo.ValorPrincipal}");
            parametro.Value.Should().Be(valorValorPrincipal);
        }

        [Fact]
        public void WFiltro_ValorPrincipal_end_QuandoTemAmbosValores_DeveUsarOperadorBETWEEN()
        {
            // Arrange
            var valorValorPrincipalInicial = 1000m;
            var valorValorPrincipalFinal = 5000m;
            var filtro = new FilterContaCorrente
            {
                ValorPrincipal = valorValorPrincipalInicial,
                ValorPrincipal_end = valorValorPrincipalFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.ValorPrincipal} BETWEEN @{DBContaCorrenteDicInfo.ValorPrincipal} AND @{DBContaCorrenteDicInfo.ValorPrincipal}_end");
            resultado.Value.where.Should().NotContain(" = ");
            // Deve ter exatamente 2 parâmetros
            resultado.Value.parametros.Should().HaveCount(2);
            // Verifica os parâmetros específicos
            var parametroInicial = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.ValorPrincipal}");
            var parametroFinal = resultado.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.ValorPrincipal}_end");
            parametroInicial.Should().NotBeNull();
            parametroInicial!.Value.Should().Be(valorValorPrincipalInicial);
            parametroFinal.Should().NotBeNull();
            parametroFinal!.Value.Should().Be(valorValorPrincipalFinal);
        }

        [Theory]
        [InlineData(1000, 2000)]
        [InlineData(0, 1000)]
        [InlineData(2500.50, 7500.75)]
        [InlineData(10000, 50000)]
        public void WFiltro_ValorPrincipal_RangeDiferentesValores_DeveProcessarCorretamente(decimal valorInicial, decimal valorFinal)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ValorPrincipal = valorInicial,
                ValorPrincipal_end = valorFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            resultado.Value.where.Should().Contain("BETWEEN");
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.ValorPrincipal}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.ValorPrincipal}_end");
            parametroInicial.Value.Should().Be(valorInicial);
            parametroFinal.Value.Should().Be(valorFinal);
        }

        [Fact]
        public void WFiltro_ValorPrincipal_Range_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ValorPrincipal = 1000m,
                ValorPrincipal_end = 5000m,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.ValorPrincipal}");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 3 parâmetros (2 para salário + 1 para nome)
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_ValorPrincipal_Range_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ValorPrincipal = 1000m,
                ValorPrincipal_end = 5000m,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(3);
        }

        [Fact]
        public void WFiltro_ValorPrincipal_Range_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ValorPrincipal = 1000m,
                ValorPrincipal_end = 5000m,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_ValorPrincipal_Range_CondicaoWhereDeveUsarTabelaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ValorPrincipal = 1000m,
                ValorPrincipal_end = 5000m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto no BETWEEN
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.ValorPrincipal} BETWEEN");
        }

        [Fact]
        public void WFiltro_ValorPrincipal_Range_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ValorPrincipal = 1000m,
                ValorPrincipal_end = 5000m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos DECIMAL não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_ValorPrincipal_Range_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ValorPrincipal = 1000m,
                ValorPrincipal_end = 5000m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_ValorPrincipal_Range_ParametrosDevemTerTipoCorreto()
        {
            // Arrange
            var valorValorPrincipalInicial = 1500.50m;
            var valorValorPrincipalFinal = 3750.75m;
            var filtro = new FilterContaCorrente
            {
                ValorPrincipal = valorValorPrincipalInicial,
                ValorPrincipal_end = valorValorPrincipalFinal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(2);
            var parametroInicial = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.ValorPrincipal}");
            var parametroFinal = resultado.Value.parametros.First(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.ValorPrincipal}_end");
            parametroInicial.Value.Should().BeOfType<decimal>();
            parametroInicial.Value.Should().Be(valorValorPrincipalInicial);
            parametroFinal.Value.Should().BeOfType<decimal>();
            parametroFinal.Value.Should().Be(valorValorPrincipalFinal);
        }

        [Fact]
        public void WFiltro_ValorPrincipal_QuandoAmbosZero_DeveUsarBETWEEN()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ValorPrincipal = 0m,
                ValorPrincipal_end = 0m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_ValorPrincipal_QuandoSomenteZeroInicial_DeveUsarIgualdade()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ValorPrincipal = 0m,
                ValorPrincipal_end = decimal.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain("BETWEEN");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(0m);
        }

        [Fact]
        public void WFiltro_ValorPrincipal_Logica_BETWEEN_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ValorPrincipal = 1500m,
                ValorPrincipal_end = 4500m,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.ValorPrincipal == decimal.MinValue) && !(filtro.ValorPrincipal_end == decimal.MinValue)
            // Deve resultar em BETWEEN quando ambos os valores não são MinValue
            resultado.Value.where.Should().Be($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.ValorPrincipal} BETWEEN @{DBContaCorrenteDicInfo.ValorPrincipal} AND @{DBContaCorrenteDicInfo.ValorPrincipal}_end");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_ValorPrincipal_Logica_Igualdade_Verifica_Condicoes_Exatas()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ValorPrincipal = 2000m,
                ValorPrincipal_end = decimal.MinValue,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica a lógica exata: !(filtro.ValorPrincipal == decimal.MinValue) && filtro.ValorPrincipal_end == decimal.MinValue
            // Deve resultar em igualdade quando apenas ValorPrincipal tem valor válido
            resultado.Value.where.Should().Be($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.ValorPrincipal}] = @{DBContaCorrenteDicInfo.ValorPrincipal}");
            resultado.Value.parametros.Should().HaveCount(1);
        }

#endregion
        [Theory]
        [InlineData("79228162514264337593543950335")]
        [InlineData("-79228162514264337593543950335")] // MinValue é usado como "não filtrar"
        [InlineData("0.01")]
        [InlineData("-999999.99")]
        public void WFiltro_ValorPrincipal_ComValoresExtremos_DeveProcessarCorretamente(string valorExtremoStr)
        {
            // Arrange
            var valorExtremo = decimal.Parse(valorExtremoStr, System.Globalization.CultureInfo.InvariantCulture);
            var filtro = new FilterContaCorrente
            {
                ValorPrincipal = valorExtremo,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(valorExtremo == decimal.MinValue ? 0 : 1);
            if (valorExtremo != decimal.MinValue)
            {
                resultado.Value.parametros.First().Value.Should().Be(valorExtremo);
            }
        }

#region filtro.ValorPrincipal Isolated Tests
        [Fact]
        public void WFiltro_ValorPrincipal_QuandoIntMinValue_NaoDeveIncluirParametroOuCondicionaWhere()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ValorPrincipal = decimal.MinValue, // Valor padrão que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE deve estar vazio
            resultado.Value.parametros.Should().BeEmpty(); // Nenhum parâmetro deve ser adicionado
        }

        [Fact]
        public void WFiltro_ValorPrincipal_QuandoTemValorPositivo_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorValorPrincipal = 5;
            var filtro = new FilterContaCorrente
            {
                ValorPrincipal = valorValorPrincipal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição correta
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.ValorPrincipal}] = @{DBContaCorrenteDicInfo.ValorPrincipal}");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be($"@{DBContaCorrenteDicInfo.ValorPrincipal}");
            parametro.Value.Should().Be(valorValorPrincipal);
        }

        [Fact]
        public void WFiltro_ValorPrincipal_QuandoValorZero_DeveIncluirParametroECondicionaWhere()
        {
            // Arrange
            var valorValorPrincipal = 0;
            var filtro = new FilterContaCorrente
            {
                ValorPrincipal = valorValorPrincipal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain($"= @{DBContaCorrenteDicInfo.ValorPrincipal}");
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorValorPrincipal);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(999)]
        [InlineData(2147483647)]
        public void WFiltro_ValorPrincipal_DiferentesValoresValidos_DeveProcessarCorretamente(decimal valorValorPrincipal)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ValorPrincipal = valorValorPrincipal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorValorPrincipal);
            resultado.Value.where.Should().Contain($"= @{DBContaCorrenteDicInfo.ValorPrincipal}");
        }

        [Fact]
        public void WFiltro_ValorPrincipal_ComOutrosCampos_DeveUsarLogicalOperatorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ValorPrincipal = 1,
                Data = "A", // Outro campo para testar o LogicalOperator // Outro campo INT para verificar a lógica AND
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.ValorPrincipal}");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            // Deve usar o operador lógico entre eles
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_ValorPrincipal_ComLogicalOperatorOR_DeveUsarOperadorCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ValorPrincipal = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " OR "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().Contain(" OR ");
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Fact]
        public void WFiltro_ValorPrincipal_QuandoLogicalOperatorVazio_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ValorPrincipal = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = string.Empty // Operador vazio
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_ValorPrincipal_QuandoLogicalOperatorNull_DeveUsarAndPorPadrao()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ValorPrincipal = 1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = null // Operador null
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar AND como padrão
            resultado.Value.where.Should().Contain(" AND ");
        }

        [Fact]
        public void WFiltro_ValorPrincipal_CondicaoWhereDeveUsarTabelnaNomeCorreto()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ValorPrincipal = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se usa o nome da tabela correto
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.ValorPrincipal}]");
        }

        [Fact]
        public void WFiltro_ValorPrincipal_DeveUsarOperadorIgualdade()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ValorPrincipal = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve usar operador de igualdade, não LIKE
            resultado.Value.where.Should().Contain(" = ");
            resultado.Value.where.Should().NotContain(" like ");
        }

        [Fact]
        public void WFiltro_ValorPrincipal_NaoDeveUsarMsiCollate()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ValorPrincipal = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Campos INT não devem usar COLLATE
            resultado.Value.where.Should().NotContain(DevourerConsts.MsiCollate);
        }

        [Fact]
        public void WFiltro_ValorPrincipal_ComoUnicoCampo_DeveNaoTerOperadorLogico()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ValorPrincipal = 1,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Como é o único campo, não deve ter operador lógico no início
            resultado.Value.where.Should().NotStartWith(" AND ");
            resultado.Value.where.Should().NotStartWith(" OR ");
        }

        [Fact]
        public void WFiltro_ValorPrincipal_ParametroDeveTerTipoCorreto()
        {
            // Arrange
            var valorValorPrincipal = (decimal)42.12;
            var filtro = new FilterContaCorrente
            {
                ValorPrincipal = valorValorPrincipal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<decimal>();
            parametro.Value.Should().Be(valorValorPrincipal);
        }

#endregion
        [Fact]
        public void WFiltro_ValorPrincipal_QuandoValorMinValue_NaoDeveIncluirNoFiltro()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ValorPrincipal = decimal.MinValue, // Valor que indica "não filtrar"
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.where.Should().BeEmpty(); // WHERE vazio quando só tem MinValue
            resultado.Value.parametros.Should().BeEmpty(); // Sem parâmetros
        }

        [Fact]
        public void WFiltro_ValorPrincipal_QuandoTemValor_DeveIncluirNoFiltro()
        {
            // Arrange
            decimal valorValorPrincipal = 1;
            var filtro = new FilterContaCorrente
            {
                ValorPrincipal = valorValorPrincipal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Verifica se o WHERE contém a condição do ValorPrincipal
            resultado.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.ValorPrincipal}] = @ctoValorPrincipal");
            // Verifica se tem exatamente 1 parâmetro
            resultado.Value.parametros.Should().HaveCount(1);
            // Verifica o parâmetro específico
            var parametro = resultado.Value.parametros.First();
            parametro.ParameterName.Should().Be("@ctoValorPrincipal");
            parametro.Value.Should().Be(valorValorPrincipal);
        }

        [Fact]
        public void WFiltro_ValorPrincipal_ComOutrosCampos_DeveUsarLogicalOperator()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ValorPrincipal = (decimal)1,
                Data = "A", // Outro campo para testar o LogicalOperator
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            // Deve conter ambos os campos com AND entre eles
            resultado.Value.where.Should().Contain("@ctoValorPrincipal");
            resultado.Value.where.Should().Contain($"@{DBContaCorrenteDicInfo.Data}");
            resultado.Value.where.Should().Contain(" AND ");
            // Deve ter 2 parâmetro(s)
            resultado.Value.parametros.Should().HaveCount(2);
        }

        [Theory]
        [InlineData(0)]
        [InlineData(1.2)]
        [InlineData(999.40)]
        public void WFiltro_ValorPrincipal_DiferentesValores_DeveFuncionar(decimal valorValorPrincipal)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                ValorPrincipal = valorValorPrincipal,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            resultado.Value.parametros.First().Value.Should().Be(valorValorPrincipal);
        }

#endregion
#region DateTime Tests
        [Theory]
        [InlineData("31/12/9999")] // Data máxima
        [InlineData("01/01/1900")] // Data muito antiga
        [InlineData("29/02/2024")] // Ano bissexto
        public void WFiltro_DtOriginal_ComDatasExtremas_DeveProcessarCorretamente(string dataExtrema)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DtOriginal = dataExtrema,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<DateTime>();
        }

        [Theory]
        [InlineData("32/12/2023")] // Dia inválido
        [InlineData("31/13/2023")] // Mês inválido
        [InlineData("29/02/2023")] // Não é ano bissexto
        [InlineData("abc/def/ghij")] // Formato completamente inválido
        public void WFiltro_DtOriginal_ComDatasInvalidas_NaoDeveAdicionarParametros(string dataInvalida)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DtOriginal = dataInvalida,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().BeEmpty();
            resultado.Value.where.Should().BeEmpty();
        }

#region DtOriginal Tests
        [Fact]
        public void WFiltro_DtOriginal_WhenEmptyOrNull_ShouldNotAddParameters()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DtOriginal = string.Empty,
                DtOriginal_end = null,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DtOriginal_WhenValidSingleDate_ShouldAddParameterAndGenerateWhereClause()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterContaCorrente
            {
                DtOriginal = testDate,
                DtOriginal_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(1);
            var parameter = result.Value.parametros.First();
            parameter.ParameterName.Should().Be($"@{DBContaCorrenteDicInfo.DtOriginal}");
            parameter.Value.Should().BeOfType<DateTime>();
            var expectedDate = DateTime.Parse(testDate);
            ((DateTime)parameter.Value).Should().Be(expectedDate);
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.DtOriginal}], 103) = CONVERT(DATE, @{DBContaCorrenteDicInfo.DtOriginal}, 103)");
        }

        [Fact]
        public void WFiltro_DtOriginal_WhenValidDateRange_ShouldAddBothParametersAndGenerateBetweenClause()
        {
            // Arrange
            var startDate = "01/06/2023";
            var endDate = "30/06/2023";
            var filtro = new FilterContaCorrente
            {
                DtOriginal = startDate,
                DtOriginal_end = endDate,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(2);
            var startParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.DtOriginal}");
            var endParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.DtOriginal}_end");
            startParameter.Should().NotBeNull();
            endParameter.Should().NotBeNull();
            startParameter!.Value.Should().BeOfType<DateTime>();
            endParameter!.Value.Should().BeOfType<DateTime>();
            ((DateTime)startParameter.Value).Should().Be(DateTime.Parse(startDate));
            ((DateTime)endParameter.Value).Should().Be(DateTime.Parse(endDate));
            result.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.DtOriginal} BETWEEN @{DBContaCorrenteDicInfo.DtOriginal} AND @{DBContaCorrenteDicInfo.DtOriginal}_end");
        }

        [Fact]
        public void WFiltro_DtOriginal_WhenInvalidDateFormat_ShouldNotAddParameter()
        {
            // Arrange
            var invalidDate = "invalid-date";
            var filtro = new FilterContaCorrente
            {
                DtOriginal = invalidDate,
                DtOriginal_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DtOriginal_WhenStartDateValidButEndDateInvalid_ShouldOnlyAddStartParameterAndGenerateSingleDateClause()
        {
            // Arrange
            var validStartDate = "15/06/2023";
            var invalidEndDate = "invalid-date";
            var filtro = new FilterContaCorrente
            {
                DtOriginal = validStartDate,
                DtOriginal_end = invalidEndDate,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(1);
            var parameter = result.Value.parametros.First();
            parameter.ParameterName.Should().Be($"@{DBContaCorrenteDicInfo.DtOriginal}");
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.DtOriginal}], 103) = CONVERT(DATE, @{DBContaCorrenteDicInfo.DtOriginal}, 103)");
            result.Value.where.Should().NotContain("BETWEEN");
        }

        [Fact]
        public void WFiltro_DtOriginal_WhenStartDateInvalidButEndDateValid_ShouldNotAddAnyParameters()
        {
            // Arrange
            var invalidStartDate = "invalid-date";
            var validEndDate = "30/06/2023";
            var filtro = new FilterContaCorrente
            {
                DtOriginal = invalidStartDate,
                DtOriginal_end = validEndDate,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DtOriginal_WhenWhitespaceOnlyDates_ShouldNotAddParameters()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DtOriginal = "   ",
                DtOriginal_end = "\t\n",
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DtOriginal_WithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterContaCorrente
            {
                Data = "A",
                DtOriginal = testDate,
                DtOriginal_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(2); // Nome + DtOriginal
            result.Value.where.Should().Contain(TSql.And);
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.DtOriginal}], 103) = CONVERT(DATE, @{DBContaCorrenteDicInfo.DtOriginal}, 103)");
        }

        [Fact]
        public void WFiltro_DtOriginal_WithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterContaCorrente
            {
                Data = "A",
                DtOriginal = testDate,
                DtOriginal_end = string.Empty,
                LogicalOperator = TSql.OR
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(TSql.OR);
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.DtOriginal}], 103) = CONVERT(DATE, @{DBContaCorrenteDicInfo.DtOriginal}, 103)");
        }

        [Fact]
        public void WFiltro_DtOriginal_WhenOnlyEndDateProvided_ShouldNotAddParameters()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DtOriginal = string.Empty,
                DtOriginal_end = "30/06/2023",
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DtOriginal_WhenDateTimeMinValue_ShouldNotAddParameters()
        {
            // Arrange
            var minValueDate = DateTime.MinValue.ToString("dd/MM/yyyy");
            var filtro = new FilterContaCorrente
            {
                DtOriginal = minValueDate,
                DtOriginal_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // The IsEmptyDX extension method should catch DateTime.MinValue and return true
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DtOriginal_AsFirstFilter_ShouldNotIncludeLogicalOperatorAtStart()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterContaCorrente
            {
                DtOriginal = testDate,
                DtOriginal_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().NotStartWith(TSql.And);
            result.Value.where.Should().StartWith($"CONVERT(DATE,[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.DtOriginal}], 103)");
        }

        [Theory]
        [InlineData("15/06/2023", "2023-06-15T00:00:00")]
        [InlineData("01/01/2024", "2024-01-01T00:00:00")]
        [InlineData("31/12/2022", "2022-12-31T00:00:00")]
        public void WFiltro_DtOriginal_WhenVariousValidDateFormats_ShouldParseCorrectly(string inputDate, string expectedDateTimeString)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DtOriginal = inputDate,
                DtOriginal_end = string.Empty,
                LogicalOperator = TSql.And
            };
            var expectedDateTime = DateTime.Parse(expectedDateTimeString);
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(1);
            var parameter = result.Value.parametros.First();
            ((DateTime)parameter.Value).Should().Be(expectedDateTime);
        }

#endregion
        [Theory]
        [InlineData("31/12/9999")] // Data máxima
        [InlineData("01/01/1900")] // Data muito antiga
        [InlineData("29/02/2024")] // Ano bissexto
        public void WFiltro_DataPgto_ComDatasExtremas_DeveProcessarCorretamente(string dataExtrema)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DataPgto = dataExtrema,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().HaveCount(1);
            var parametro = resultado.Value.parametros.First();
            parametro.Value.Should().BeOfType<DateTime>();
        }

        [Theory]
        [InlineData("32/12/2023")] // Dia inválido
        [InlineData("31/13/2023")] // Mês inválido
        [InlineData("29/02/2023")] // Não é ano bissexto
        [InlineData("abc/def/ghij")] // Formato completamente inválido
        public void WFiltro_DataPgto_ComDatasInvalidas_NaoDeveAdicionarParametros(string dataInvalida)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DataPgto = dataInvalida,
                LogicalOperator = " AND "
            };
            // Act
            var resultado = _service.WFiltro(filtro);
            // Assert
            resultado.Should().NotBeNull();
            resultado.Value.parametros.Should().BeEmpty();
            resultado.Value.where.Should().BeEmpty();
        }

#region DataPgto Tests
        [Fact]
        public void WFiltro_DataPgto_WhenEmptyOrNull_ShouldNotAddParameters()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DataPgto = string.Empty,
                DataPgto_end = null,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DataPgto_WhenValidSingleDate_ShouldAddParameterAndGenerateWhereClause()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterContaCorrente
            {
                DataPgto = testDate,
                DataPgto_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(1);
            var parameter = result.Value.parametros.First();
            parameter.ParameterName.Should().Be($"@{DBContaCorrenteDicInfo.DataPgto}");
            parameter.Value.Should().BeOfType<DateTime>();
            var expectedDate = DateTime.Parse(testDate);
            ((DateTime)parameter.Value).Should().Be(expectedDate);
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.DataPgto}], 103) = CONVERT(DATE, @{DBContaCorrenteDicInfo.DataPgto}, 103)");
        }

        [Fact]
        public void WFiltro_DataPgto_WhenValidDateRange_ShouldAddBothParametersAndGenerateBetweenClause()
        {
            // Arrange
            var startDate = "01/06/2023";
            var endDate = "30/06/2023";
            var filtro = new FilterContaCorrente
            {
                DataPgto = startDate,
                DataPgto_end = endDate,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(2);
            var startParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.DataPgto}");
            var endParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.DataPgto}_end");
            startParameter.Should().NotBeNull();
            endParameter.Should().NotBeNull();
            startParameter!.Value.Should().BeOfType<DateTime>();
            endParameter!.Value.Should().BeOfType<DateTime>();
            ((DateTime)startParameter.Value).Should().Be(DateTime.Parse(startDate));
            ((DateTime)endParameter.Value).Should().Be(DateTime.Parse(endDate));
            result.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].{DBContaCorrenteDicInfo.DataPgto} BETWEEN @{DBContaCorrenteDicInfo.DataPgto} AND @{DBContaCorrenteDicInfo.DataPgto}_end");
        }

        [Fact]
        public void WFiltro_DataPgto_WhenInvalidDateFormat_ShouldNotAddParameter()
        {
            // Arrange
            var invalidDate = "invalid-date";
            var filtro = new FilterContaCorrente
            {
                DataPgto = invalidDate,
                DataPgto_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DataPgto_WhenStartDateValidButEndDateInvalid_ShouldOnlyAddStartParameterAndGenerateSingleDateClause()
        {
            // Arrange
            var validStartDate = "15/06/2023";
            var invalidEndDate = "invalid-date";
            var filtro = new FilterContaCorrente
            {
                DataPgto = validStartDate,
                DataPgto_end = invalidEndDate,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(1);
            var parameter = result.Value.parametros.First();
            parameter.ParameterName.Should().Be($"@{DBContaCorrenteDicInfo.DataPgto}");
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.DataPgto}], 103) = CONVERT(DATE, @{DBContaCorrenteDicInfo.DataPgto}, 103)");
            result.Value.where.Should().NotContain("BETWEEN");
        }

        [Fact]
        public void WFiltro_DataPgto_WhenStartDateInvalidButEndDateValid_ShouldNotAddAnyParameters()
        {
            // Arrange
            var invalidStartDate = "invalid-date";
            var validEndDate = "30/06/2023";
            var filtro = new FilterContaCorrente
            {
                DataPgto = invalidStartDate,
                DataPgto_end = validEndDate,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DataPgto_WhenWhitespaceOnlyDates_ShouldNotAddParameters()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DataPgto = "   ",
                DataPgto_end = "\t\n",
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DataPgto_WithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterContaCorrente
            {
                Data = "A",
                DataPgto = testDate,
                DataPgto_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(2); // Nome + DataPgto
            result.Value.where.Should().Contain(TSql.And);
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.DataPgto}], 103) = CONVERT(DATE, @{DBContaCorrenteDicInfo.DataPgto}, 103)");
        }

        [Fact]
        public void WFiltro_DataPgto_WithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterContaCorrente
            {
                Data = "A",
                DataPgto = testDate,
                DataPgto_end = string.Empty,
                LogicalOperator = TSql.OR
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(TSql.OR);
            result.Value.where.Should().Contain($"CONVERT(DATE,[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.DataPgto}], 103) = CONVERT(DATE, @{DBContaCorrenteDicInfo.DataPgto}, 103)");
        }

        [Fact]
        public void WFiltro_DataPgto_WhenOnlyEndDateProvided_ShouldNotAddParameters()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DataPgto = string.Empty,
                DataPgto_end = "30/06/2023",
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DataPgto_WhenDateTimeMinValue_ShouldNotAddParameters()
        {
            // Arrange
            var minValueDate = DateTime.MinValue.ToString("dd/MM/yyyy");
            var filtro = new FilterContaCorrente
            {
                DataPgto = minValueDate,
                DataPgto_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // The IsEmptyDX extension method should catch DateTime.MinValue and return true
            result.Value.parametros.Should().BeEmpty();
            result.Value.where.Should().BeEmpty();
        }

        [Fact]
        public void WFiltro_DataPgto_AsFirstFilter_ShouldNotIncludeLogicalOperatorAtStart()
        {
            // Arrange
            var testDate = "15/06/2023";
            var filtro = new FilterContaCorrente
            {
                DataPgto = testDate,
                DataPgto_end = string.Empty,
                LogicalOperator = TSql.And
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().NotStartWith(TSql.And);
            result.Value.where.Should().StartWith($"CONVERT(DATE,[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.DataPgto}], 103)");
        }

        [Theory]
        [InlineData("15/06/2023", "2023-06-15T00:00:00")]
        [InlineData("01/01/2024", "2024-01-01T00:00:00")]
        [InlineData("31/12/2022", "2022-12-31T00:00:00")]
        public void WFiltro_DataPgto_WhenVariousValidDateFormats_ShouldParseCorrectly(string inputDate, string expectedDateTimeString)
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DataPgto = inputDate,
                DataPgto_end = string.Empty,
                LogicalOperator = TSql.And
            };
            var expectedDateTime = DateTime.Parse(expectedDateTimeString);
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().HaveCount(1);
            var parameter = result.Value.parametros.First();
            ((DateTime)parameter.Value).Should().Be(expectedDateTime);
        }

#endregion
#endregion
#region Bool Tests
#region Quitado Filter Tests
        [Fact]
        public void WFiltro_QuitadoEqualsIntMinValue_ShouldNotAddParameterOrWhereClause()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Quitado = int.MinValue
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().NotContain(p => p.ParameterName.Contains(DBContaCorrenteDicInfo.Quitado));
            result.Value.where.Should().NotContain(DBContaCorrenteDicInfo.Quitado);
        }

        [Fact]
        public void WFiltro_QuitadoHasValidValue_ShouldAddParameterAndWhereClause()
        {
            // Arrange
            var QuitadoValue = 1;
            var filtro = new FilterContaCorrente
            {
                Quitado = QuitadoValue,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // Check parameter
            var QuitadoParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Quitado}");
            QuitadoParameter.Should().NotBeNull();
            QuitadoParameter.Value.Should().Be(QuitadoValue);
            // Check where clause
            result.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.Quitado}] = @{DBContaCorrenteDicInfo.Quitado}");
        }

        [Fact]
        public void WFiltro_QuitadoWithDifferentValues_ShouldAddCorrectParameterValue()
        {
            // Arrange & Act & Assert for Quitado = 0 (typically female)
            var filtroFemale = new FilterContaCorrente
            {
                Quitado = 0
            };
            var resultFemale = _service.WFiltro(filtroFemale);
            resultFemale.Should().NotBeNull();
            var femaleParam = resultFemale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Quitado}");
            femaleParam.Should().NotBeNull();
            femaleParam.Value.Should().Be(0);
            // Arrange & Act & Assert for Quitado = 1 (typically male)
            var filtroMale = new FilterContaCorrente
            {
                Quitado = 1
            };
            var resultMale = _service.WFiltro(filtroMale);
            resultMale.Should().NotBeNull();
            var maleParam = resultMale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Quitado}");
            maleParam.Should().NotBeNull();
            maleParam.Value.Should().Be(1);
        }

        [Fact]
        public void WFiltro_QuitadoAsFirstFilter_ShouldNotIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Quitado = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().StartWith($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.Quitado}] = @{DBContaCorrenteDicInfo.Quitado}");
            result.Value.where.Should().NotStartWith(" AND ");
        }

        [Fact]
        public void WFiltro_QuitadoWithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Data = "Data",
                Quitado = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain($" AND ");
        }

        [Fact]
        public void WFiltro_QuitadoWithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Data = "Data",
                Quitado = 1,
                LogicalOperator = " OR "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(" OR ");
        }

#endregion
#region Sucumbencia Filter Tests
        [Fact]
        public void WFiltro_SucumbenciaEqualsIntMinValue_ShouldNotAddParameterOrWhereClause()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Sucumbencia = int.MinValue
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().NotContain(p => p.ParameterName.Contains(DBContaCorrenteDicInfo.Sucumbencia));
            result.Value.where.Should().NotContain(DBContaCorrenteDicInfo.Sucumbencia);
        }

        [Fact]
        public void WFiltro_SucumbenciaHasValidValue_ShouldAddParameterAndWhereClause()
        {
            // Arrange
            var SucumbenciaValue = 1;
            var filtro = new FilterContaCorrente
            {
                Sucumbencia = SucumbenciaValue,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // Check parameter
            var SucumbenciaParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Sucumbencia}");
            SucumbenciaParameter.Should().NotBeNull();
            SucumbenciaParameter.Value.Should().Be(SucumbenciaValue);
            // Check where clause
            result.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.Sucumbencia}] = @{DBContaCorrenteDicInfo.Sucumbencia}");
        }

        [Fact]
        public void WFiltro_SucumbenciaWithDifferentValues_ShouldAddCorrectParameterValue()
        {
            // Arrange & Act & Assert for Sucumbencia = 0 (typically female)
            var filtroFemale = new FilterContaCorrente
            {
                Sucumbencia = 0
            };
            var resultFemale = _service.WFiltro(filtroFemale);
            resultFemale.Should().NotBeNull();
            var femaleParam = resultFemale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Sucumbencia}");
            femaleParam.Should().NotBeNull();
            femaleParam.Value.Should().Be(0);
            // Arrange & Act & Assert for Sucumbencia = 1 (typically male)
            var filtroMale = new FilterContaCorrente
            {
                Sucumbencia = 1
            };
            var resultMale = _service.WFiltro(filtroMale);
            resultMale.Should().NotBeNull();
            var maleParam = resultMale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Sucumbencia}");
            maleParam.Should().NotBeNull();
            maleParam.Value.Should().Be(1);
        }

        [Fact]
        public void WFiltro_SucumbenciaAsFirstFilter_ShouldNotIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Sucumbencia = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().StartWith($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.Sucumbencia}] = @{DBContaCorrenteDicInfo.Sucumbencia}");
            result.Value.where.Should().NotStartWith(" AND ");
        }

        [Fact]
        public void WFiltro_SucumbenciaWithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Data = "Data",
                Sucumbencia = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain($" AND ");
        }

        [Fact]
        public void WFiltro_SucumbenciaWithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Data = "Data",
                Sucumbencia = 1,
                LogicalOperator = " OR "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(" OR ");
        }

#endregion
#region DistRegra Filter Tests
        [Fact]
        public void WFiltro_DistRegraEqualsIntMinValue_ShouldNotAddParameterOrWhereClause()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DistRegra = int.MinValue
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().NotContain(p => p.ParameterName.Contains(DBContaCorrenteDicInfo.DistRegra));
            result.Value.where.Should().NotContain(DBContaCorrenteDicInfo.DistRegra);
        }

        [Fact]
        public void WFiltro_DistRegraHasValidValue_ShouldAddParameterAndWhereClause()
        {
            // Arrange
            var DistRegraValue = 1;
            var filtro = new FilterContaCorrente
            {
                DistRegra = DistRegraValue,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // Check parameter
            var DistRegraParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.DistRegra}");
            DistRegraParameter.Should().NotBeNull();
            DistRegraParameter.Value.Should().Be(DistRegraValue);
            // Check where clause
            result.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.DistRegra}] = @{DBContaCorrenteDicInfo.DistRegra}");
        }

        [Fact]
        public void WFiltro_DistRegraWithDifferentValues_ShouldAddCorrectParameterValue()
        {
            // Arrange & Act & Assert for DistRegra = 0 (typically female)
            var filtroFemale = new FilterContaCorrente
            {
                DistRegra = 0
            };
            var resultFemale = _service.WFiltro(filtroFemale);
            resultFemale.Should().NotBeNull();
            var femaleParam = resultFemale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.DistRegra}");
            femaleParam.Should().NotBeNull();
            femaleParam.Value.Should().Be(0);
            // Arrange & Act & Assert for DistRegra = 1 (typically male)
            var filtroMale = new FilterContaCorrente
            {
                DistRegra = 1
            };
            var resultMale = _service.WFiltro(filtroMale);
            resultMale.Should().NotBeNull();
            var maleParam = resultMale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.DistRegra}");
            maleParam.Should().NotBeNull();
            maleParam.Value.Should().Be(1);
        }

        [Fact]
        public void WFiltro_DistRegraAsFirstFilter_ShouldNotIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                DistRegra = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().StartWith($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.DistRegra}] = @{DBContaCorrenteDicInfo.DistRegra}");
            result.Value.where.Should().NotStartWith(" AND ");
        }

        [Fact]
        public void WFiltro_DistRegraWithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Data = "Data",
                DistRegra = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain($" AND ");
        }

        [Fact]
        public void WFiltro_DistRegraWithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Data = "Data",
                DistRegra = 1,
                LogicalOperator = " OR "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(" OR ");
        }

#endregion
#region Contrato Filter Tests
        [Fact]
        public void WFiltro_ContratoEqualsIntMinValue_ShouldNotAddParameterOrWhereClause()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Contrato = int.MinValue
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().NotContain(p => p.ParameterName.Contains(DBContaCorrenteDicInfo.Contrato));
            result.Value.where.Should().NotContain(DBContaCorrenteDicInfo.Contrato);
        }

        [Fact]
        public void WFiltro_ContratoHasValidValue_ShouldAddParameterAndWhereClause()
        {
            // Arrange
            var ContratoValue = 1;
            var filtro = new FilterContaCorrente
            {
                Contrato = ContratoValue,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // Check parameter
            var ContratoParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Contrato}");
            ContratoParameter.Should().NotBeNull();
            ContratoParameter.Value.Should().Be(ContratoValue);
            // Check where clause
            result.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.Contrato}] = @{DBContaCorrenteDicInfo.Contrato}");
        }

        [Fact]
        public void WFiltro_ContratoWithDifferentValues_ShouldAddCorrectParameterValue()
        {
            // Arrange & Act & Assert for Contrato = 0 (typically female)
            var filtroFemale = new FilterContaCorrente
            {
                Contrato = 0
            };
            var resultFemale = _service.WFiltro(filtroFemale);
            resultFemale.Should().NotBeNull();
            var femaleParam = resultFemale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Contrato}");
            femaleParam.Should().NotBeNull();
            femaleParam.Value.Should().Be(0);
            // Arrange & Act & Assert for Contrato = 1 (typically male)
            var filtroMale = new FilterContaCorrente
            {
                Contrato = 1
            };
            var resultMale = _service.WFiltro(filtroMale);
            resultMale.Should().NotBeNull();
            var maleParam = resultMale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Contrato}");
            maleParam.Should().NotBeNull();
            maleParam.Value.Should().Be(1);
        }

        [Fact]
        public void WFiltro_ContratoAsFirstFilter_ShouldNotIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Contrato = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().StartWith($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.Contrato}] = @{DBContaCorrenteDicInfo.Contrato}");
            result.Value.where.Should().NotStartWith(" AND ");
        }

        [Fact]
        public void WFiltro_ContratoWithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Data = "Data",
                Contrato = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain($" AND ");
        }

        [Fact]
        public void WFiltro_ContratoWithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Data = "Data",
                Contrato = 1,
                LogicalOperator = " OR "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(" OR ");
        }

#endregion
#region Pago Filter Tests
        [Fact]
        public void WFiltro_PagoEqualsIntMinValue_ShouldNotAddParameterOrWhereClause()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Pago = int.MinValue
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().NotContain(p => p.ParameterName.Contains(DBContaCorrenteDicInfo.Pago));
            result.Value.where.Should().NotContain(DBContaCorrenteDicInfo.Pago);
        }

        [Fact]
        public void WFiltro_PagoHasValidValue_ShouldAddParameterAndWhereClause()
        {
            // Arrange
            var PagoValue = 1;
            var filtro = new FilterContaCorrente
            {
                Pago = PagoValue,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // Check parameter
            var PagoParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Pago}");
            PagoParameter.Should().NotBeNull();
            PagoParameter.Value.Should().Be(PagoValue);
            // Check where clause
            result.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.Pago}] = @{DBContaCorrenteDicInfo.Pago}");
        }

        [Fact]
        public void WFiltro_PagoWithDifferentValues_ShouldAddCorrectParameterValue()
        {
            // Arrange & Act & Assert for Pago = 0 (typically female)
            var filtroFemale = new FilterContaCorrente
            {
                Pago = 0
            };
            var resultFemale = _service.WFiltro(filtroFemale);
            resultFemale.Should().NotBeNull();
            var femaleParam = resultFemale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Pago}");
            femaleParam.Should().NotBeNull();
            femaleParam.Value.Should().Be(0);
            // Arrange & Act & Assert for Pago = 1 (typically male)
            var filtroMale = new FilterContaCorrente
            {
                Pago = 1
            };
            var resultMale = _service.WFiltro(filtroMale);
            resultMale.Should().NotBeNull();
            var maleParam = resultMale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Pago}");
            maleParam.Should().NotBeNull();
            maleParam.Value.Should().Be(1);
        }

        [Fact]
        public void WFiltro_PagoAsFirstFilter_ShouldNotIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Pago = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().StartWith($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.Pago}] = @{DBContaCorrenteDicInfo.Pago}");
            result.Value.where.Should().NotStartWith(" AND ");
        }

        [Fact]
        public void WFiltro_PagoWithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Data = "Data",
                Pago = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain($" AND ");
        }

        [Fact]
        public void WFiltro_PagoWithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Data = "Data",
                Pago = 1,
                LogicalOperator = " OR "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(" OR ");
        }

#endregion
#region Distribuir Filter Tests
        [Fact]
        public void WFiltro_DistribuirEqualsIntMinValue_ShouldNotAddParameterOrWhereClause()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Distribuir = int.MinValue
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().NotContain(p => p.ParameterName.Contains(DBContaCorrenteDicInfo.Distribuir));
            result.Value.where.Should().NotContain(DBContaCorrenteDicInfo.Distribuir);
        }

        [Fact]
        public void WFiltro_DistribuirHasValidValue_ShouldAddParameterAndWhereClause()
        {
            // Arrange
            var DistribuirValue = 1;
            var filtro = new FilterContaCorrente
            {
                Distribuir = DistribuirValue,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // Check parameter
            var DistribuirParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Distribuir}");
            DistribuirParameter.Should().NotBeNull();
            DistribuirParameter.Value.Should().Be(DistribuirValue);
            // Check where clause
            result.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.Distribuir}] = @{DBContaCorrenteDicInfo.Distribuir}");
        }

        [Fact]
        public void WFiltro_DistribuirWithDifferentValues_ShouldAddCorrectParameterValue()
        {
            // Arrange & Act & Assert for Distribuir = 0 (typically female)
            var filtroFemale = new FilterContaCorrente
            {
                Distribuir = 0
            };
            var resultFemale = _service.WFiltro(filtroFemale);
            resultFemale.Should().NotBeNull();
            var femaleParam = resultFemale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Distribuir}");
            femaleParam.Should().NotBeNull();
            femaleParam.Value.Should().Be(0);
            // Arrange & Act & Assert for Distribuir = 1 (typically male)
            var filtroMale = new FilterContaCorrente
            {
                Distribuir = 1
            };
            var resultMale = _service.WFiltro(filtroMale);
            resultMale.Should().NotBeNull();
            var maleParam = resultMale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Distribuir}");
            maleParam.Should().NotBeNull();
            maleParam.Value.Should().Be(1);
        }

        [Fact]
        public void WFiltro_DistribuirAsFirstFilter_ShouldNotIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Distribuir = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().StartWith($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.Distribuir}] = @{DBContaCorrenteDicInfo.Distribuir}");
            result.Value.where.Should().NotStartWith(" AND ");
        }

        [Fact]
        public void WFiltro_DistribuirWithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Data = "Data",
                Distribuir = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain($" AND ");
        }

        [Fact]
        public void WFiltro_DistribuirWithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Data = "Data",
                Distribuir = 1,
                LogicalOperator = " OR "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(" OR ");
        }

#endregion
#region LC Filter Tests
        [Fact]
        public void WFiltro_LCEqualsIntMinValue_ShouldNotAddParameterOrWhereClause()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                LC = int.MinValue
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().NotContain(p => p.ParameterName.Contains(DBContaCorrenteDicInfo.LC));
            result.Value.where.Should().NotContain(DBContaCorrenteDicInfo.LC);
        }

        [Fact]
        public void WFiltro_LCHasValidValue_ShouldAddParameterAndWhereClause()
        {
            // Arrange
            var LCValue = 1;
            var filtro = new FilterContaCorrente
            {
                LC = LCValue,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // Check parameter
            var LCParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.LC}");
            LCParameter.Should().NotBeNull();
            LCParameter.Value.Should().Be(LCValue);
            // Check where clause
            result.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.LC}] = @{DBContaCorrenteDicInfo.LC}");
        }

        [Fact]
        public void WFiltro_LCWithDifferentValues_ShouldAddCorrectParameterValue()
        {
            // Arrange & Act & Assert for LC = 0 (typically female)
            var filtroFemale = new FilterContaCorrente
            {
                LC = 0
            };
            var resultFemale = _service.WFiltro(filtroFemale);
            resultFemale.Should().NotBeNull();
            var femaleParam = resultFemale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.LC}");
            femaleParam.Should().NotBeNull();
            femaleParam.Value.Should().Be(0);
            // Arrange & Act & Assert for LC = 1 (typically male)
            var filtroMale = new FilterContaCorrente
            {
                LC = 1
            };
            var resultMale = _service.WFiltro(filtroMale);
            resultMale.Should().NotBeNull();
            var maleParam = resultMale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.LC}");
            maleParam.Should().NotBeNull();
            maleParam.Value.Should().Be(1);
        }

        [Fact]
        public void WFiltro_LCAsFirstFilter_ShouldNotIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                LC = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().StartWith($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.LC}] = @{DBContaCorrenteDicInfo.LC}");
            result.Value.where.Should().NotStartWith(" AND ");
        }

        [Fact]
        public void WFiltro_LCWithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Data = "Data",
                LC = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain($" AND ");
        }

        [Fact]
        public void WFiltro_LCWithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Data = "Data",
                LC = 1,
                LogicalOperator = " OR "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(" OR ");
        }

#endregion
#region Hide Filter Tests
        [Fact]
        public void WFiltro_HideEqualsIntMinValue_ShouldNotAddParameterOrWhereClause()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Hide = int.MinValue
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.parametros.Should().NotContain(p => p.ParameterName.Contains(DBContaCorrenteDicInfo.Hide));
            result.Value.where.Should().NotContain(DBContaCorrenteDicInfo.Hide);
        }

        [Fact]
        public void WFiltro_HideHasValidValue_ShouldAddParameterAndWhereClause()
        {
            // Arrange
            var HideValue = 1;
            var filtro = new FilterContaCorrente
            {
                Hide = HideValue,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            // Check parameter
            var HideParameter = result.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Hide}");
            HideParameter.Should().NotBeNull();
            HideParameter.Value.Should().Be(HideValue);
            // Check where clause
            result.Value.where.Should().Contain($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.Hide}] = @{DBContaCorrenteDicInfo.Hide}");
        }

        [Fact]
        public void WFiltro_HideWithDifferentValues_ShouldAddCorrectParameterValue()
        {
            // Arrange & Act & Assert for Hide = 0 (typically female)
            var filtroFemale = new FilterContaCorrente
            {
                Hide = 0
            };
            var resultFemale = _service.WFiltro(filtroFemale);
            resultFemale.Should().NotBeNull();
            var femaleParam = resultFemale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Hide}");
            femaleParam.Should().NotBeNull();
            femaleParam.Value.Should().Be(0);
            // Arrange & Act & Assert for Hide = 1 (typically male)
            var filtroMale = new FilterContaCorrente
            {
                Hide = 1
            };
            var resultMale = _service.WFiltro(filtroMale);
            resultMale.Should().NotBeNull();
            var maleParam = resultMale.Value.parametros.FirstOrDefault(p => p.ParameterName == $"@{DBContaCorrenteDicInfo.Hide}");
            maleParam.Should().NotBeNull();
            maleParam.Value.Should().Be(1);
        }

        [Fact]
        public void WFiltro_HideAsFirstFilter_ShouldNotIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Hide = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().StartWith($"[{DBContaCorrenteDicInfo.PTabelaNome}].[{DBContaCorrenteDicInfo.Hide}] = @{DBContaCorrenteDicInfo.Hide}");
            result.Value.where.Should().NotStartWith(" AND ");
        }

        [Fact]
        public void WFiltro_HideWithOtherFilters_ShouldIncludeLogicalOperatorInWhereClause()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Data = "Data",
                Hide = 1,
                LogicalOperator = " AND "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain($" AND ");
        }

        [Fact]
        public void WFiltro_HideWithORLogicalOperator_ShouldUseORInWhereClause()
        {
            // Arrange
            var filtro = new FilterContaCorrente
            {
                Data = "Data",
                Hide = 1,
                LogicalOperator = " OR "
            };
            // Act
            var result = _service.WFiltro(filtro);
            // Assert
            result.Should().NotBeNull();
            result.Value.where.Should().Contain(" OR ");
        }

#endregion
#endregion
        [Fact]
        public void Dispose_CalledOnce_DisposesCorrectly()
        {
            // Act
            _service.Dispose();
            // Assert - Should not throw any exception
            Assert.True(true);
        }

        [Fact]
        public void Dispose_CalledTwice_DoesNotThrow()
        {
            // Act
            _service.Dispose();
            _service.Dispose();
            // Assert - Should not throw any exception
            Assert.True(true);
        }

        public virtual void Dispose()
        {
            _service?.Dispose();
        }
    }
}